<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PcapDotNet.Packets</name>
    </assembly>
    <members>
        <member name="T:PcapDotNet.Packets.Transport.TransportDatagram">
            <summary>
            Contains the common part of UDP and TCP.
            
            <para>
            Format:
            <pre>
            +-----+-------------+----------+-----+-----+-----+-----+-----+-----+------------------+
            | Bit | 0-4         | 4-9      | 10  | 11  | 12  | 13  | 14  | 15  | 16-31            |
            +-----+-------------+----------+-----+-----+-----+-----+-----+-----+------------------+
            | 0   | Source Port                                                | Destination Port |
            +-----+------------------------------------------------------------+------------------+
            | 32  | Sequence Number                                                               |
            +-----+-------------------------------------------------------------------------------+
            </pre>
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Datagram">
            <summary>
            Represents a packet datagram.
            A datagram is part of the packet bytes that can be treated as a specific protocol data (usually header + payload).
            Never copies the given buffer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.DataSegment">
            <summary>
            Represents segement of a byte array.
            Never copies the given buffer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.#ctor(System.Byte[])">
            <summary>
            Take all the bytes as a segment.
            </summary>
            <param name="buffer">The buffer to take as a segment.</param>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Take only part of the bytes as a segment.
            </summary>
            <param name="buffer">The bytes to take the segment from.</param>
            <param name="offset">The offset in the buffer to start taking the bytes from.</param>
            <param name="length">The number of bytes to take.</param>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.Subsegment(System.Int32,System.Int32)">
            <summary>
            Creates a subsegment starting from a given offset in the segment taking a given number of bytes.
            </summary>
            <param name="offset">The offset in the segment to start taking.</param>
            <param name="length">The number of bytes to take from the segment.</param>
            <returns>A new DataSegment that is part of the given DataSegment.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ToMemoryStream">
            <summary>
            Returns the Segment's bytes as a read only MemoryStream with a non-public buffer.
            </summary>
            <returns>A read only MemoryStream containing the bytes of the segment.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.GetEnumerator">
            <summary>
            Iterate through all the bytes in the segment.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.Equals(PcapDotNet.Packets.DataSegment)">
            <summary>
            Two segments are equal if they have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.Equals(System.Object)">
            <summary>
            Two segments are equal if they have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.GetHashCode">
            <summary>
            The hash code of a segment is the hash code of its length xored with all its bytes (each byte is xored with the next byte in the integer).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ToString">
            <summary>
            Creates a string starting with the number of bytes the data segment contains 
            and ending with the first 10 bytes of the data segment as hexadecimal digits.
            </summary>
            <returns>
            A string starting with the number of bytes the data segment contains 
            and ending with the first 10 bytes of the data segment as hexadecimal digits.
            </returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ToHexadecimalString">
            <summary>
            Converts the segment to a hexadecimal string representing every byte as two hexadecimal digits.
            </summary>
            <returns>A hexadecimal string representing every byte as two hexadecimal digits.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.Decode(System.Text.Encoding)">
            <summary>
            Converts the segment to a string using the given encoding.
            </summary>
            <param name="encoding">The encoding to use to convert the bytes sequence in the segment to a string.</param>
            <returns>A string of the bytes in the segment converted using the given encoding.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadBytes(System.Int32,System.Int32)">
            <summary>
            Reads a requested number of bytes from a specific offset in the segment.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>The bytes read from the segment starting from the given offset and in the given length.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadUShort(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset in the segment as a ushort with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadInt(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the segment as an int with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadUInt(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the segment as a uint with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadUInt48(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset in the segment as a UInt48 with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadMacAddress(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset in the segment as a MacAddress with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadIpV4Address(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the segment as an IpV4Address with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadIpV4TimeOfDay(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the segment as an IpV4TimeOfDay with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.ReadIpV6Address(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the segment as an IpV4Address with a given endianity.
            </summary>
            <param name="offset">The offset in the segment to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.Sum16BitsToChecksum(System.UInt32)">
            <summary>
            Converts the given 16 bits sum to a checksum.
            Sums the two 16 bits in the 32 bits value and if the result is bigger than a 16 bits value repeat.
            The result is one's complemented and the least significant 16 bits are taken.
            </summary>
            <param name="sum"></param>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.DataSegment.Sum16Bits(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sums bytes in a buffer as 16 bits big endian values.
            If the number of bytes is odd then a 0x00 value is assumed after the last byte.
            Used to calculate checksum.
            </summary>
            <param name="buffer">The buffer to take the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>A value equals to the sum of all 16 bits big endian values of the given bytes.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.DataSegment.Length">
            <summary>
            The number of bytes in this segment.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataSegment.Item(System.Int32)">
            <summary>
            The value of the byte in the given offset in the segment.
            </summary>
            <param name="offset">The offset in the segment to take the byte from.</param>
        </member>
        <member name="P:PcapDotNet.Packets.DataSegment.Last">
            <summary>
            Returns the last byte of the segment.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataSegment.Empty">
            <summary>
            An empty DataSegment.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataSegment.Buffer">
            <summary>
            The original buffer that holds all the data for the segment.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataSegment.StartOffset">
            <summary>
            The offset of the first byte of the segment in the buffer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.#ctor(System.Byte[])">
            <summary>
            Take all the bytes as a datagram.
            </summary>
            <param name="buffer">The buffer to take as a datagram.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Take only part of the bytes as a datagram.
            </summary>
            <param name="buffer">The bytes to take the datagram from.</param>
            <param name="offset">The offset in the buffer to start taking the bytes from.</param>
            <param name="length">The number of bytes to take.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.CalculateIsValid">
            <summary>
            The default validity check always returns true.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.Empty">
            <summary>
            An empty datagram.
            Useful for empty payloads.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.IsValid">
            <summary>
            A datagram is checked for validity according to the protocol.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.SourcePort">
            <summary>
            Indicates the port of the sending process.
            In UDP, this field is optional and may only be assumed to be the port 
            to which a reply should be addressed in the absence of any other information.
            If not used in UDP, a value of zero is inserted.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.DestinationPort">
            <summary>
            Destination Port has a meaning within the context of a particular internet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the Transport header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.IsChecksumOptional">
            <summary>
            True iff the checksum for the transport type is optional.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.Payload">
            <summary>
            The payload of the transport datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionEcho">
            <summary>
            TCP Echo Option:
            <pre>
            +--------+--------+--------+--------+--------+--------+
            | Kind=6 | Length |   4 bytes of info to be echoed    |
            +--------+--------+--------+--------+--------+--------+
            </pre>
            
            <para>
            This option carries four bytes of information that the receiving TCP may send back in a subsequent TCP Echo Reply option.  
            A TCP may send the TCP Echo option in any segment, but only if a TCP Echo option was received in a SYN segment for the connection.
            </para>
            
            <para>
            When the TCP echo option is used for RTT measurement, it will be included in data segments, 
            and the four information bytes will define the time at which the data segment was transmitted in any format convenient to the sender.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionComplex">
            <summary>
            Represents a complex TCP option.
            Complex option means that it contains data and not just the type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOption">
            <summary>
            Represents a TCP option according to rfc 793. 
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Option">
            <summary>
            A generic option (for IPv4 and TCP).
            The option is read from buffer and can be of different length.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Option.Equivalent(PcapDotNet.Packets.Option)">
            <summary>
            Checks whether two options have equivalent type.
            Useful to check if an option that must appear at most once appears in the list.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Option.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Option.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.Equivalent(PcapDotNet.Packets.Option)">
            <summary>
            Checks whether two options have equivalent type.
            Useful to check if an option that must appear at most once appears in the list.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.Equals(System.Object)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.GetHashCode">
            <summary>
            The hash code for a tcp option is the hash code for the option type.
            This should be overridden by tcp options with data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.ToString">
            <summary>
            The string that represents the option type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.#ctor(PcapDotNet.Packets.Transport.TcpOptionType)">
            <summary>
            Initializes the option type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOption.End">
            <summary>
            This option code indicates the end of the option list.  
            This might not coincide with the end of the TCP header according to the Data Offset field.  
            This is used at the end of all options, not the end of each option, 
            and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOption.Nop">
            <summary>
            This option code may be used between options, 
            for example, to align the beginning of a subsequent option on a word boundary.
            There is no guarantee that senders will use this option, 
            so receivers must be prepared to process options even if they do not begin on a word boundary.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOption.OptionType">
            <summary>
            The type of the TCP option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionComplex.OptionHeaderLength">
            <summary>
            The number of bytes this option header take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionComplex.#ctor(PcapDotNet.Packets.Transport.TcpOptionType)">
            <summary>
            Creates a complex option using the given option type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IOptionComplexFactory">
            <summary>
            This interface is used to create all complex options.
            Every complex option should implement such a factory to create itself from a buffer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IOptionComplexFactory.CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEcho.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEcho.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given echo info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.#ctor">
            <summary>
            The default info is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.Equals(PcapDotNet.Packets.Transport.TcpOptionEcho)">
            <summary>
            Two echo options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two echo options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.GetHashCode">
            <summary>
            The hash code of the echo option is the hash code of the option type xored with the hash code info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEcho.Info">
            <summary>
            The info value of the option to be echoed.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEcho.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEcho.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Packet">
            <summary>
            A raw packet.
            Includes all packet layers as taken from an adapter including the type of the datalink.
            Immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.FromHexadecimalString(System.String,System.DateTime,PcapDotNet.Packets.DataLinkKind)">
            <summary>
            Creates a packet from a string that represents bytes in a hexadecimal format.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.#ctor(System.Byte[],System.DateTime,PcapDotNet.Packets.DataLinkKind)">
            <summary>
            Create a packet from an array of bytes.
            </summary>
            <param name="data">The bytes of the packet. This array should not be changed after creating the packet until the packet is no longer used.</param>
            <param name="timestamp">A timestamp of the packet - when it was captured.</param>
            <param name="dataLink">The type of the datalink of the packet.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.#ctor(System.Byte[],System.DateTime,PcapDotNet.Packets.IDataLink)">
            <summary>
            Create a packet from an array of bytes.
            </summary>
            <param name="data">The bytes of the packet. This array should not be changed after creating the packet until the packet is no longer used.</param>
            <param name="timestamp">A timestamp of the packet - when it was captured.</param>
            <param name="dataLink">The type of the datalink of the packet.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Equals(PcapDotNet.Packets.Packet)">
            <summary>
            Equals means that the packets have equal data.
            </summary>
            <param name="other">The packet to compare this packet to.</param>
            <returns>True iff the packets have equal data.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Equals(System.Object)">
            <summary>
            Equals means that the packets have equal data.
            </summary>
            <param name="obj">The packet to compare this packet to.</param>
            <returns>True iff the packets have equal data.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.GetHashCode">
            <summary>
            The hash code of a packet is the xor of all its bytes. Each byte is xored with the next 8 bits of the integer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.ToString">
            <summary>
            The Packet string contains the datalink and the length.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bytes of the packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.IndexOf(System.Byte)">
            <summary>
            Returns the first offset in the packet that contains the given byte.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Insert(System.Int32,System.Byte)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.RemoveAt(System.Int32)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Add(System.Byte)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Clear">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Contains(System.Byte)">
            <summary>
            Determines whether the packet contains a specific byte.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the bytes of the packet to a buffer, starting at a particular offset.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Remove(System.Byte)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Length">
            <summary>
            The number of bytes this packet take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Timestamp">
            <summary>
            The time this packet was captured.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.DataLink">
            <summary>
            The type of the datalink of the device this packet was captured from.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Buffer">
            <summary>
            The underlying array of bytes.
            When taking this array the caller is responsible to make sure this array will not be modified while the packet is still in use.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Item(System.Int32)">
            <summary>
            Returns the value of the byte in the given offset.
            Set operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Count">
            <summary>
            Returns the number of bytes in this packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.IsReadOnly">
            <summary>
            True since this object is read only.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.IsValid">
            <summary>
             True iff the packet is valid.
             The packet is valid unless an invalid part of it was found.
             Examples for invalid parts:
             * Bad checksum.
             * An illegal value for a field.
             * Length of packet is too short for a header or according to a length field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Ethernet">
            <summary>
            Takes the entire packet as an Ethernet datagram.
            Please note that if the DataLink is not Ethernet, this should make no sense.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.IpV4">
            <summary>
            Takes the entire packet as an IPv4 datagram.
            Please note that if the DataLink is not IPv4, this should make no sense.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Option">
            <summary>
            Represents an ip option according to rfc 791. 
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.Equivalent(PcapDotNet.Packets.Option)">
            <summary>
            Checks whether two options have equivalent type.
            Useful to check if an option that must appear at most once appears in the list.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.Equals(System.Object)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.GetHashCode">
            <summary>
            The hash code of the option is the hash code of the option type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.ToString">
            <summary>
            The string of the option is the string of the option type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType)">
            <summary>
            Constructs the option by type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Option.End">
            <summary>
             This option indicates the end of the option list.<br/>
             This might not coincide with the end of the internet header according to the internet header length.
             This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the internet header.
             May be copied, introduced, or deleted on fragmentation, or for any other reason.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Option.Nop">
            <summary>
            This option may be used between options, for example, to align the beginning of a subsequent option on a 32 bit boundary.
            May be copied, introduced, or deleted on fragmentation, or for any other reason.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Option.OptionType">
            <summary>
            The type of the ip option.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpVersion1Layer">
            <summary>
            RFC 1112.
            Represents an IGMP version 1 layer.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpSimpleLayer">
            <summary>
            Represents a Simple IGMP layer.
            A simple layer only has the 8 bytes header without additional fields.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpLayer">
            <summary>
            The base of all IGMP layers.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.SimpleLayer">
            <summary>
            A simple layer is a layer that doesn't care what is the length of its payload, what layer comes after it and what layer comes before it.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Layer">
            <summary>
            The base class of a layer used to build a Packet.
            Each layer represents the part of the packet relevant to a specific protocol.
            A sequence of layers can represent a packet.
            A packet can be according to a sequence of layers.
            <seealso cref="T:PcapDotNet.Packets.PacketBuilder"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.ILayer">
            <summary>
            The interface of a layer used to build a Packet.
            Each layer represents the part of the packet relevant to a specific protocol.
            A sequence of layers can represent a packet.
            A packet can be according to a sequence of layers.
            <seealso cref="T:PcapDotNet.Packets.PacketBuilder"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.ILayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ILayer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="P:PcapDotNet.Packets.ILayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.ILayer.DataLink">
            <summary>
            The kind of the data link of the layer.
            Can be null if this is not the first layer in the packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Equals(System.Object)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code base is a XOR of the hash codes of the layer length and data link.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Layer.DataLink">
            <summary>
            The kind of the data link of the layer.
            Can be null if this is not the first layer in the packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.SimpleLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.SimpleLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IIpV4NextLayer">
            <summary>
            A layer under an IPv4 layer.
            Must provide the IPv4 Protocol.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.Equals(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            IGMP layers are equal if they have the same message type, query version, similar max response time and the same specific type fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            IGMP layers are equal if they have the same message type, query version, similar max response time and the same specific type fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.GetHashCode">
            <summary>
            Xor of the hash codes of the layer length, datalink, message type and query version.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the fields that are not mutual to all IGMP layers are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IIgmpLayerWithGroupAddress">
            <summary>
            Represents an IGMP layer that contains a Group Address.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IIgmpLayerWithGroupAddress.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.GetHashCode">
            <summary>
            Xor of the hash codes of the layer length, datalink, message type, query version and group address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the the group address is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.EqualFields(PcapDotNet.Packets.Igmp.IgmpSimpleLayer)">
            <summary>
            true iff the the group address is equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpVersion1Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReportVersion1Layer">
            <summary>
            RFC 1112.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion1Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode">
            <summary>
            The different ICMP message types and codes.
            Each of the values is a combination of the message type and a code values that is legal with this message type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableNetUnreachable">
            <summary>
            RFC 792.
            If, according to the information in the gateway's routing tables, 
            the network specified in the internet destination field of a datagram is unreachable, 
            e.g., the distance to the network is infinity, 
            the gateway may send a destination unreachable message to the internet source host of the datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableHostUnreachable">
            <summary>
            RFC 792.
            In some networks, the gateway may be able to determine if the internet destination host is unreachable.  
            Gateways in these networks may send destination unreachable messages to the source host when the destination host is unreachable.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableProtocolUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated protocol module is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachablePortUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated process port is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableFragmentationNeededAndDoNotFragmentSet">
            <summary>
            RFC 792.
            A datagram must be fragmented to be forwarded by a gateway yet the Don't Fragment flag is on.  
            In this case the gateway must discard the datagram and may return a destination unreachable message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableSourceRouteFailed">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TimeExceededTimeToLive">
            <summary>
            RFC 792.
            If the gateway processing a datagram finds the time to live field is zero it must discard the datagram.  
            The gateway may also notify the source host via the time exceeded message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TimeExceededFragmentReassembly">
            <summary>
            RFC 792.
            If a host reassembling a fragmented datagram cannot complete the reassembly due to missing fragments within its time limit it discards the datagram, 
            and it may send a time exceeded message.
            If fragment zero is not available then no time exceeded need be sent at all.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ParameterProblemPointerIndicatesTheError">
            <summary>
            RFC 792.
            If the gateway or host processing a datagram finds a problem with the header parameters such that it cannot complete processing the datagram it must discard the datagram.  
            One potential source of such a problem is with incorrect arguments in an option.  
            The gateway or host may also notify the source host via the parameter problem message. 
            This message is only sent if the error caused the datagram to be discarded.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SourceQuench">
            <summary>
            RFC 792.
            
            <para>
            A gateway may discard internet datagrams if it does not have the buffer space needed to queue the datagrams for output to the next network on the route to the destination network.  
            If a gateway discards a datagram, it may send a source quench message to the internet source host of the datagram.  
            A destination host may also send a source quench message if datagrams arrive too fast to be processed.  
            The source quench message is a request to the host to cut back the rate at which it is sending traffic to the internet destination.  
            The gateway may send a source quench message for every message that it discards.  
            On receipt of a source quench message, the source host should cut back the rate at which it is sending traffic to the specified destination 
            until it no longer receives source quench messages from the gateway.  
            The source host can then gradually increase the rate at which it sends traffic to the destination until it again receives source quench messages.
            </para>
            
            <para>
            The gateway or host may send the source quench message when it approaches its capacity limit rather than waiting until the capacity is exceeded.  
            This means that the data datagram which triggered the source quench message may be delivered.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheTypeOfServiceAndNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheTypeOfServiceAndHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.Echo">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>        
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.EchoReply">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>        
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.Timestamp">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TimestampReply">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.InformationRequest">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.InformationReply">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RouterAdvertisement">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RouterSolicitation">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.AddressMaskRequest">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.AddressMaskReply">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TraceRouteOutboundPacketSuccessfullyForwarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TraceRouteNoRouteForOutboundPacketDiscarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnknownOrUnspecifiedError">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedDoNotConvertOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnknownMandatoryOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedKnownUnsupportedOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnsupportedTransportProtocol">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedOverallLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedIpHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedTransportProtocolIsBiggerThan255">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedPortConversionOutOfRange">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedTransportHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailed32BitRolloverMissingAndAckSet">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnknownMandatoryTransportOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DomainNameRequest">
            <summary>
            RFC 1788.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DomainNameReply">
            <summary>
            RFC 1788.
            Parsing of this datagram isn't supported because its parsing is not clear from the RFC.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresBadSecurityParametersIndex">
            <summary>
            RFC 2521.
            Indicates that a received datagram includes a Security Parameters Index (SPI) that is invalid or has expired.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresAuthenticationFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed the authenticity or integrity check for a given SPI.
            
            <para>
            Note that the SPI may indicate an outer Encapsulating Security Protocol when a separate Authentication Header SPI is hidden inside.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresDecompressionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decompression check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresDecryptionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decryption check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresNeedAuthentication">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted without additional authentication.
            
            <para>
            In this case, either no SPI is present, or an unsuitable SPI is present.  
            For example, an encryption SPI without integrity arrives from a secure operating system with mutually suspicious users.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresNeedAuthorization">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted because it has insufficient authorization.
            
            <para>
            In this case, an authentication SPI is present that is inappropriate for the target transport or application.  
            The principle party denoted by the SPI does not have proper authorization for the facilities used by the datagram.  
            For example, the party is authorized for Telnet access, but not for FTP access.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram">
            <summary>
            RFC 2521.
            <pre>
            +-----+------+------+----------+
            | Bit | 0-7  | 8-15 | 16-31    |
            +-----+------+------+----------+
            | 0   | Type | Code | Checksum |
            +-----+------+------+----------+
            | 32  | Reserved    | Pointer  |
            +-----+-------------+----------+
            | 64  | Internet Header        |
            |     | + 64 bits of           |
            |     | Original Data Datagram |
            +-----+------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIpV4HeaderPlus64BitsPayloadDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | Internet Header         |
            |     | + 64 bits of            |
            |     | Original Data Datagram  |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIpV4PayloadDatagram">
            <summary>
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | IpV4 datagram           |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDatagram">
            <summary>
            Generic
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | Value according to Type |
            +-----+-------------------------+
            | 64  | Payload                 |
            | ... |                         |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpDatagram.HeaderLength">
            <summary>
            The number of bytes the ICMP header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDatagram.CalculateIsValid">
            <summary>
            ICMP is valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDatagram.CreateDatagram(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an IcmpDatagram from a buffer according to the message type.
            </summary>
            <param name="buffer">The buffer of the datagram.</param>
            <param name="offset">The offset where the datagram starts.</param>
            <param name="length">The length of the datagram in the buffer.</param>
            <returns>An IcmpDatagram according to the Icmp message type.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MessageTypeAndCode">
            <summary>
            A combination of the ICMP Message Type and Code.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Checksum">
            <summary>
            The checksum is the 16-bit ones's complement of the one's complement sum of the ICMP message starting with the ICMP Type.
            For computing the checksum, the checksum field should be zero.
            This checksum may be replaced in the future.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.IsChecksumCorrect">
            <summary>
            True iff the checksum value is correct according to the datagram data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Payload">
            <summary>
            The payload of the ICMP.
            All the data without the header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpIpV4PayloadDatagram.CalculateIsValid">
            <summary>
            ICMP with IPv4 payload is valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            and the IPv4 payload contains at least an IPv4 header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIpV4PayloadDatagram.IpV4">
            <summary>
            The ICMP payload as an IPv4 datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpIpV4HeaderPlus64BitsPayloadDatagram.OriginalDatagramPayloadLength">
            <summary>
            The number of bytes this payload includes from the original data datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpIpV4HeaderPlus64BitsPayloadDatagram.CalculateIsValid">
            <summary>
            ICMP with IPv4 payload and 64 bits IPv4 payload is valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header and the IPv4's payload is in the expected size.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header, the IPv4's payload is in the expected size and the Pointer points to a byte in the IPv4 payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.Pointer">
            <summary>
            An offset into the Original Internet Headers that locates the most significant octet of the offending SPI.  
            Will be zero when no SPI is present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpLayer">
            <summary>
            Represents an ICMP layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for the ICMP checksum.
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Equals(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            ICMP layers are equal if they have the same message type, code, checksum, variable and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            ICMP layers are equal if they have the same message type, code, checksum, variable and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the layer length, data link, message type and code, checksum and variable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.ToString">
            <summary>
            Returns a string containing the message type, code and variable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the ICMP payload is equal to the other ICMP payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.MessageTypeAndCode">
            <summary>
            A combination of the ICMP Message Type and Code.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.Checksum">
            <summary>
            The checksum is the 16-bit ones's complement of the one's complement sum of the ICMP message starting with the ICMP Type.
            For computing the checksum, the checksum field should be zero.
            This checksum may be replaced in the future.
            null means that this checksum should be calculated to be correct.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestDatagram">
            <summary>
            RFC 1788.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIdentifiedDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedDatagram.Identifier">
            <summary>
            An identifier to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedDatagram.SequenceNumber">
            <summary>
            A sequence number to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpLayer">
            <summary>
            RFC 2616.
            Represents an HTTP layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two HTTP layers are equal iff they have the same version, header and body.
            Extended by specific HTTP layers types for more checks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpLayer.Equals(PcapDotNet.Packets.Http.HttpLayer)">
            <summary>
            Two HTTP layers are equal iff they have the same version, header and body.
            Extended by specific HTTP layers types for more checks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the HTTP layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.IsRequest">
            <summary>
            True iff the message is a request and iff the message is not a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.IsResponse">
            <summary>
            True iff the message is a response and iff the message is not a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Version">
            <summary>
            The version of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Header">
            <summary>
            The header of the HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Body">
            <summary>
            Message Body.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs">
            <summary>
            RFC 1702.
            Represents a source route entry consisting of a list of Autonomous System numbers and indicates an AS source route.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntry">
            <summary>
            RFC 1701.
            SRE.
            <pre>
            +-----+----------------+------------+------------+
            | Bit | 0-15           | 16-23      | 24-31      |
            +-----+----------------+------------+------------+
            | 0   | Address Family | SRE Offset | SRE Length |
            +-----+----------------+------------+------------+
            | 32  | Routing Information ...                  |
            +-----+------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntry.HeaderLength">
            <summary>
            The number of bytes the entry header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.Equals(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            Two entries are equal iff they have the same address family, length, payload offset and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.Equals(System.Object)">
            <summary>
            Two entries are equal iff they have the same address family, length, payload offset and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.GetHashCode">
            <summary>
            The hash code of an entry is a xor of the hash code of the address family, length, payload offset and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the payloads a are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.Length">
            <summary>
            The number of bytes the entry takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.PayloadHashCode">
            <summary>
            The hash code of the payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.UInt16},System.Int32)">
            <summary>
            Initializes using the given AS numbers and the next as number index.
            </summary>
            <param name="asNumbers">Autonomous System numbers of the source route.</param>
            <param name="nextAsNumberIndex">The next AS number index in the source route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the AS numbers are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.PayloadHashCode">
            <summary>
            The xor of the hash code of the AS numbers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.AsNumbers">
            <summary>
            Autonomous System numbers of the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.NextAsNumberIndex">
            <summary>
            The next AS number index in the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.NextAsNumber">
            <summary>
            The next AS number.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetType">
            <summary>
            EtherType is a two-octet field in an Ethernet frame, as defined by the Ethernet II framing networking standard. 
            It is used to indicate which protocol is encapsulated in the payload.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.None">
            <summary>
            No Ethernet type
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.IpV4">
            <summary>
            Internet Protocol, Version 4 (IPv4)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.Arp">
            <summary>
            Address Resolution Protocol (ARP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ReverseArp">
            <summary>
            Reverse Address Resolution Protocol (RARP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AppleTalk">
            <summary>
            AppleTalk (Ethertalk)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AppleTalkArp">
            <summary>
            AppleTalk Address Resolution Protocol (AARP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.VLanTaggedFrame">
            <summary>
            VLAN-tagged frame (IEEE 802.1Q)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.NovellInternetworkPacketExchange">
            <summary>
            Novell IPX (alt)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.Novell">
            <summary>
            Novell
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.IpV6">
            <summary>
            Internet Protocol, Version 6 (IPv6)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MacControl">
            <summary>
            MAC Control
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PointToPointProtocol">
            <summary>
            PPP, Point-to-Point Protocol
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.CobraNet">
            <summary>
            CobraNet
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MultiprotocolLabelSwitchingUnicast">
            <summary>
            MPLS unicast
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MultiprotocolLabelSwitchingMulticast">
            <summary>
            MPLS multicast
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PointToPointProtocolOverEthernetDiscoveryStage">
            <summary>
            PPPoE Discovery Stage
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PointToPointProtocolOverEthernetSessionStage">
            <summary>
            PPPoE Session Stage 
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ExtensibleAuthenticationProtocolOverLan">
            <summary>
            EAP over LAN (IEEE 802.1X)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.HyperScsi">
            <summary>
            HyperSCSI (SCSI over Ethernet)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AtaOverEthernet">
            <summary>
            ATA over Ethernet
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.EtherCatProtocol">
            <summary>
            EtherCAT Protocol
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ProviderBridging">
            <summary>
            Provider Bridging (IEEE 802.1ad)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AvbTransportProtocol">
            <summary>
            AVB Transport Protocol (AVBTP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.SerialRealTimeCommunicationSystemIii">
            <summary>
            SERCOS III
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.CircuitEmulationServicesOverEthernet">
            <summary>
            Circuit Emulation Services over Ethernet (MEF-8)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.HomePlug">
            <summary>
            HomePlug
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MacSecurity">
            <summary>
            MAC security (IEEE 802.1AE)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PrecisionTimeProtocol">
            <summary>
            Precision Time Protocol (IEEE 1588)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ConnectivityFaultManagementOrOperationsAdministrationManagement">
            <summary>
            IEEE 802.1ag Connectivity Fault Management (CFM) Protocol / ITU-T Recommendation Y.1731 (OAM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.FibreChannelOverEthernet">
            <summary>
            Fibre Channel over Ethernet
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.FibreChannelOverEthernetInitializationProtocol">
            <summary>
            FCoE Initialization Protocol
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.QInQ">
            <summary>
            Q-in-Q
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.VeritasLowLatencyTransport">
            <summary>
            Veritas Low Latency Transport (LLT)
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority">
            <summary>
            RFC 1035.
            <pre>
            +-------+---------+
            | bit   | 0-31    |
            +-------+---------+
            | 0     | MNAME   |
            | ...   |         |
            +-------+---------+
            | X     | RNAME   |
            | ...   |         |
            +-------+---------+
            | Y     | SERIAL  |
            +-------+---------+
            | Y+32  | REFRESH |
            +-------+---------+
            | Y+64  | RETRY   |
            +-------+---------+
            | Y+96  | EXPIRE  |
            +-------+---------+
            | Y+128 | MINIMUM |
            +-------+---------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceData">
            <summary>
            RFC 1035.
            Represents a resource record data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceData.GetDnsResourceDataType(PcapDotNet.Packets.Dns.DnsType)">
            <summary>
            Returns the DnsResourceData concrete type that should be created for the given DnsType.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Base.SerialNumber32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructs an instance out of the main name server, responsible mailbox, serial, refresh, retry, expire and minimum TTL fields.
            </summary>
            <param name="mainNameServer">The domain-name of the name server that was the original or primary source of data for this zone.</param>
            <param name="responsibleMailbox">A domain-name which specifies the mailbox of the person responsible for this zone.</param>
            <param name="serial">
            The unsigned 32 bit version number of the original copy of the zone.
            Zone transfers preserve this value.
            This value wraps and should be compared using sequence space arithmetic.
            </param>
            <param name="refresh">A 32 bit time interval before the zone should be refreshed.</param>
            <param name="retry">A 32 bit time interval that should elapse before a failed refresh should be retried.</param>
            <param name="expire">
            A 32 bit time value that specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.
            </param>
            <param name="minimumTtl">The unsigned 32 bit minimum TTL field that should be exported with any RR from this zone.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.Equals(PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority)">
            <summary>
            Two DnsResourceDataStartOfAuthority are equal iff their main name server, responsible mailbox, serial, refresh, retry, expire 
            and minimum TTL fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.Equals(System.Object)">
            <summary>
            Two DnsResourceDataStartOfAuthority are equal iff their main name server, responsible mailbox, serial, refresh, retry, expire 
            and minimum TTL fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.GetHashCode">
            <summary>
            A hash code based on the main name server, responsible mailbox, serial, refresh, retry, expire and minimum TTL fields
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.MainNameServer">
            <summary>
            The domain-name of the name server that was the original or primary source of data for this zone.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.ResponsibleMailbox">
            <summary>
            A domain-name which specifies the mailbox of the person responsible for this zone.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.Serial">
            <summary>
            The unsigned 32 bit version number of the original copy of the zone.
            Zone transfers preserve this value.
            This value wraps and should be compared using sequence space arithmetic.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.Refresh">
            <summary>
            A 32 bit time interval before the zone should be refreshed.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.Retry">
            <summary>
            A 32 bit time interval that should elapse before a failed refresh should be retried.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.Expire">
            <summary>
            A 32 bit time value that specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataStartOfAuthority.MinimumTtl">
            <summary>
            The unsigned 32 bit minimum TTL field that should be exported with any RR from this zone.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataAfsDatabase">
            <summary>
            RFC 1183.
            <pre>
            +-----+----------+
            | bit | 0-15     |
            +-----+----------+
            | 0   | subtype  |
            +-----+----------+
            | 16  | hostname |
            | ... |          |
            +-----+----------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataUShortDomainName">
            <summary>
            A base class for any resource data that contains a 16 bit unsigned integer followed by a domain name.
            <pre>
            +-----+--------+
            | bit | 0-15   |
            +-----+--------+
            | 0   | Value  |
            +-----+--------+
            | 16  | Domain |
            | ... |        |
            +-----+--------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataUShortDomainName.Equals(PcapDotNet.Packets.Dns.DnsResourceDataUShortDomainName)">
            <summary>
            Two DnsResourceDataUShortDomainName are equal iff their of the same type and their ushort values and domain names are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataUShortDomainName.Equals(System.Object)">
            <summary>
            Two DnsResourceDataUShortDomainName are equal iff their of the same type and their ushort values and domain names are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataUShortDomainName.GetHashCode">
            <summary>
            A hash code based on the type, ushort value and domain name.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAfsDatabase.#ctor(PcapDotNet.Packets.Dns.DnsAfsDatabaseSubtype,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs an AFS database resource data from the given subtype and host name.
            </summary>
            <param name="subtype">The subtype of the resource data.</param>
            <param name="hostName">A host that has a server for the cell named by the owner name of the RR.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataAfsDatabase.Subtype">
            <summary>
            The subtype of the resource data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataAfsDatabase.HostName">
            <summary>
            A host that has a server for the cell named by the owner name of the RR.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptionCode">
            <summary>
            The option code for a DNS option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOptionCode.None">
            <summary>
            No code defined.
            Should not be used.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOptionCode.LongLivedQuery">
            <summary>
            http://files.dns-sd.org/draft-sekar-dns-llq.txt.
            LLQ.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOptionCode.UpdateLease">
            <summary>
            http://files.dns-sd.org/draft-sekar-dns-ul.txt.
            UL.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOptionCode.NameServerIdentifier">
            <summary>
            RFC 5001.
            NSID.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsFingerprintPublicKeyAlgorithm">
            <summary>
            RFC 4255.
            Describes the algorithm of the public key.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsFingerprintPublicKeyAlgorithm.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsFingerprintPublicKeyAlgorithm.Rsa">
            <summary>
            RSA algorithm.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsFingerprintPublicKeyAlgorithm.Dss">
            <summary>
            DSS algorithm.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptResourceRecord">
            <summary>
            RFC 2671.
            <pre>
            +------+----------------+----------+
            | bit  | 0-7            | 8-15     |
            +------+----------------+----------+
            | 0    | Name                      |
            | ...  |                           |
            +------+---------------------------+
            |      | Type = OPT                |
            +------+---------------------------+
            |      | Sender's UDP payload size |
            +------+----------------+----------+
            |      | EXTENDED-RCODE | VERSION  |
            +------+----------------+----------+
            |      | Flags                     |
            +------+---------------------------+
            |      | Resource Data Length      |
            +------+---------------------------+
            |      | Resource Data             |
            | ...  |                           |
            +------+---------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsDataResourceRecord">
            <summary>
            RFC 1035.
            A resource record with data.
            Used for the answers, authorities and additionals sections.
            For OPT resource records, DnsOptResourceRecord should be used.
            <pre>
            +------+-------------------------------------------------+
            | byte | 0-1                                             |
            +------+-------------------------------------------------+
            | 0    | Name                                            |
            | ...  |                                                 |
            +------+-------------------------------------------------+
            |      | Type                                            |
            +------+-------------------------------------------------+
            |      | Class                                           |
            +------+-------------------------------------------------+
            |      | TTL                                             |
            |      |                                                 |
            +------+-------------------------------------------------+
            |      | Resource Data Length                            |
            +------+-------------------------------------------------+
            |      | Resource Data                                   |
            | ...  |                                                 |
            +------+-------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceRecord">
            <summary>
            RFC 1035.
            All RRs have the same top level format shown below:
            <pre>
            +------+-------------------------------------------------+
            | byte | 0-1                                             |
            +------+-------------------------------------------------+
            | 0    | Name                                            |
            | ...  |                                                 |
            +------+-------------------------------------------------+
            |      | Type                                            |
            +------+-------------------------------------------------+
            |      | Class                                           |
            +------+-------------------------------------------------+
            |      | TTL (not available in queries)                  |
            |      |                                                 |
            +------+-------------------------------------------------+
            |      | Resource Data Length (not available in queries) |
            +------+-------------------------------------------------+
            |      | Resource Data (not available in queries)        |
            | ...  |                                                 |
            +------+-------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceRecord.ToString">
            <summary>
            A string representing the resource record by concatenating its different parts.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceRecord.DomainName">
            <summary>
            An owner name, i.e., the name of the node to which this resource record pertains.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceRecord.DnsType">
            <summary>
            Two octets containing one of the RR TYPE codes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceRecord.DnsClass">
            <summary>
            Two octets containing one of the RR CLASS codes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceRecord.Ttl">
            <summary>
            A 32 bit signed integer that specifies the time interval that the resource record may be cached before the source of the information should again be consulted.  
            Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached.  
            For example, SOA records are always distributed with a zero TTL to prohibit caching.  
            Zero values can also be used for extremely volatile data.
            Not available in queries.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceRecord.Data">
            <summary>
            A variable length string of octets that describes the resource.  
            The format of this information varies according to the TYPE and CLASS of the resource record.
            For example, the if the TYPE is A and the CLASS is IN, the RDATA field is a 4 octet ARPA Internet address.
            Not available in queries.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDataResourceRecord.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.Dns.DnsType,PcapDotNet.Packets.Dns.DnsClass,System.Int32,PcapDotNet.Packets.Dns.DnsResourceData)">
            <summary>
            Creates a resource record from domain name, type, class, ttl and data.
            </summary>
            <param name="domainName">An owner name, i.e., the name of the node to which this resource record pertains.</param>
            <param name="type">Two octets containing one of the RR TYPE codes.</param>
            <param name="dnsClass">Two octets containing one of the RR CLASS codes.</param>
            <param name="ttl">
            A 32 bit signed integer that specifies the time interval that the resource record may be cached before the source of the information should again be consulted.  
            Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached.  
            For example, SOA records are always distributed with a zero TTL to prohibit caching.  
            Zero values can also be used for extremely volatile data.
            </param>
            <param name="data">
            A variable length string of octets that describes the resource.  
            The format of this information varies according to the TYPE and CLASS of the resource record.
            For example, the if the TYPE is A and the CLASS is IN, the RDATA field is a 4 octet ARPA Internet address.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDataResourceRecord.ToString">
            <summary>
            A string representing the resource record by concatenating its different parts.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDataResourceRecord.Equals(PcapDotNet.Packets.Dns.DnsDataResourceRecord)">
            <summary>
            Two DnsDataResourceRecord are equal iff their domain name, dns type, dns class, ttl and data fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDataResourceRecord.Equals(System.Object)">
            <summary>
            Two DnsDataResourceRecord are equal iff their domain name, dns type, dns class, ttl and data fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDataResourceRecord.GetHashCode">
            <summary>
            A hash code of the combination of the domain name, dns type, dns class, ttl and data fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDataResourceRecord.Ttl">
            <summary>
            A 32 bit signed integer that specifies the time interval that the resource record may be cached before the source of the information should again be consulted.  
            Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached.  
            For example, SOA records are always distributed with a zero TTL to prohibit caching.  
            Zero values can also be used for extremely volatile data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDataResourceRecord.Data">
            <summary>
            A variable length string of octets that describes the resource.  
            The format of this information varies according to the TYPE and CLASS of the resource record.
            For example, the if the TYPE is A and the CLASS is IN, the RDATA field is a 4 octet ARPA Internet address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptResourceRecord.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,System.UInt16,System.Byte,PcapDotNet.Packets.Dns.DnsOptVersion,PcapDotNet.Packets.Dns.DnsOptFlags,PcapDotNet.Packets.Dns.DnsResourceDataOptions)">
            <summary>
            Constructs an instance out of the domain name, senders UDP payload size, extended return code, version, flags and data fields.
            </summary>
            <param name="domainName">An owner name, i.e., the name of the node to which this resource record pertains.</param>
            <param name="sendersUdpPayloadSize">
            The number of octets of the largest UDP payload that can be reassembled and delivered in the sender's network stack.
            Note that path MTU, with or without fragmentation, may be smaller than this.
            </param>
            <param name="extendedReturnCode">
            Forms upper 8 bits of extended 12-bit RCODE.
            Note that EXTENDED-RCODE value "0" indicates that an unextended RCODE is in use (values "0" through "15").
            </param>
            <param name="version">
            Indicates the implementation level of whoever sets it.
            Full conformance with this specification is indicated by version "0".
            Requestors are encouraged to set this to the lowest implemented level capable of expressing a transaction, 
            to minimize the responder and network load of discovering the greatest common implementation level between requestor and responder.
            A requestor's version numbering strategy should ideally be a run time configuration option.
            </param>
            <param name="flags">OPT flags.</param>
            <param name="data">An OPT resource record data</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptResourceRecord.ToString">
            <summary>
            A string representing the resource record by concatenating its different parts.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptResourceRecord.SendersUdpPayloadSize">
            <summary>
            The number of octets of the largest UDP payload that can be reassembled and delivered in the sender's network stack.
            Note that path MTU, with or without fragmentation, may be smaller than this.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptResourceRecord.ExtendedReturnCode">
            <summary>
            Forms upper 8 bits of extended 12-bit RCODE.
            Note that EXTENDED-RCODE value "0" indicates that an unextended RCODE is in use (values "0" through "15").
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptResourceRecord.Version">
            <summary>
            Indicates the implementation level of whoever sets it.
            Full conformance with this specification is indicated by version "0".
            Requestors are encouraged to set this to the lowest implemented level capable of expressing a transaction, 
            to minimize the responder and network load of discovering the greatest common implementation level between requestor and responder.
            A requestor's version numbering strategy should ideally be a run time configuration option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptResourceRecord.Flags">
            <summary>
            OPT flags.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionType">
            <summary>
            The option-type octet is viewed as having 3 fields:
            <list type="table">
              <listheader>
                  <term>Bits</term>
                  <description>Description</description>
              </listheader>
              <item><term>1 bit</term>
                <description>
                  Copied flag.
                  <para>
                    The copied flag indicates that this option is copied into all fragments on fragmentation.
                    <list type="bullet">
                      <item>0 = not copied.</item>
                      <item>1 = copied.</item>
                    </list>
                  </para>
                </description>
              </item>
              <item><term>2 bits</term>
                <description>
                  Option class.
                  <para>
                    The option classes are:
                    <list type="bullet">
                      <item>0 = control.</item>
                      <item>1 = reserved for future use.</item>
                      <item>2 = debugging and measurement.</item>
                      <item>3 = reserved for future use.</item>
                    </list>
                  </para>
                </description>
              </item>
              <item><term>5 bits</term><description>Option number.</description></item>
            </list>
            </summary>
            <remarks>
            <list type="bullet">
              <item>DoD Extended Security Option (133), RFC 1108, is not supported because it only defines abstract option and no concrete option RFC is available.</item>
              <item>EIP: The Extended Internet Protocol, RFC 1385, is not supported because according iana.org its option type is 145 but according to the RFC its option type is 138 (0x8A).</item>
            </list>
            </remarks>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.EndOfOptionList">
            <summary>
            End of Option list.  
            This option occupies only 1 octet; it has no length octet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.NoOperation">
            <summary>
            No Operation.  
            This option occupies only 1 octet; it has no length octet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.QuickStart">
            <summary>
            Quick Start (QS). RFC 4782.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.TraceRoute">
            <summary>
            Traceroute Using an IP Option.
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.BasicSecurity">
            <summary>
            DoD Basic Security:  
            Used to carry the classification level and protection authority flags.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.LooseSourceRouting">
            <summary>
            Loose Source Routing.
            Used to route the internet datagram based on information supplied by the source.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.StrictSourceRouting">
            <summary>
            Strict Source Routing.  
            Used to route the internet datagram based on information supplied by the source.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.RecordRoute">
            <summary>
            Record Route.  
            Used to trace the route an internet datagram takes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.StreamIdentifier">
            <summary>
            Stream ID.  
            Used to carry the stream identifier.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.InternetTimestamp">
            <summary>
            Internet Timestamp.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.RouterAlert">
            <summary>
            Router Alert Option (RFC 2113).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType">
            <summary>
            The type of the timestamp ip option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType.TimestampOnly">
            <summary>
            Time stamps only, stored in consecutive 32-bit words.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType.AddressAndTimestamp">
            <summary>
            Each timestamp is preceded with internet address of the registering entity.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType.AddressPrespecified">
            <summary>
            The internet address fields are prespecified.  
            An IP module only registers its timestamp if it matches its own address with the next specified internet address.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly">
            <summary>
            Represents a timestamp IPv4 option with only the timestamps.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp">
            <summary>
            Internet Timestamp
            <pre>
            +--------+--------+--------+--------+
            |01000100| length | pointer|oflw|flg|
            +--------+--------+--------+--------+
            |         internet address          |
            +--------+--------+--------+--------+
            |             timestamp             |
            +--------+--------+--------+--------+
            |                 .                 |
                              .
                              .
             Type = 68
            </pre>
            
            <para>
            The Option Length is the number of octets in the option counting the type, length, pointer, and overflow/flag octets (maximum length 40).
            </para>
            
            <para>
            The Pointer is the number of octets from the beginning of this option to the end of timestamps plus one 
            (i.e., it points to the octet beginning the space for next timestamp).  
            The smallest legal value is 5.  
            The timestamp area is full when the pointer is greater than the length.
            </para>
            
            <para>
            The Overflow (oflw) [4 bits] is the number of IP modules that cannot register timestamps due to lack of space.
            </para>
            
            <para>
            The Flag (flg) [4 bits] values are
            <list type="bullet">
              <item>0 - time stamps only, stored in consecutive 32-bit words.</item>
              <item>1 - each timestamp is preceded with internet address of the registering entity.</item>
              <item>3 - the internet address fields are prespecified.</item>
            </list>
            An IP module only registers its timestamp if it matches its own address with the next specified internet address.
            </para>
            
            <para>
            The Timestamp is a right-justified, 32-bit timestamp in milliseconds since midnight UT.  
            If the time is not available in milliseconds or cannot be provided with respect to midnight UT 
            then any time may be inserted as a timestamp provided the high order bit of the timestamp field is set to one 
            to indicate the use of a non-standard value.
            </para>
            
            <para>
            The originating host must compose this option with a large enough timestamp data area to hold all the timestamp information expected.  
            The size of the option does not change due to adding timestamps.  
            The intitial contents of the timestamp data area must be zero or internet address/zero pairs.
            </para>
            
            <para>
            If the timestamp data area is already full (the pointer exceeds the length) the datagram is forwarded without inserting the timestamp, 
            but the overflow count is incremented by one.
            If there is some room but not enough room for a full timestamp to be inserted, or the overflow count itself overflows, 
            the original datagram is considered to be in error and is discarded.
            In either case an ICMP parameter problem message may be sent to the source host.
            </para>
            
            <para>
            The timestamp option is not copied upon fragmentation.  
            It is carried in the first fragment.  
            Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionComplex">
            <summary>
            Represents a complex IPv4 option.
            Complex option means that it contains data and not just the type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionComplex.OptionHeaderLength">
            <summary>
            The header length in bytes for the option (type and size).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionComplex.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType)">
            <summary>
            Constructs the option by type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.OptionMinimumLength">
            <summary>
            The minimum length in bytes for the option (type, length, pointer, overflow and flags).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.OptionValueMinimumLength">
            <summary>
            The minimum length in bytes of the option value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.OverflowMaxValue">
            <summary>
            The maximum value for the overflow field.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.PointedIndexMaxValue">
            <summary>
            The maximum value for the pointed index field.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Equals(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            Two options are equal if they have the same value (timestamp, overflow, pointed equals, addresses and timestamps).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two options are equal if they have the same value (timestamp, overflow, pointed equals and addresses).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code, the timestamp and overflow hash code and the pointed index hash code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionTimestampType,System.Byte,System.Byte)">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="timestampType">The timestamp option type.</param>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp to points to the octet beginning the space for next timestamp. The timestamp area is considered full when the index points beyond the timestamps.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.EqualValues(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            True iff the options values is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.WriteValues(System.Byte[],System.Int32@)">
            <summary>
            Writes the value of the option to the buffer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.TimestampType">
            <summary>
            The timestamp option type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Overflow">
            <summary>
            The number of IP modules that cannot register timestamps due to lack of space.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.PointedIndex">
            <summary>
            The index in the timestamp that points to the for next timestamp. 
            The timestamp area is considered full when the index points beyond the timestamps.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.CountTimestamps">
            <summary>
            The number of timestamps this option holds (or can hold).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.ValuesLength">
            <summary>
            The number of bytes the value of the option take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.#ctor(System.Byte,System.Byte,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4TimeOfDay})">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timestamps">The timestamps as time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.#ctor(System.Byte,System.Byte,PcapDotNet.Packets.IpV4.IpV4TimeOfDay[])">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timestamps">The timestamps as time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.GetHashCode">
            <summary>
            The hash code of this options is the hash code of the base class xored with the hash code of the timestamps.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.EqualValues(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            Compares the values of the options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.WriteValues(System.Byte[],System.Int32@)">
            <summary>
            Writes the value of the option to the buffer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.CountTimestamps">
            <summary>
            The number of timestamps this option holds (or can hold).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.Timestamps">
            <summary>
            The timestamps as time passed since midnight UT.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.ValuesLength">
            <summary>
            The number of bytes the value of the option take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress">
            <summary>
             Represents a timestamp IPv4 option with each timestamp preceded with internet address of the registering entity or the internet address fields are prespecified.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionTimestampType,System.Byte,System.Byte,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress})">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="timestampType">The timestamp option type.</param>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timedRoute">The pairs of addresses and timestamps where each timestamp time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionTimestampType,System.Byte,System.Byte,PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress[])">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="timestampType">The timestamp option type.</param>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timedRoute">The pairs of addresses and timestamps where each timestamp time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.GetHashCode">
            <summary>
            The hash of this option is the base class hash xored with the hash of each timestamp.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.EqualValues(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            True iff the options values is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.WriteValues(System.Byte[],System.Int32@)">
            <summary>
            Writes the value of the option to the buffer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.CountTimestamps">
            <summary>
            The number of timestamps this option holds (or can hold).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.TimedRoute">
            <summary>
            The pairs of addresses and timestamps where each timestamp time passed since midnight UT.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.ValuesLength">
            <summary>
            The number of bytes the value of the option take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.IEthernetNextLayer">
            <summary>
            A layer under an Ethernet layer.
            Must provide the Ethernet Type and the default destination MAC address (if any).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.IEthernetNextLayer.PreviousLayerEtherType">
            <summary>
            The Ethernet Type the Ethernet layer should write when this layer is the Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.IEthernetNextLayer.PreviousLayerDefaultDestination">
            <summary>
            The default MAC Address value when this layer is the Ethernet payload.
            null means there is no default value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpUnknownLayer">
            <summary>
            Represents an ICMP layer with an unknown message type.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.LayerMessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.LayerCode">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.LayerVariable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.Payload">
            <summary>
            The payload of the ICMP.
            All the data without the ICMP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer">
            <summary>
            RFC 1256.
            An ICMP Router Advertisement layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the Entries are equal to the other ICMP entries.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer)">
            <summary>
            True iff the Entries are equal to the other ICMP entries.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.Lifetime">
            <summary>
            The maximum time that the router addresses may be considered valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.Entries">
            <summary>
            The pairs of sending router's IP address(es) on the interface from which this message is sent
            and the preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet.
            A signed, twos-complement value; higher values mean more preferable.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.IArpPreviousLayer">
            <summary>
            A layer that contains an ARP layer.
            Must provide the ARP hardware type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.IArpPreviousLayer.PreviousLayerHardwareType">
            <summary>
            The ARP Hardware Type of the layer before the ARP layer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataSignature">
            <summary>
            RFCs 2535, 4034.
            <pre>
            +-----+--------------+-----------+--------+
            | bit | 0-15         | 16-23     | 24-31  |
            +-----+--------------+-----------+--------+
            | 0   | type covered | algorithm | labels |
            +-----+--------------+-----------+--------+
            | 32  | original TTL                      |
            +-----+-----------------------------------+
            | 64  | signature expiration              |
            +-----+-----------------------------------+
            | 96  | signature inception               |
            +-----+--------------+--------------------+
            | 128 | key tag      |                    |
            +-----+--------------+ signer's name      |
            | ... |                                   |
            +-----+-----------------------------------+
            |     | signature                         |
            | ... |                                   |
            +-----+-----------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSignature.#ctor(PcapDotNet.Packets.Dns.DnsType,PcapDotNet.Packets.Dns.DnsAlgorithm,System.Byte,System.UInt32,PcapDotNet.Base.SerialNumber32,PcapDotNet.Base.SerialNumber32,System.UInt16,PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the type covered, algorithm, labels, original TTL, signature expiration, signature inception, key tag, 
            signer's name and signature fields.
            </summary>
            <param name="typeCovered">The type of the other RRs covered by this SIG.</param>
            <param name="algorithm">The key algorithm.</param>
            <param name="labels">
            An unsigned count of how many labels there are in the original SIG RR owner name not counting the null label for root and not counting any initial "*" for a wildcard.  
            If a secured retrieval is the result of wild card substitution, it is necessary for the resolver to use the original form of the name in verifying the digital signature.
            This field makes it easy to determine the original form.
            
            If, on retrieval, the RR appears to have a longer name than indicated by "labels", the resolver can tell it is the result of wildcard substitution.
            If the RR owner name appears to be shorter than the labels count, the SIG RR must be considered corrupt and ignored.
            The maximum number of labels allowed in the current DNS is 127 but the entire octet is reserved and would be required should DNS names ever be expanded to 255 labels.
            </param>
            <param name="originalTtl">
            The "original TTL" field is included in the RDATA portion to avoid
            (1) authentication problems that caching servers would otherwise cause by decrementing the real TTL field and
            (2) security problems that unscrupulous servers could otherwise cause by manipulating the real TTL field.
            This original TTL is protected by the signature while the current TTL field is not.
            
            NOTE:  The "original TTL" must be restored into the covered RRs when the signature is verified.
            This generaly implies that all RRs for a particular type, name, and class, that is, all the RRs in any particular RRset, must have the same TTL to start with.
            </param>
            <param name="signatureExpiration">
            The last time the signature is valid.
            Numbers of seconds since the start of 1 January 1970, GMT, ignoring leap seconds.
            Ring arithmetic is used.
            This time can never be more than about 68 years after the inception.
            </param>
            <param name="signatureInception">
            The first time the signature is valid.
            Numbers of seconds since the start of 1 January 1970, GMT, ignoring leap seconds.
            Ring arithmetic is used.
            This time can never be more than about 68 years before the expiration.
            </param>
            <param name="keyTag">
            Used to efficiently select between multiple keys which may be applicable and thus check that a public key about to be used 
            for the computationally expensive effort to check the signature is possibly valid.  
            For algorithm 1 (MD5/RSA) as defined in RFC 2537, 
            it is the next to the bottom two octets of the public key modulus needed to decode the signature field.
            That is to say, the most significant 16 of the least significant 24 bits of the modulus in network (big endian) order. 
            For all other algorithms, including private algorithms, it is calculated as a simple checksum of the KEY RR.
            </param>
            <param name="signersName">
            The domain name of the signer generating the SIG RR.
            This is the owner name of the public KEY RR that can be used to verify the signature.  
            It is frequently the zone which contained the RRset being authenticated.
            Which signers should be authorized to sign what is a significant resolver policy question.
            The signer's name may be compressed with standard DNS name compression when being transmitted over the network.
            </param>
            <param name="signature">
            The actual signature portion of the SIG RR binds the other RDATA fields to the RRset of the "type covered" RRs with that owner name and class.
            This covered RRset is thereby authenticated. 
            To accomplish this, a data sequence is constructed as follows: 
            
            data = RDATA | RR(s)...
            
            where "|" is concatenation,
            
            RDATA is the wire format of all the RDATA fields in the SIG RR itself (including the canonical form of the signer's name) before but not including the signature,
            and RR(s) is the RRset of the RR(s) of the type covered with the same owner name and class as the SIG RR in canonical form and order.
            
            How this data sequence is processed into the signature is algorithm dependent.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSignature.Equals(PcapDotNet.Packets.Dns.DnsResourceDataSignature)">
            <summary>
            Two DnsResourceDataSignature are equal iff their type covered, algorithm, labels, original TTL, signature expiration, signature inception, key tag,
            signer's name and signature fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSignature.Equals(System.Object)">
            <summary>
            Two DnsResourceDataSignature are equal iff their type covered, algorithm, labels, original TTL, signature expiration, signature inception, key tag,
            signer's name and signature fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSignature.GetHashCode">
            <summary>
            A hash code of the combination of the type covered, algorithm, labels, original TTL, signature expiration, signature inception, key tag,
            signer's name and signature fields
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.TypeCovered">
            <summary>
            The type of the other RRs covered by this SIG.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.Algorithm">
            <summary>
            The key algorithm.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.Labels">
            <summary>
            An unsigned count of how many labels there are in the original SIG RR owner name not counting the null label for root and not counting any initial "*" for a wildcard.  
            If a secured retrieval is the result of wild card substitution, it is necessary for the resolver to use the original form of the name in verifying the digital signature.
            This field makes it easy to determine the original form.
            
            If, on retrieval, the RR appears to have a longer name than indicated by "labels", the resolver can tell it is the result of wildcard substitution.
            If the RR owner name appears to be shorter than the labels count, the SIG RR must be considered corrupt and ignored.
            The maximum number of labels allowed in the current DNS is 127 but the entire octet is reserved and would be required should DNS names ever be expanded to 255 labels.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.OriginalTtl">
            <summary>
            The "original TTL" field is included in the RDATA portion to avoid
            (1) authentication problems that caching servers would otherwise cause by decrementing the real TTL field and
            (2) security problems that unscrupulous servers could otherwise cause by manipulating the real TTL field.
            This original TTL is protected by the signature while the current TTL field is not.
            
            NOTE:  The "original TTL" must be restored into the covered RRs when the signature is verified.
            This generaly implies that all RRs for a particular type, name, and class, that is, all the RRs in any particular RRset, must have the same TTL to start with.
             </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.SignatureExpiration">
            <summary>
            The last time the signature is valid.
            Numbers of seconds since the start of 1 January 1970, GMT, ignoring leap seconds.
            Ring arithmetic is used.
            This time can never be more than about 68 years after the inception.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.SignatureInception">
            <summary>
            The first time the signature is valid.
            Numbers of seconds since the start of 1 January 1970, GMT, ignoring leap seconds.
            Ring arithmetic is used.
            This time can never be more than about 68 years before the expiration.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.KeyTag">
            <summary>
            Used to efficiently select between multiple keys which may be applicable and thus check that a public key about to be used 
            for the computationally expensive effort to check the signature is possibly valid.  
            For algorithm 1 (MD5/RSA) as defined in RFC 2537, 
            it is the next to the bottom two octets of the public key modulus needed to decode the signature field.
            That is to say, the most significant 16 of the least significant 24 bits of the modulus in network (big endian) order. 
            For all other algorithms, including private algorithms, it is calculated as a simple checksum of the KEY RR.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.SignersName">
            <summary>
            The domain name of the signer generating the SIG RR.
            This is the owner name of the public KEY RR that can be used to verify the signature.  
            It is frequently the zone which contained the RRset being authenticated.
            Which signers should be authorized to sign what is a significant resolver policy question.
            The signer's name may be compressed with standard DNS name compression when being transmitted over the network.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSignature.Signature">
            <summary>
            The actual signature portion of the SIG RR binds the other RDATA fields to the RRset of the "type covered" RRs with that owner name and class.
            This covered RRset is thereby authenticated. 
            To accomplish this, a data sequence is constructed as follows: 
            
            data = RDATA | RR(s)...
            
            where "|" is concatenation,
            
            RDATA is the wire format of all the RDATA fields in the SIG RR itself (including the canonical form of the signer's name) before but not including the signature,
            and RR(s) is the RRset of the RR(s) of the type covered with the same owner name and class as the SIG RR in canonical form and order.
            
            How this data sequence is processed into the signature is algorithm dependent.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey">
            <summary>
            RFCs 3757, 4034, 5011.
            <pre>
            +-----+----------+----------+--------+----------+--------------------+
            | bit | 0-6      | 7        | 8      | 9-14     | 15                 |
            +-----+----------+----------+--------+----------+--------------------+
            | 0   | Reserved | Zone Key | Revoke | Reserved | Secure Entry Point |
            +-----+----------+----------+--------+----------+--------------------+
            | 16  | Protocol            | Algorithm                              |
            +-----+---------------------+----------------------------------------+
            | 32  | Public Key                                                   |
            | ... |                                                              |
            +-----+--------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataSimple">
            <summary>
            A DNS resource record type that any domain name that it contains should not be compressed when written and cannot decompress them when reads them.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNoCompression">
            <summary>
            A DNS resource record type that any domain name that it contains should not be compressed when written.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.ProtocolValue">
            <summary>
            The expected value for the protocol field.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Byte,PcapDotNet.Packets.Dns.DnsAlgorithm,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance from the zone key, revoke, secure entry point, protocol, algorithm and public key fields.
            </summary>
            <param name="zoneKey">
            If true, the DNSKEY record holds a DNS zone key, and the DNSKEY RR's owner name must be the name of a zone.
            If false, then the DNSKEY record holds some other type of DNS public key and must not be used to verify RRSIGs that cover RRsets.
            </param>
            <param name="revoke">
            If true, and the resolver sees an RRSIG(DNSKEY) signed by the associated key,
            then the resolver must consider this key permanently invalid for all purposes except for validating the revocation.
            </param>
            <param name="secureEntryPoint">
            RFC 3757.
            If true, then the DNSKEY record holds a key intended for use as a secure entry point.
            This flag is only intended to be a hint to zone signing or debugging software as to the intended use of this DNSKEY record;
            validators must not alter their behavior during the signature validation process in any way based on the setting of this bit.
            This also means that a DNSKEY RR with the SEP bit set would also need the Zone Key flag set in order to be able to generate signatures legally.
            A DNSKEY RR with the SEP set and the Zone Key flag not set MUST NOT be used to verify RRSIGs that cover RRsets.
            </param>
            <param name="protocol">
            Must have value 3, and the DNSKEY RR MUST be treated as invalid during signature verification if it is found to be some value other than 3.
            </param>
            <param name="algorithm">Identifies the public key's cryptographic algorithm and determines the format of the Public Key field.</param>
            <param name="publicKey">The public key material. The format depends on the algorithm of the key being stored.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.Equals(PcapDotNet.Packets.Dns.DnsResourceDataDnsKey)">
            <summary>
            Two DnsResourceDataDnsKey are equal iff their zone key, revoke, secure entry point, protocol, algorithm and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.Equals(System.Object)">
            <summary>
            Two DnsResourceDataDnsKey are equal iff their zone key, revoke, secure entry point, protocol, algorithm and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.GetHashCode">
            <summary>
            The hash code based on the zone key, revoke, secure entry point, protocol, algorithm and public key fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.ZoneKey">
            <summary>
            If true, the DNSKEY record holds a DNS zone key, and the DNSKEY RR's owner name must be the name of a zone.
            If false, then the DNSKEY record holds some other type of DNS public key and must not be used to verify RRSIGs that cover RRsets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.Revoke">
            <summary>
            If true, and the resolver sees an RRSIG(DNSKEY) signed by the associated key,
            then the resolver must consider this key permanently invalid for all purposes except for validating the revocation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.SecureEntryPoint">
            <summary>
            RFC 3757.
            If true, then the DNSKEY record holds a key intended for use as a secure entry point.
            This flag is only intended to be a hint to zone signing or debugging software as to the intended use of this DNSKEY record;
            validators must not alter their behavior during the signature validation process in any way based on the setting of this bit.
            This also means that a DNSKEY RR with the SEP bit set would also need the Zone Key flag set in order to be able to generate signatures legally.
            A DNSKEY RR with the SEP set and the Zone Key flag not set MUST NOT be used to verify RRSIGs that cover RRsets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.Protocol">
            <summary>
            Must have value 3, and the DNSKEY RR MUST be treated as invalid during signature verification if it is found to be some value other than 3.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.Algorithm">
            <summary>
            Identifies the public key's cryptographic algorithm and determines the format of the Public Key field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDnsKey.PublicKey">
            <summary>
            The public key material.
            The format depends on the algorithm of the key being stored.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptionUpdateLease">
            <summary>
            http://files.dns-sd.org/draft-sekar-dns-ul.txt.
            <pre>
            +-----+-------+
            | bit | 0-31  |
            +-----+-------+
            | 0   | LEASE |
            +-----+-------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOption">
            <summary>
            RFC 2671.
            A single option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOption.MinimumLength">
            <summary>
            The minimum number of bytes an option can take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOption.Equals(PcapDotNet.Packets.Dns.DnsOption)">
            <summary>
            Two options are equal if they are of the same type, have the same code and have equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOption.Equals(System.Object)">
            <summary>
            Two options are equal if they are of the same type, have the same code and have equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOption.GetHashCode">
            <summary>
            Returns a hash code based on the option code and data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOption.Code">
            <summary>
            The option code.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOption.Length">
            <summary>
            The number of bytes the option takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOption.DataLength">
            <summary>
            The number of bytes the option data takes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOptionUpdateLease.ConstDataLength">
            <summary>
            The number of bytes this option data can take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptionUpdateLease.#ctor(System.Int32)">
            <summary>
            Builds 
            </summary>
            <param name="lease"></param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionUpdateLease.Lease">
            <summary>
            Indicating the lease life, in seconds, desired by the client.
            In Update Responses, this field contains the actual lease granted by the server.
            Note that the lease granted by the server may be less than, greater than, or equal to the value requested by the client.
            To reduce network and server load, a minimum lease of 30 minutes (1800 seconds) is recommended.
            Note that leases are expected to be sufficiently long as to make timer discrepancies (due to transmission latency, etc.)
            between a client and server negligible.
            Clients that expect the updated records to be relatively static may request appropriately longer leases.
            Servers may grant relatively longer or shorter leases to reduce network traffic due to refreshes, or reduce stale data, respectively.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionUpdateLease.DataLength">
            <summary>
            The number of bytes the option data takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsKeySignatoryAttributes">
            <summary>
            RFC 2137.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeySignatoryAttributes.General">
            <summary>
            The general update signatory field bit has no special meaning.
            If the other three bits are all zero, it must be one so that the field is non-zero to designate that the key is an update key.
            The meaning of all values of the signatory field with the general bit and one or more other signatory field bits on is reserved.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeySignatoryAttributes.Unique">
            <summary>
            If non-zero, this key is authorized to add and update RRs for only a single owner name.
            If there already exist RRs with one or more names signed by this key, they may be updated but no new name created until the number of existing names is reduced to zero.
            This bit is meaningful only for mode A dynamic zones and is ignored in mode B dynamic zones. 
            This bit is meaningful only if the owner name is a wildcard.
            (Any dynamic update KEY with a non-wildcard name is, in effect, a unique name update key.)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeySignatoryAttributes.Strong">
            <summary>
            If non-zero, this key is authorized to add and delete RRs even if there are other RRs with the same owner name and class that are authenticated by a SIG signed with a different dynamic update KEY.
            If zero, the key can only authorize updates where any existing RRs of the same owner and class are authenticated by a SIG using the same key.
            This bit is meaningful only for type A dynamic zones and is ignored in type B dynamic zones.
            
            Keeping this bit zero on multiple KEY RRs with the same or nested wild card owner names permits multiple entities to exist that can create and delete names but can not effect RRs with different owner names from any they created.
            In effect, this creates two levels of dynamic update key, strong and weak, where weak keys are limited in interfering with each other but a strong key can interfere with any weak keys or other strong keys.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeySignatoryAttributes.Zone">
            <summary>
            If nonzero, this key is authorized to attach, detach, and move zones by creating and deleting NS, glue A, and zone KEY RR(s).
            If zero, the key can not authorize any update that would effect such RRs.
            This bit is meaningful for both type A and type B dynamic secure zones.
            NOTE:  do not confuse the "zone" signatory field bit with the "zone" key type bit.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.UdpDatagram">
            <summary>
            RFC 768.
            This User Datagram Protocol (UDP) is defined to make available a datagram mode of packet-switched computer communication  
            in  the environment of an interconnected set of computer networks.   
            This protocol assumes that the Internet Protocol (IP) is used as the underlying protocol.
            
            <para>
            This protocol provides a procedure for application programs to send messages  to other programs 
            with a minimum of protocol mechanism. 
            The protocol is transaction oriented, and delivery and duplicate protection are not guaranteed.  
            Applications requiring ordered reliable delivery of streams of data should use the Transmission Control Protocol (TCP).
            </para>
            
            <para>
            Format
            <pre>
             0      7 8     15 16    23 24    31
            +--------+--------+--------+--------+
            |     Source      |   Destination   |
            |      Port       |      Port       |
            +--------+--------+--------+--------+
            |                 |                 |
            |     Length      |    Checksum     |
            +--------+--------+--------+--------+
            |
            |          data octets ...
            +---------------- ...
            </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.UdpDatagram.HeaderLength">
            <summary>
            The number of bytes the datagram header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.UdpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.UdpDatagram.CalculateIsValid">
            <summary>
            A udp datagram is valid if it has a full header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.TotalLength">
            <summary>
            The length in octets of this user datagram including this header and the data.   
            (This  means  the minimum value of the length is eight.)
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the UDP header, and the data, padded  with zero octets at the end (if  necessary) to  make  a multiple of two octets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.IsChecksumOptional">
            <summary>
            True iff the checksum for the transport type is optional.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.Payload">
            <summary>
            The payload of the UDP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.Dns">
            <summary>
            The payload of the datagram as a DNS datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSimple">
            <summary>
            A simple TCP option - holds only the type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSimple.OptionLength">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSimple.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSimple.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Options">
            <summary>
            Represents IPv4 Options.
            The options may appear or not in datagrams.  
            They must be implemented by all IP modules (host and gateways).  
            What is optional is their transmission in any particular datagram, not their implementation.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Options`1">
            <summary>
            A generic Options class.
            Represents a list of options (either IPv4 options or TCP options).
            </summary>
            <typeparam name="T">The Option type this collection contains.</typeparam>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.Equals(PcapDotNet.Packets.Options{`0})">
            <summary>
            Two options are equal iff they have the exact same options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.Equals(System.Object)">
            <summary>
            Two options are equal iff they have the exact same options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.GetHashCode">
            <summary>
            The hash code is the xor of the following hash codes: number of bytes the options take and all the options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.ToString">
            <summary>
            A string of all the option type names.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.OptionsCollection">
            <summary>
            Returns the collection of options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.Count">
            <summary>
            Returns the number of options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.Item(System.Int32)">
            <summary>
            Returns the option in the given index.
            </summary>
            <param name="index">The zero based index of the option.</param>
            <returns>The option in the given index.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.BytesLength">
            <summary>
            The number of bytes the options take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.IsValid">
            <summary>
            Whether or not the options parsed ok.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Options.MaximumBytesLength">
            <summary>
            The maximum number of bytes the options may take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Options.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Option})">
            <summary>
            Creates options from a list of options.
            </summary>
            <param name="options">The list of options.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Options.#ctor(PcapDotNet.Packets.IpV4.IpV4Option[])">
            <summary>
            Creates options from a list of options.
            </summary>
            <param name="options">The list of options.</param>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Options.None">
            <summary>
            No options instance.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion">
            <summary>
            The version of the IGMP query message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.None">
            <summary>
            No query version - not a query.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Version1">
            <summary>
            Version 1 query - RFC1112.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Version2">
            <summary>
            Version 2 query - RFC2236.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Version3">
            <summary>
            Version 3 query - RFC3376.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Unknown">
            <summary>
            The version of the query could not be interpreted.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram">
            <summary>
            RFC 1256.
            <pre>
            +-----+-----------+-----------------+----------+
            | Bit | 0-7       | 8-15            | 16-31    |
            +-----+-----------+-----------------+----------+
            | 0   | Type      | Code            | Checksum |
            +-----+-----------+-----------------+----------+
            | 32  | Num Addrs | Addr Entry Size | Lifetime |
            +-----+-----------+-----------------+----------+
            | 64  | Router Address[1]                      |
            +-----+----------------------------------------+
            | 96  | Preference Level[1]                    |
            +-----+----------------------------------------+
            | 128 | Router Address[2]                      |
            +-----+----------------------------------------+
            | 160 | Preference Level[2]                    |
            +-----+----------------------------------------+
            |  .  |                   .                    |
            |  .  |                   .                    |
            |  .  |                   .                    |
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.DefaultAddressEntrySize">
            <summary>
            The default number of 32-bit words of information per each router address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range
            and the address entry size is the default address entry size.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.NumberOfAddresses">
            <summary>
            The number of router addresses advertised in this message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.AddressEntrySize">
            <summary>
            The number of 32-bit words of information per each router address (2, in the version of the protocol described here).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.LifetimeSeconds">
            <summary>
            The maximum number of seconds that the router addresses may be considered valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.Lifetime">
            <summary>
            The maximum time that the router addresses may be considered valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.Entries">
            <summary>
            The pairs of sending router's IP address(es) on the interface from which this message is sent
            and the preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet.
            A signed, twos-complement value; higher values mean more preferable.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestLayer">
            <summary>
            RFC 1788.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer">
            <summary>
            Represents an ICMP layer with an Identifier and a Sequence Number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer.Identifier">
            <summary>
            An identifier to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer.SequenceNumber">
            <summary>
            A sequence number to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyLayer">
            <summary>
            RFC 950.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer">
            <summary>
            RFC 950.
            Represents an ICMP Trace Route message layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the address mask is equal to the other address mask.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer)">
            <summary>
            True iff the address mask is equal to the other address mask.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.AddressMask">
            <summary>
            A 32-bit mask.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceData2DomainNames">
            <summary>
            A resource record data that contains exactly 2 domain names.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataDomainNames">
            <summary>
            A base class for resource record datas that contain DNS domain names.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDomainNames.Equals(PcapDotNet.Packets.Dns.DnsResourceDataDomainNames)">
            <summary>
            Two domain names resource data are equal if they are of the same type and contain the same domain names in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDomainNames.Equals(System.Object)">
            <summary>
            Two domain names resource data are equal if they are of the same type and contain the same domain names in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDomainNames.GetHashCode">
            <summary>
            The hash code of the resource data is based on the concrete type and domain names.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsKeyProtocol">
            <summary>
            RFC 2535.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyProtocol.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyProtocol.Tls">
            <summary>
            Connection with TLS.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyProtocol.Email">
            <summary>
            Connection with email.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyProtocol.DnsSec">
            <summary>
            DNS security.
            The protocol field should be set to this value for zone keys and other keys used in DNS security.
            Implementations that can determine that a key is a DNS security key by the fact that flags label it a zone key or the signatory flag field is non-zero are not required to check the protocol field.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyProtocol.IpSec">
            <summary>
            Oakley/IPSEC [RFC 2401] protocol.
            Indicates that this key is valid for use in conjunction with that security standard.
            This key could be used in connection with secured communication on behalf of an end entity or user whose name is the owner name of the KEY RR if the entity or user flag bits are set.
            The presence of a KEY resource with this protocol value is an assertion that the host speaks Oakley/IPSEC.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyProtocol.All">
            <summary>
            The key can be used in connection with any protocol for which KEY RR protocol octet values have been defined.
            The use of this value is discouraged and the use of different keys for different protocols is encouraged.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsCertificationAuthorityAuthorizationFlags">
            <summary>
            Hallam-Baker.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificationAuthorityAuthorizationFlags.Critical">
            <summary>
            If set, the critical flag is asserted and the property must be understood if the CAA record is to be correctly processed by a certificate issuer.
            A Certification Authority must not issue certificates for any Domain that contains a CAA critical property for an unknown or unsupported property type that has the issuer flag set.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsQueryResourceRecord">
            <summary>
            RFC 1035.
            <pre>
            +------+-------------------------------------------------+
            | byte | 0-1                                             |
            +------+-------------------------------------------------+
            | 0    | Name                                            |
            | ...  |                                                 |
            +------+-------------------------------------------------+
            |      | Type                                            |
            +------+-------------------------------------------------+
            |      | Class                                           |
            +------+-------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsQueryResourceRecord.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.Dns.DnsType,PcapDotNet.Packets.Dns.DnsClass)">
            <summary>
            Creates a DNS query record from a domain name, type and class.
            </summary>
            <param name="domainName">An owner name, i.e., the name of the node to which this resource record pertains.</param>
            <param name="type">Two octets containing one of the RR TYPE codes.</param>
            <param name="dnsClass">Two octets containing one of the RR CLASS codes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsQueryResourceRecord.Equals(PcapDotNet.Packets.Dns.DnsQueryResourceRecord)">
            <summary>
            Two query records are equal if they have the same domain name, type and class.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsQueryResourceRecord.Equals(System.Object)">
            <summary>
            Two query records are equal if they have the same domain name, type and class.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsQueryResourceRecord.GetHashCode">
            <summary>
            A hash code based on the query record's domain name, type and class.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsQueryResourceRecord.Ttl">
            <summary>
            There's no TTL in a query record.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsQueryResourceRecord.Data">
            <summary>
            There's no data in a query record.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsDomainNameCompressionMode">
            <summary>
            Defines when and how to compress DNS domain names when creating a DNS datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDomainNameCompressionMode.All">
            <summary>
            Compress any domain name if possible.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDomainNameCompressionMode.Nothing">
            <summary>
            Never compress domain names.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionEchoReply">
            <summary>
            TCP Echo Reply Option:
            <pre>
            +--------+--------+--------+--------+--------+--------+
            | Kind=7 | Length |    4 bytes of echoed info         |
            +--------+--------+--------+--------+--------+--------+
            </pre>
            
            <para>
            A TCP that receives a TCP Echo option containing four information bytes will return these same bytes in a TCP Echo Reply option.
            </para>
            
            <para>
            This TCP Echo Reply option must be returned in the next segment (e.g., an ACK segment) that is sent.
            If more than one Echo option is received before a reply segment is sent, the TCP must choose only one of the options to echo, 
            ignoring the others; specifically, it must choose the newest segment with the oldest sequence number.
            </para>
            
            <para>
            To use the TCP Echo and Echo Reply options, a TCP must send a TCP Echo option in its own SYN segment 
            and receive a TCP Echo option in a SYN segment from the other TCP.  
            A TCP that does not implement the TCP Echo or Echo Reply options must simply ignore any TCP Echo options it receives.  
            However, a TCP should not receive one of these options in a non-SYN segment unless it included a TCP Echo option in its own SYN segment.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEchoReply.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEchoReply.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given echo info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.#ctor">
            <summary>
            The default echo info is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Equals(PcapDotNet.Packets.Transport.TcpOptionEchoReply)">
            <summary>
            Two echo reply options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two echo reply options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.GetHashCode">
            <summary>
            The hash code of the echo reply option is the hash code of the option type xored with the hash code of the info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Info">
            <summary>
            The echoed info.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEchoReply.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion">
            <summary>
            An emotion that can be set in a TCP mood option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Happy">
            <summary>
            :)  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Sad">
            <summary>
            :(  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Amused">
            <summary>
            :D  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Confused">
            <summary>
            %(  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Bored">
            <summary>
            :o  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Surprised">
            <summary>
            :O  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Silly">
            <summary>
            :P  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Frustrated">
            <summary>
            :@  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Angry">
            <summary>
            >:@ 
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Apathetic">
            <summary>
            :|  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Sneaky">
            <summary>
            ;)  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Evil">
            <summary>
            >:) 
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.None">
            <summary>
            An unknown emotion.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpRecordType">
            <summary>
            Group Record Type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.None">
            <summary>
            Illegal record type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.CurrentStateRecordModeIsInclude">
            <summary>
            A "Current-State Record" is sent by a system in response to a Query received on an interface. 
            It reports the current reception state of that interface, with respect to a single multicast address.
            <para>
            MODE_IS_INCLUDE - indicates that the interface has a filter mode of INCLUDE for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.CurrentStateRecordModeIsExclude">
            <summary>
            A "Current-State Record" is sent by a system in response to a Query received on an interface. 
            It reports the current reception state of that interface, with respect to a single multicast address.
            <para>
            MODE_IS_EXCLUDE - indicates that the interface has a filter mode of EXCLUDE for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.FilterModeChangeToInclude">
            <summary>
            A "Filter-Mode-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of the filter mode
            (i.e., a change from INCLUDE to EXCLUDE, or from EXCLUDE to INCLUDE), 
            of the interface-level state entry for a particular multicast address.  
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            CHANGE_TO_INCLUDE_MODE - indicates that the interface has changed to INCLUDE filter mode for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's new source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.FilterModeChangeToExclude">
            <summary>
            A "Filter-Mode-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of the filter mode
            (i.e., a change from INCLUDE to EXCLUDE, or from EXCLUDE to INCLUDE), 
            of the interface-level state entry for a particular multicast address.  
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            CHANGE_TO_EXCLUDE_MODE - indicates that the interface has changed to EXCLUDE filter mode for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's new source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.SourceListChangeAllowNewSources">
            <summary>
            A "Source-List-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of source list 
            that is *not* coincident with a change of filter mode, of the interface-level state entry for a particular multicast address.
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            ALLOW_NEW_SOURCES - indicates that the Source Address [i] fields in this Group Record contain a list of the additional sources 
            that the system wishes to hear from, for packets sent to the specified multicast address.  
            If the change was to an INCLUDE source list, these are the addresses that were added to the list; if the change was to an EXCLUDE source list, 
            these are the addresses that were deleted from the list.
            </para>
            <para>
            If a change of source list results in both allowing new sources and blocking old sources, 
            then two Group Records are sent for the same multicast address, one of type ALLOW_NEW_SOURCES and one of type BLOCK_OLD_SOURCES.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.SourceListChangeBlockOldSources">
            <summary>
            A "Source-List-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of source list 
            that is *not* coincident with a change of filter mode, of the interface-level state entry for a particular multicast address.
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            BLOCK_OLD_SOURCES - indicates that the Source Address [i] fields in this Group Record contain a list of the sources 
            that the system no longer wishes to hear from, for packets sent to the specified multicast address.  
            If the change was to an INCLUDE source list, these are the addresses that were deleted from  the list; if the change was to an EXCLUDE source list, 
            these are the addresses that were added to the list.
            </para>
            <para>
            If a change of source list results in both allowing new sources and blocking old sources, 
            then two Group Records are sent for the same multicast address, one of type ALLOW_NEW_SOURCES and one of type BLOCK_OLD_SOURCES.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpMessageType">
            <summary>
            The different ICMP message types.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.EchoReply">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.DestinationUnreachable">
            <summary>
            RFC 792
            
            <para>
            If, according to the information in the gateway's routing tables, 
            the network specified in the internet destination field of a datagram is unreachable, e.g., the distance to the network is infinity, 
            the gateway may send a destination unreachable message to the internet source host of the datagram.  
            In addition, in some networks, the gateway may be able to determine if the internet destination host is unreachable.  
            Gateways in these networks may send destination unreachable messages to the source host when the destination host is unreachable.
            </para>
            
            <para>
            If, in the destination host, the IP module cannot deliver the datagram  because the indicated protocol module or process port is not active, 
            the destination host may send a destination unreachable message to the source host.
            </para>
            
            <para>
            Another case is when a datagram must be fragmented to be forwarded by a gateway yet the Don't Fragment flag is on. 
            In this case the gateway must discard the datagram and may return a destination unreachable message.
            </para>
            
            <para>
            Codes 0, 1, 4, and 5 may be received from a gateway.  
            Codes 2 and 3 may be received from a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.SourceQuench">
            <summary>
            RFC 792.
            
            <para>
            A gateway may discard internet datagrams if it does not have the buffer space needed to queue the datagrams for output to the next network on the route to the destination network.  
            If a gateway discards a datagram, it may send a source quench message to the internet source host of the datagram.  
            A destination host may also send a source quench message if datagrams arrive too fast to be processed.  
            The source quench message is a request to the host to cut back the rate at which it is sending traffic to the internet destination.  
            The gateway may send a source quench message for every message that it discards.  
            On receipt of a source quench message, the source host should cut back the rate at which it is sending traffic to the specified destination 
            until it no longer receives source quench messages from the gateway.  
            The source host can then gradually increase the rate at which it sends traffic to the destination until it again receives source quench messages.
            </para>
            
            <para>
            The gateway or host may send the source quench message when it approaches its capacity limit rather than waiting until the capacity is exceeded.  
            This means that the data datagram which triggered the source quench message may be delivered.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.Redirect">
            <summary>
            RFC 792.
            
            <para>
            The gateway sends a redirect message to a host in the following situation.  
            A gateway, G1, receives an internet datagram from a host on a network to which the gateway is attached.  
            The gateway, G1, checks its routing table and obtains the address of the next gateway, G2, on the route to the datagram's internet destination network, X.  
            If G2 and the host identified by the internet source address of the datagram are on the same network, a redirect message is sent to the host.  
            The redirect message advises the host to send its traffic for network X directly to gateway G2 as this is a shorter path to the destination.  
            The gateway forwards the original datagram's data to its internet destination.
            </para>
            
            <para>
            For datagrams with the IP source route options and the gateway address in the destination address field, 
            a redirect message is not sent even if there is a better route to the ultimate destination than the next address in the source route.
            </para>
            
            <para>
            Codes 0, 1, 2, and 3 may be received from a gateway.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.Echo">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.RouterAdvertisement">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.RouterSolicitation">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.TimeExceeded">
            <summary>
            RFC 792.
            
            <para>
            If the gateway processing a datagram finds the time to live field is zero it must discard the datagram.  
            The gateway may also notify the source host via the time exceeded message.
            </para>
            
            <para>
            If a host reassembling a fragmented datagram cannot complete the reassembly due to missing fragments within its time limit it discards the datagram, 
            and it may send a time exceeded message.
            If fragment zero is not available then no time exceeded need be sent at all.
            </para>
            
            <para>
            Code 0 may be received from a gateway.  
            Code 1 may be received from a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.ParameterProblem">
            <summary>
            RFC 792.
            
            <para>
            If the gateway or host processing a datagram finds a problem with the header parameters such that it cannot complete processing the datagram it must discard the datagram.  
            One potential source of such a problem is with incorrect arguments in an option.  
            The gateway or host may also notify the source host via the parameter problem message. 
            This message is only sent if the error caused the datagram to be discarded.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.Timestamp">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.TimestampReply">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.InformationRequest">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.InformationReply">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.AddressMaskRequest">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.AddressMaskReply">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.TraceRoute">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.ConversionFailed">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.DomainNameRequest">
            <summary>
            RFC 1788.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.DomainNameReply">
            <summary>
            RFC 1788.
            Parsing of this datagram isn't supported because its parsing is not clear from the RFC.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.SecurityFailures">
            <summary>
            RFC 2521.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Originate Timestamp           |
            +-----+-------------------------------+
            | 96  | Receive Timestamp             |
            +-----+-------------------------------+
            | 128 | Transmit Timestamp            |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.DatagramLength">
            <summary>
            The number of bytes this datagram should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.PayloadLength">
            <summary>
            The number of bytes this ICMP payload should take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.OriginateTimestamp">
            <summary>
            The time the sender last touched the message before sending it.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.ReceiveTimestamp">
            <summary>
            The time the echoer first touched it on receipt.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.TransmitTimestamp">
            <summary>
            The time the echoer last touched the message on sending it.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer">
            <summary>
            RFC 1393.
            Represents an ICMP Trace Route message layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the OutboundHopCount, ReturnHopCount, OutputLinkSpeed and OutputLinkMaximumTransmissionUnit fields are equal to the other layer fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer)">
            <summary>
            True iff the OutboundHopCount, ReturnHopCount, OutputLinkSpeed and OutputLinkMaximumTransmissionUnit fields are equal to the other layer fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.Identification">
            <summary>
            The ID Number as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.  
            This is NOT related to the ID number in the IP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.OutboundHopCount">
            <summary>
            The Outbound Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.ReturnHopCount">
            <summary>
            The Return Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.OutputLinkSpeed">
            <summary>
            The speed, in OCTETS per second, of the link over which the Outbound/Return Packet will be sent.  
            Since it will not be long before network speeds exceed 4.3Gb/s, and since some machines deal poorly with fields longer than 32 bits, octets per second was chosen over bits per second.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.OutputLinkMaximumTransmissionUnit">
            <summary>
            The MTU, in bytes, of the link over which the Outbound/Return Packet will be sent.  
            MTU refers to the data portion (includes IP header; excludes datalink header/trailer) of the packet.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestDatagram">
            <summary>
            RFC 2616.
            Represents an HTTP request.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpDatagram">
             <summary>
             RFC 2616
             
             Message:
             <pre>
             HTTP-message     = Request | Response
             
             generic-message  = start-line
                                *(message-header CRLF)
                                CRLF
                                [ message-body ]
             
             start-line       = Request-Line | Status-Line
             
             message-header   = field-name ":" [ field-value ]
             field-name       = token
             field-value      = *( field-content | LWS )
             field-content    = &lt;the OCTETs making up the field-value and consisting of either *TEXT or combinations of token, separators, and quoted-string>
             
             message-body     = entity-body
                              | &lt;entity-body encoded as per Transfer-Encoding>
             general-header   = Cache-Control          
                              | Connection             
                              | Date                   
                              | Pragma                 
                              | Trailer                
                              | Transfer-Encoding      
                              | Upgrade                
                              | Via                    
                              | Warning                
             </pre>
             
             Request:
             <pre>
             Request          = Request-Line             
                                *(( general-header       
                                 | request-header        
                                 | entity-header ) CRLF) 
                                CRLF
                                [ message-body ]         
             
             Request-Line     = Method SP Request-URI SP HTTP-Version CRLF
             
             Method           = "OPTIONS"              
                              | "GET"                  
                              | "HEAD"                 
                              | "POST"                 
                              | "PUT"                  
                              | "DELETE"               
                              | "TRACE"                
                              | "CONNECT"              
                              | extension-method
             
             extension-method = token
             
             Request-URI      = "*" | absoluteURI | abs_path | authority
             absoluteURI      = scheme ":" ( hier_part | opaque_part )
             scheme           = alpha *( alpha | digit | "+" | "-" | "." )
             hier_part        = ( net_path | abs_path ) [ "?" query ]
             opaque_part      = uric_no_slash *uric
             net_path         = "//" authority [ abs_path ]
             abs_path         = "/"  path_segments
             query            = *uric
             uric_no_slash    = unreserved | escaped | ";" | "?" | ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
             uric             = reserved | unreserved | escaped
             authority        = server | reg_name
             path_segments    = segment *( "/" segment )
             unreserved       = alphanum | mark
             escaped          = "%" hex hex
             reserved         = ";" | "/" | "?" | ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
             server           = [ [ userinfo "@" ] hostport ]
             reg_name         = 1*( unreserved | escaped | "$" | "," | ";" | ":" | "@" | "&amp;" | "=" | "+" )
             segment          = *pchar *( ";" param )
             mark             = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"
             userinfo         = *( unreserved | escaped | ";" | ":" | "&amp;" | "=" | "+" | "$" | "," )
             hostport         = host [ ":" port ]
             pchar            = unreserved | escaped | ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
             param            = *pchar
             host             = hostname | IPv4address
             port             = *digit
             hostname         = *( domainlabel "." ) toplabel [ "." ]
             IPv4address      = 1*digit "." 1*digit "." 1*digit "." 1*digit
             domainlabel      = alphanum | alphanum *( alphanum | "-" ) alphanum
             toplabel         = alpha | alpha *( alphanum | "-" ) alphanum
             
             request-header   = Accept                  
                              | Accept-Charset          
                              | Accept-Encoding         
                              | Accept-Language         
                              | Authorization           
                              | Expect                  
                              | From                    
                              | Host                    
                              | If-Match                
                              | If-Modified-Since       
                              | If-None-Match           
                              | If-Range                
                              | If-Unmodified-Since     
                              | Max-Forwards            
                              | Proxy-Authorization     
                              | Range                   
                              | Referer                 
                              | TE                      
                              | User-Agent              
             </pre>
             
             Response:
             <pre>
             Response         = Status-Line             
                                *(( general-header      
                                 | response-header      
                                 | entity-header ) CRLF)
                                CRLF
                                [ message-body ]        
             
             Status-Line      = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
             
             Status-Code      = "100"  
                              | "101"  
                              | "200"  
                              | "201"  
                              | "202"  
                              | "203"  
                              | "204"  
                              | "205"  
                              | "206"  
                              | "300"  
                              | "301"  
                              | "302"  
                              | "303"  
                              | "304"  
                              | "305"  
                              | "307"  
                              | "400"  
                              | "401"  
                              | "402"  
                              | "403"  
                              | "404"  
                              | "405"  
                              | "406"  
                              | "407"  
                              | "408"  
                              | "409"  
                              | "410"  
                              | "411"  
                              | "412"  
                              | "413"  
                              | "414"  
                              | "415"  
                              | "416"  
                              | "417"  
                              | "500"  
                              | "501"  
                              | "502"  
                              | "503"  
                              | "504"  
                              | "505"  
                              | extension-code
             
             extension-code   = 3DIGIT
             Reason-Phrase    = *&lt;TEXT, excluding CR, LF>
             
             response-header  = Accept-Ranges       
                              | Age                 
                              | ETag                
                              | Location            
                              | Proxy-Authenticate  
                              | Retry-After         
                              | Server              
                              | Vary                
                              | WWW-Authenticate    
            
             entity-header    = Allow               
                              | Content-Encoding    
                              | Content-Language    
                              | Content-Length      
                              | Content-Location    
                              | Content-MD5         
                              | Content-Range       
                              | Content-Type        
                              | Expires             
                              | Last-Modified       
                              | extension-header
            
             extension-header = message-header
             
             entity-body      = *OCTET
             
             entity-body     := Content-Encoding( Content-Type( data ) )
             </pre>
             </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.IsRequest">
            <summary>
            True iff the message is a request and iff the message is not a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.IsResponse">
            <summary>
            True iff the message is a response and iff the message is not a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.Version">
            <summary>
            The version of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.Header">
            <summary>
            The header of the HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.Body">
            <summary>
            Message Body.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestDatagram.IsRequest">
            <summary>
            True since the message is a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestDatagram.Method">
            <summary>
            The HTTP Request Method.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestDatagram.Uri">
            <summary>
            The HTTP Request URI.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature">
            <summary>
            RFC 2845.
            <pre>
            +------+-------------+----------+-----------+
            | bit  | 0-15        | 16-31    | 32-47     |
            +------+-------------+----------+-----------+
            | 0    | Algorithm Name                     |
            | ...  |                                    |
            +------+------------------------------------+
            | X    | Time Signed                        |
            +------+-------------+----------+-----------+
            | X+48 | Fudge       | MAC Size | MAC       |
            +------+-------------+----------+           |
            | ...  |                                    |
            +------+-------------+----------+-----------+
            | Y    | Original ID | Error    | Other Len |
            +------+-------------+----------+-----------+
            | Y+48 | Other Data                         |
            | ...  |                                    |
            +------+------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Base.UInt48,System.UInt16,PcapDotNet.Packets.DataSegment,System.UInt16,PcapDotNet.Packets.Dns.DnsResponseCode,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the algorithm time signed, fudge, message authentication code, original ID, error and other fields.
            </summary>
            <param name="algorithm">Name of the algorithm in domain name syntax.</param>
            <param name="timeSigned">Seconds since 1-Jan-70 UTC.</param>
            <param name="fudge">Seconds of error permitted in Time Signed.</param>
            <param name="messageAuthenticationCode">Defined by Algorithm Name.</param>
            <param name="originalId">Original message ID.</param>
            <param name="error">RCODE covering TSIG processing.</param>
            <param name="other">Empty unless Error == BADTIME.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.Equals(PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature)">
            <summary>
            Two DnsResourceDataTransactionSignature are equal iff their algorithm time signed, fudge, message authentication code, original ID, error
            and other fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.Equals(System.Object)">
            <summary>
            Two DnsResourceDataTransactionSignature are equal iff their algorithm time signed, fudge, message authentication code, original ID, error
            and other fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.GetHashCode">
            <summary>
            A hash code of the combination of the algorithm time signed, fudge, message authentication code, original ID, error and other fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.Algorithm">
            <summary>
            Name of the algorithm in domain name syntax.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.TimeSigned">
            <summary>
            Seconds since 1-Jan-70 UTC.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.Fudge">
            <summary>
            Seconds of error permitted in Time Signed.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.MessageAuthenticationCode">
            <summary>
            Defined by Algorithm Name.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.OriginalId">
            <summary>
            Original message ID.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.Error">
            <summary>
            RCODE covering TSIG processing.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionSignature.Other">
            <summary>
            Empty unless Error == BADTIME.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataResponsiblePerson">
            <summary>
            RFC 1183.
            <pre>
            +------------+
            | mbox-dname |
            +------------+
            | txt-dname  |
            +------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataResponsiblePerson.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs a responsible person resource data from the given mailbox and text domain.
            </summary>
            <param name="mailbox">
            A domain name that specifies the mailbox for the responsible person.
            Its format in master files uses the DNS convention for mailbox encoding, identical to that used for the RNAME mailbox field in the SOA RR.
            The root domain name (just ".") may be specified for Mailbox to indicate that no mailbox is available.
            </param>
            <param name="textDomain">
            A domain name for which TXT RR's exist. 
            A subsequent query can be performed to retrieve the associated TXT resource records at TextDomain.
            This provides a level of indirection so that the entity can be referred to from multiple places in the DNS.
            The root domain name (just ".") may be specified for TextDomain to indicate that the TXT_DNAME is absent, and no associated TXT RR exists.
            </param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataResponsiblePerson.Mailbox">
            <summary>
            A domain name that specifies the mailbox for the responsible person.
            Its format in master files uses the DNS convention for mailbox encoding, identical to that used for the RNAME mailbox field in the SOA RR.
            The root domain name (just ".") may be specified for Mailbox to indicate that no mailbox is available.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataResponsiblePerson.TextDomain">
            <summary>
            A domain name for which TXT RR's exist. 
            A subsequent query can be performed to retrieve the associated TXT resource records at TextDomain.
            This provides a level of indirection so that the entity can be referred to from multiple places in the DNS.
            The root domain name (just ".") may be specified for TextDomain to indicate that the TXT_DNAME is absent, and no associated TXT RR exists.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Parameters">
            <summary>
            RFC 5155.
            <pre>
            +-----+-------------+----------+--------+------------+
            | bit | 0-7         | 8-14     | 15     | 16-31      |
            +-----+-------------+----------+--------+------------+
            | 0   | Hash Alg    | Reserved | OptOut | Iterations |
            +-----+-------------+----------+--------+------------+
            | 32  | Salt Length | Salt                           |
            +-----+-------------+                                |
            | ... |                                              |
            +-----+----------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Base">
            <summary>
            RFC 5155.
            <pre>
            +-----+-------------+----------+--------+------------+
            | bit | 0-7         | 8-14     | 15     | 16-31      |
            +-----+-------------+----------+--------+------------+
            | 0   | Hash Alg    | Reserved | OptOut | Iterations |
            +-----+-------------+----------+--------+------------+
            | 32  | Salt Length | Salt                           |
            +-----+-------------+                                |
            | ... |                                              |
            +-----+----------------------------------------------+
            | ... | ...                                          |
            +-----+----------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Base.HashAlgorithm">
            <summary>
            Identifies the cryptographic hash algorithm used to construct the hash-value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Base.Flags">
            <summary>
            Can be used to indicate different processing.
            All undefined flags must be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Base.Iterations">
            <summary>
            Defines the number of additional times the hash function has been performed.
            More iterations result in greater resiliency of the hash value against dictionary attacks, 
            but at a higher computational cost for both the server and resolver.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Base.Salt">
            <summary>
            Appended to the original owner name before hashing in order to defend against pre-calculated dictionary attacks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Parameters.#ctor(PcapDotNet.Packets.Dns.DnsSecNSec3HashAlgorithm,PcapDotNet.Packets.Dns.DnsSecNSec3Flags,System.UInt16,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs a next domain secure 3 parameters resource data from the hash algorithm, flags, iterations and salt fields.
            </summary>
            <param name="hashAlgorithm">Identifies the cryptographic hash algorithm used to construct the hash-value.</param>
            <param name="flags">Can be used to indicate different processing. All undefined flags must be zero.</param>
            <param name="iterations">
            Defines the number of additional times the hash function has been performed.
            More iterations result in greater resiliency of the hash value against dictionary attacks, 
            but at a higher computational cost for both the server and resolver.
            </param>
            <param name="salt">Appended to the original owner name before hashing in order to defend against pre-calculated dictionary attacks.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Parameters.Equals(PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Parameters)">
            <summary>
            Two DnsResourceDataNextDomainSecure3Parameters are equal if they have the hash algorithm, flags, iterations and salt fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Parameters.Equals(System.Object)">
            <summary>
            Two DnsResourceDataNextDomainSecure3Parameters are equal if they have the hash algorithm, flags, iterations and salt fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3Parameters.GetHashCode">
            <summary>
            A hash code made up from the combination of the hash algorithm, flags, iterations and salt fields.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3">
            <summary>
            RFC 5155.
            <pre>
            +-----+-------------+----------+--------+------------+
            | bit | 0-7         | 8-14     | 15     | 16-31      |
            +-----+-------------+----------+--------+------------+
            | 0   | Hash Alg    | Reserved | OptOut | Iterations |
            +-----+-------------+----------+--------+------------+
            | 32  | Salt Length | Salt                           |
            +-----+-------------+                                |
            | ... |                                              |
            +-----+-------------+--------------------------------+
            |     | Hash Length | Next Hashed Owner Name         |
            +-----+-------------+                                |
            | ... |                                              |
            +-----+----------------------------------------------+
            |     | Type Bit Maps                                |
            | ... |                                              |
            +-----+----------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3.#ctor(PcapDotNet.Packets.Dns.DnsSecNSec3HashAlgorithm,PcapDotNet.Packets.Dns.DnsSecNSec3Flags,System.UInt16,PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.DataSegment,System.Collections.Generic.IEnumerable{PcapDotNet.Packets.Dns.DnsType})">
            <summary>
            Constructs an instance out of the hash algorithm, flags, iterations, salt, next hashed owner name and types exist fields.
            </summary>
            <param name="hashAlgorithm">Identifies the cryptographic hash algorithm used to construct the hash-value.</param>
            <param name="flags">Can be used to indicate different processing. All undefined flags must be zero.</param>
            <param name="iterations">
            Defines the number of additional times the hash function has been performed.
            More iterations result in greater resiliency of the hash value against dictionary attacks, 
            but at a higher computational cost for both the server and resolver.
            </param>
            <param name="salt">Appended to the original owner name before hashing in order to defend against pre-calculated dictionary attacks.</param>
            <param name="nextHashedOwnerName">
            Contains the next hashed owner name in hash order.
            This value is in binary format.
            Given the ordered set of all hashed owner names, the Next Hashed Owner Name field contains the hash of an owner name that immediately follows the owner name of the given NSEC3 RR.
            The value of the Next Hashed Owner Name field in the last NSEC3 RR in the zone is the same as the hashed owner name of the first NSEC3 RR in the zone in hash order.
            Note that, unlike the owner name of the NSEC3 RR, the value of this field does not contain the appended zone name.
            </param>
            <param name="typesExist">Identifies the RRSet types that exist at the original owner name of the NSEC3 RR.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3.Equals(PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3)">
            <summary>
            Two DnsResourceDataNextDomainSecure3 are equal iff their hash algorithm, flags, iterations, salt, next hashed owner name and types exist fields
            are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3.Equals(System.Object)">
            <summary>
            Two DnsResourceDataNextDomainSecure3 are equal iff their hash algorithm, flags, iterations, salt, next hashed owner name and types exist fields
            are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3.GetHashCode">
            <summary>
            A hash code of the combination of the hash algorithm, flags, iterations, salt, next hashed owner name and types exist fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3.NextHashedOwnerName">
            <summary>
            Contains the next hashed owner name in hash order.
            This value is in binary format.
            Given the ordered set of all hashed owner names, the Next Hashed Owner Name field contains the hash of an owner name that immediately follows the owner name of the given NSEC3 RR.
            The value of the Next Hashed Owner Name field in the last NSEC3 RR in the zone is the same as the hashed owner name of the first NSEC3 RR in the zone in hash order.
            Note that, unlike the owner name of the NSEC3 RR, the value of this field does not contain the appended zone name.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure3.TypesExist">
            <summary>
            Identifies the RRSet types that exist at the original owner name of the NSEC3 RR.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataKey">
            <summary>
            RFC 2065, 2535.
            <pre>
            +-----+---+---+--------------+----+----------+------+--------+-------+-------+----------+-------+
            | bit | 0 | 1 | 2            | 3  | 4        | 5    | 6-7    | 8     | 9     | 10-11    | 12-15 |
            +-----+---+---+--------------+----+----------+------+--------+-------+-------+----------+-------+
            | 0   | A | C | experimental | XT | Reserved | user | NAMTYP | IPSEC | email | Reserved | SIG   |
            +-----+---+---+--------------+----+----------+------+--------+-------+-------+----------+-------+
            | 16  | protocol                                             | algorithm                        |
            +-----+------------------------------------------------------+----------------------------------+
            | 32  | Flags extension (optional)                                                              |
            +-----+-----------------------------------------------------------------------------------------+
            | 32  | public key                                                                              |
            | or  |                                                                                         |
            | 48  |                                                                                         |
            | ... |                                                                                         |
            +-----+-----------------------------------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataKey.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,PcapDotNet.Packets.Dns.DnsKeyNameType,PcapDotNet.Packets.Dns.DnsKeySignatoryAttributes,PcapDotNet.Packets.Dns.DnsKeyProtocol,PcapDotNet.Packets.Dns.DnsAlgorithm,System.Nullable{System.UInt16},PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the authentication prohibited, confidentiality prohibited, experimental, user associated, IPSec, email, name type, 
            signatory, protocol, algorithm, flags extension and public key fields.
            </summary>
            <param name="authenticationProhibited">Use of the key is prohibited for authentication.</param>
            <param name="confidentialityProhibited">Use of the key is prohibited for confidentiality.</param>
            <param name="experimental">
            Ignored if the type field indicates "no key" and the following description assumes that type field to be non-zero.
            Keys may be associated with zones, entities, or users for experimental, trial, or optional use, in which case this bit will be one.
            If this bit is a zero, it means that the use or availability of security based on the key is "mandatory". 
            Thus, if this bit is off for a zone key, the zone should be assumed secured by SIG RRs and any responses indicating the zone is not secured should be considered bogus.
            If this bit is a one for a host or end entity, it might sometimes operate in a secure mode and at other times operate without security.
            The experimental bit, like all other aspects of the KEY RR, is only effective if the KEY RR is appropriately signed by a SIG RR.
            The experimental bit must be zero for safe secure operation and should only be a one for a minimal transition period.
            </param>
            <param name="userAssociated">
            Indicates that this is a key associated with a "user" or "account" at an end entity, usually a host.
            The coding of the owner name is that used for the responsible individual mailbox in the SOA and RP RRs:
            The owner name is the user name as the name of a node under the entity name.
            For example, "j.random_user" on host.subdomain.domain could have a public key associated through a KEY RR
            with name j\.random_user.host.subdomain.domain and the user bit a one.
            It could be used in an security protocol where authentication of a user was desired.
            This key might be useful in IP or other security for a user level service such a telnet, ftp, rlogin, etc.
            </param>
            <param name="ipSec">
            Indicates that this key is valid for use in conjunction with that security standard.
            This key could be used in connection with secured communication on behalf of an end entity or user whose name is the owner name of the KEY RR
            if the entity or user bits are on.
            The presence of a KEY resource with the IPSEC and entity bits on and experimental and no-key bits off is an assertion that the host speaks IPSEC.
            </param>
            <param name="email">
            Indicates that this key is valid for use in conjunction with MIME security multiparts.
            This key could be used in connection with secured communication on behalf of an end entity or user
            whose name is the owner name of the KEY RR if the entity or user bits are on.
            </param>
            <param name="nameType">The name type.</param>
            <param name="signatory">
            If non-zero, indicates that the key can validly sign things as specified in DNS dynamic update.
            Note that zone keys always have authority to sign any RRs in the zone regardless of the value of the signatory field.
            </param>
            <param name="protocol">
            It is anticipated that keys stored in DNS will be used in conjunction with a variety of Internet protocols.
            It is intended that the protocol octet and possibly some of the currently unused (must be zero) bits in the KEY RR flags 
            as specified in the future will be used to indicate a key's validity for different protocols.
            </param>
            <param name="algorithm">The key algorithm parallel to the same field for the SIG resource.</param>
            <param name="flagsExtension">
            Optional second 16 bit flag field after the algorithm octet and before the key data.
            Must not be non-null unless one or more such additional bits have been defined and are non-zero.
            </param>
            <param name="publicKey">The public key value.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataKey.Equals(PcapDotNet.Packets.Dns.DnsResourceDataKey)">
            <summary>
            Two DnsResourceDataKey are equal iff their authentication prohibited, confidentiality prohibited, experimental, user associated, IPSec, email, 
            name type, signatory, protocol, algorithm, flags extension and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataKey.Equals(System.Object)">
            <summary>
            Two DnsResourceDataKey are equal iff their authentication prohibited, confidentiality prohibited, experimental, user associated, IPSec, email, 
            name type, signatory, protocol, algorithm, flags extension and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataKey.GetHashCode">
            <summary>
            A hash code out of the combination of the authentication prohibited, confidentiality prohibited, experimental, user associated, IPSec, email, 
            name type, signatory, protocol, algorithm, flags extension and public key fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.AuthenticationProhibited">
            <summary>
            Use of the key is prohibited for authentication.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.ConfidentialityProhibited">
            <summary>
            Use of the key is prohibited for confidentiality.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.Experimental">
            <summary>
            Ignored if the type field indicates "no key" and the following description assumes that type field to be non-zero.
            Keys may be associated with zones, entities, or users for experimental, trial, or optional use, in which case this bit will be one.
            If this bit is a zero, it means that the use or availability of security based on the key is "mandatory". 
            Thus, if this bit is off for a zone key, the zone should be assumed secured by SIG RRs and any responses indicating the zone is not secured should be considered bogus.
            If this bit is a one for a host or end entity, it might sometimes operate in a secure mode and at other times operate without security.
            The experimental bit, like all other aspects of the KEY RR, is only effective if the KEY RR is appropriately signed by a SIG RR.
            The experimental bit must be zero for safe secure operation and should only be a one for a minimal transition period.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.UserAssociated">
            <summary>
            Indicates that this is a key associated with a "user" or "account" at an end entity, usually a host.
            The coding of the owner name is that used for the responsible individual mailbox in the SOA and RP RRs:
            The owner name is the user name as the name of a node under the entity name.
            For example, "j.random_user" on host.subdomain.domain could have a public key associated through a KEY RR
            with name j\.random_user.host.subdomain.domain and the user bit a one.
            It could be used in an security protocol where authentication of a user was desired.
            This key might be useful in IP or other security for a user level service such a telnet, ftp, rlogin, etc.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.IpSec">
            <summary>
            Indicates that this key is valid for use in conjunction with that security standard.
            This key could be used in connection with secured communication on behalf of an end entity or user whose name is the owner name of the KEY RR
            if the entity or user bits are on.
            The presence of a KEY resource with the IPSEC and entity bits on and experimental and no-key bits off is an assertion that the host speaks IPSEC.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.Email">
            <summary>
            Indicates that this key is valid for use in conjunction with MIME security multiparts.
            This key could be used in connection with secured communication on behalf of an end entity or user
            whose name is the owner name of the KEY RR if the entity or user bits are on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.NameType">
            <summary>
            The name type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.Signatory">
            <summary>
            If non-zero, indicates that the key can validly sign things as specified in DNS dynamic update.
            Note that zone keys always have authority to sign any RRs in the zone regardless of the value of the signatory field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.Protocol">
            <summary>
            It is anticipated that keys stored in DNS will be used in conjunction with a variety of Internet protocols.
            It is intended that the protocol octet and possibly some of the currently unused (must be zero) bits in the KEY RR flags 
            as specified in the future will be used to indicate a key's validity for different protocols.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.Algorithm">
            <summary>
            The key algorithm parallel to the same field for the SIG resource.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.FlagsExtension">
            <summary>
            Optional second 16 bit flag field after the algorithm octet and before the key data.
            Must not be non-null unless one or more such additional bits have been defined and are non-zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKey.PublicKey">
            <summary>
            The public key value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataIpV6">
            <summary>
            RFC 3596.
            <pre>
            +-----+-------+
            | bit | 0-127 |
            +-----+-------+
            | 0   | IP    |
            +-----+-------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV6.#ctor(PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Constructs an IPv6 resource data from the given IP.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV6.Equals(PcapDotNet.Packets.Dns.DnsResourceDataIpV6)">
            <summary>
            Two IPv6 resource datas are equal if their IP is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV6.Equals(System.Object)">
            <summary>
            Two IPv6 resource datas are equal if their IP is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV6.GetHashCode">
            <summary>
            Returns the hash code of the IPv6 value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIpV6.Data">
            <summary>
            The IPv6 value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsType">
            <summary>
            RFCs 1035, 1183, 1348, 1706, 1712, 1876, 1995, 2065, 2163, 2168, 2230, 2535, 2671, 2672, 2782, 2845, 2874, 2915, 2930, 3123, 3226, 3403, 3596, 3658,
            3755, 4025, 4034, 4255, 4398, 4408, 4431, 4701, 5011, 5155, 5205, 5864, 5936.
            Other sources: ATMDOC, Barwood, Eastlake, Faltstrom, Hallam-Baker, PATTON, Reid, Weiler, Wijngaards.
            Type fields are used in resource records.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.A">
            <summary>
            RFC 1035.
            A host address.
            Payload type: DnsResourceDataIpV4.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Ns">
            <summary>
            RFC 1035.
            An authoritative name server.
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Md">
            <summary>
            RFC 1035.
            A mail destination (Obsolete - use MX).
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.MailForwarder">
            <summary>
            RFC 1035.
            MF - A mail forwarder (Obsolete - use MX).
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.CName">
            <summary>
            RFC 1035.
            The canonical name for an alias.
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.StartOfAuthority">
            <summary>
            RFC 1035.
            SOA - Marks the start of a zone of authority.
            Payload type: DnsResourceDataStartOfAuthority.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Mailbox">
            <summary>
            RFC 1035.
            MB - A mailbox domain name (EXPERIMENTAL).
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.MailGroup">
            <summary>
            RFC 1035.
            MG - A mail group member (EXPERIMENTAL).
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.MailRename">
            <summary>
            RFC 1035.
            MR - A mail rename domain name (EXPERIMENTAL).
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Null">
            <summary>
            RFC 1035.
            A null RR (EXPERIMENTAL).
            Payload type: DnsResourceDataAnything.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Wks">
            <summary>
            RFC 1035.
            A well known service description..
            Payload type: DnsResourceDataWellKnownService.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Ptr">
            <summary>
            RFC 1035.
            A domain name pointer.
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.HInfo">
            <summary>
            RFC 1035.
            Host information.
            Payload type: DnsResourceDataHostInformation.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.MInfo">
            <summary>
            RFC 1035.
            mailbox or mail list information.
            Payload type: DnsResourceDataMailingListInfo.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.MailExchange">
            <summary>
            RFC 1035.
            MX - Mail exchange.
            Payload type: DnsResourceDataMailExchange.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Txt">
            <summary>
            RFC 1035.
            Text strings.
            Payload type: DnsResourceDataText.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.ResponsiblePerson">
            <summary>
            RFC 1183.
            RP - For Responsible Person.
            Payload type: DnsResourceDataResponsiblePerson.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.AfsDatabase">
            <summary>
            RFCs 1183, 5864.
            AFSDB - For AFS Data Base location.
            Payload type: DnsResourceDataAfsDb.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.X25">
            <summary>
            RFC 1183.
            For X.25 PSDN address.
            Payload type: DnsResourceDataString.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Isdn">
            <summary>
            RFC 1183.
            For ISDN address.
            Payload type: DnsResourceDataIsdn.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.RouteThrough">
            <summary>
            RFC 1183.
            RT - For Route Through.
            Payload type: DnsResourceDataRouteThrough.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NetworkServiceAccessPoint">
            <summary>
            RFC 1706.
            NSAP - Network Service Access Point.
            For NSAP address, NSAP style A record.
            Payload type: DnsResourceDataNetworkServiceAccessPoint.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NetworkServiceAccessPointPointer">
            <summary>
            RFC 1348.
            NSAPPTR - For domain name pointer, NSAP style.
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Signature">
            <summary>
            RFCs 2535, 3755, 4034.
            SIG - For security signature.
            Payload type: DnsResourceDataSignature.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Key">
            <summary>
            RFCs 2065, 2535, 3755, 4034.
            For security key.
            Payload type: DnsResourceDataKey.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.PointerX400">
            <summary>
            RFC 2163.
            PX - X.400 mail mapping information.
            Payload type: DnsResourceDataX400Pointer.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.GPos">
            <summary>
            RFC 1712.
            Geographical Position.
            Payload type: DnsResourceDataGeographicalPosition.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Aaaa">
            <summary>
            RFC 3596.
            IP6 Address.
            Payload type: DnsResourceDataIpV6.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Loc">
            <summary>
            RFC 1876.
            Location Information.
            Payload type: DnsResourceDataLocationInformation.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NextDomain">
            <summary>
            RFC 2535, 3755.
            NXT - Next Domain - OBSOLETE.
            Payload type: DnsResourceDataNextDomain.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.EId">
            <summary>
            Patton.
            Nimrod Endpoint Identifier.
            Payload type: DnsResourceDataAnything.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NimrodLocator">
            <summary>
            Patton.
            NimLoc - Nimrod Locator.
            Payload type: DnsResourceDataAnything.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.ServerSelection">
            <summary>
            RFC 2782.
            SRV - Server Selection.
            Payload type: DnsResourceDataServerSelection.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.AtmA">
            <summary>
            ATMDOC.
            ATM Address.
            Payload type: DnsResourceDataAtmAddress.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NaPtr">
            <summary>
            RFCs 2168, 2915, 3403.
            Naming Authority Pointer.
            Payload type: DnsResourceDataNamingAuthorityPointer.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.KeyExchanger">
            <summary>
            RFC 2230.
            KX - Key Exchanger.
            Payload type: DnsResourceDataKeyExchanger.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Cert">
            <summary>
            RFC 4398.
            CERT.
            Payload type: DnsResourceDataCertificate.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.A6">
            <summary>
            RFCs 2874, 3226.
            A6 (Experimental).
            Payload type: DnsResourceDataA6.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.DName">
            <summary>
            RFC 2672.
            DNAME.
            Payload type: DnsResourceDataDomainName.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Sink">
            <summary>
            Eastlake.
            SINK.
            Payload type: DnsResourceDataSink.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Opt">
            <summary>
            RFC 2671.
            OPT.
            Payload type: DnsResourceDataOptions.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Apl">
            <summary>
            RFC 3123.
            Address Prefix List.
            Payload type: DnsResourceDataAddressPrefixList.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.DelegationSigner">
            <summary>
            RFCs 3658, 4034.
            DS - Delegation Signer.
            Payload type: DnsResourceDataDelegationSigner.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.SshFingerprint">
            <summary>
            RFC 4255.
            SSHFP - SSH Key Fingerprint.
            Used to store a fingerprint of an SSH public host key that is associated with a Domain Name System (DNS) name.
            Payload type: DnsResourceDataSshFingerprint.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.IpSecKey">
            <summary>
            RFC 4025.
            IPSECKEY.
            Payload type: DnsResourceDataIpSecKey.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.ResourceRecordSignature">
            <summary>
            RFCs 3755, 4034.
            RRSIG.
            Payload type: DnsResourceDataSignature.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NSec">
            <summary>
            RFCs 3755, 4034.
            NSEC.
            Payload type: DnsResourceDataNextDomainSecure.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.DnsKey">
            <summary>
            RFCs 3755, 4034, 5011.
            DNSKEY.
            Represents the public key.
            Payload type: DnsResourceDataDnsKey.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.DynamicHostConfigurationId">
            <summary>
            RFC 4701.
            DHCID.
            Dynamic Host Configuration Information.
            Payload type: DnsResourceDataAnything.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NSec3">
            <summary>
            RFC 5155.
            NSEC3.
            Payload type: DnsResourceDataNextDomainSecure3.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NSec3Parameters">
            <summary>
            RFC 5155.
            NSEC3PARAM.
            Payload type: DnsResourceDataNextDomainSecure3Parameters.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Hip">
            <summary>
            RFC 5205.
            Host Identity Protocol.
            Payload type: DnsResourceDataHostIdentityProtocol.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.NInfo">
            <summary>
            Reid.
            NINFO.
            Payload type: DnsResourceDataNInfo.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.RKey">
            <summary>
            Reid.
            RKEY.
            Can be used to encrypt NAPTR record.
            Payload type: DnsResourceDataRKey.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.TrustAnchorLink">
            <summary>
            Wijngaards.
            TALINK - DNSSEC Trust Anchor LINK.
            Payload type: DnsResourceDataTrustAnchorLink.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Cds">
            <summary>
            Barwood.
            Child DS.
            Payload type: DnsResourceDataDelegationSigner.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Spf">
            <summary>
            RFC 4408.
            Sender Policy Framework.
            Payload type: DnsResourceDataText.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.UInfo">
            <summary>
            IANA-Reserved.
            Not documented.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Uid">
            <summary>
            IANA-Reserved.
            Not documented.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Gid">
            <summary>
            IANA-Reserved.
            Not documented.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Unspecified">
            <summary>
            IANA-Reserved.
            UNSPEC - Not documented.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.TKey">
            <summary>
            RFC 2930.
            Transaction Key.
            Payload type: DnsResourceDataTransactionKey.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.TransactionSignature">
            <summary>
            RFC 2845.
            TSIG - Transaction Signature.
            Payload type: DnsResourceDataTransactionSignature.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Ixfr">
            <summary>
            RFC 1995.
            Incremental transfer.
            Query Type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Axfr">
            <summary>
            RFCs 1035, 5936.
            Transfer of an entire zone.
            Query Type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.MailB">
            <summary>
            RFC 1035.
            Mailbox-related RRs (MB, MG or MR).
            Query Type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.MailA">
            <summary>
            RFC 1035.
            Mail agent RRs (Obsolete - see MX).
            Query Type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Any">
            <summary>
            *.
            A request for all records
            Query Type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.Uri">
            <summary>
            Faltstrom.
            URI.
            Payload type: DnsResourceDataUri.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.CertificationAuthorityAuthorization">
            <summary>
            Hallam-Baker.
            CAA - Certification Authority Authorization.
            Payload type: DnsResourceDataCertificationAuthorityAuthorization.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.TrustAnchor">
            <summary>
            Weiler. 2005-12-13.
            TA - DNSSEC Trust Authorities or Trust Anchor.
            Payload type: DnsResourceDataDelegationSigner.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsType.DnsSecLookAsideValidation">
            <summary>
            RFC 4431.
            DLV - DNSSEC Lookaside Validation.
            Payload type: DnsResourceDataDelegationSigner.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResponseCode">
            <summary>
            RFCs 1035, 2136, 2671, 2845, 2930, 4635.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.NoError">
            <summary>
            RFC 1035.
            No error condition
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.FormatError">
            <summary>
            RFC 1035.
            Format error - The name server was unable to interpret the query.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.ServerFailure">
            <summary>
            RFC 1035.
            Server failure - The name server was unable to process this query due to a problem with the name server.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.NotExistentDomain">
            <summary>
            RFC 1035.
            Name Error - Meaningful only for responses from an authoritative name server, 
            this code signifies that the domain name referenced in the query does not exist.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.NotImplemented">
            <summary>
            RFC 1035.
            Not Implemented - The name server does not support the requested kind of query.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.Refused">
            <summary>
            RFC 1035.
            Refused - The name server refuses to perform the specified operation for policy reasons.  
            For example, a name server may not wish to provide the information to the particular requester, 
            or a name server may not wish to perform a particular operation (e.g., zone transfer) for particular data.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.YxDomain">
            <summary>
            RFC 2136.
            YXDomain. Name Exists when it should not.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.YxResourceRecordSet">
            <summary>
            RFC 2136.
            YXRRSET - RR Set Exists when it should not.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.NotExistResourceRecordSet">
            <summary>
            RFC 2136.
            NXRRSET - RR Set that should exist does not (NX).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.NotAuth">
            <summary>
            RFC 2136.
            Server Not Authoritative for zone.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.NotZone">
            <summary>
            RFC 2136.
            Name not contained in zone.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.BadVersionOrBadSignature">
            <summary>
            RFCs 2671, 2845.
            Bad OPT Version or TSIG Signature Failure.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.BadKey">
            <summary>
            RFC 2845.
            Key not recognized.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.BadTime">
            <summary>
            RFC 2845.
            Signature out of time window.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.BadMode">
            <summary>
            RFC 2930.
            Bad TKEY Mode.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.BadName">
            <summary>
            RFC 2930.
            Duplicate key name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.BadAlgorithm">
            <summary>
            RFC 2930.
            Algorithm not supported.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResponseCode.BadTruncation">
            <summary>
            RFC 4635.
            BADTRUNC - Bad Truncation.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsPublicKeyAlgorithm">
            <summary>
            Identifies the public key's cryptographic algorithm and determines the format of the public key field.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsPublicKeyAlgorithm.None">
            <summary>
            Indicates that no key is present.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsPublicKeyAlgorithm.Dsa">
            <summary>
            A DSA key is present, in the format defined in RFC 2536.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsPublicKeyAlgorithm.Rsa">
            <summary>
            A RSA key is present, in the format defined in RFC 3110 with the following changes:
            The earlier definition of RSA/MD5 in RFC 2065 limited the exponent and modulus to 2552 bits in length.
            RFC 3110 extended that limit to 4096 bits for RSA/SHA1 keys
            The IPSECKEY RR imposes no length limit on RSA public keys, other than the 65535 octet limit imposed by the two-octet length encoding.
            This length extension is applicable only to IPSECKEY; it is not applicable to KEY RRs. 
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsCertificateType">
            <summary>
            The certificate type for cetificate DNS resource records.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.None">
            <summary>
            No certificate type defined.
            Should not be used.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.Pkix">
            <summary>
            RFC 4398.
            Indicates an X.509 certificate conforming to the profile defined by the IETF PKIX working group. 
            The certificate section will start with a one-octet unsigned OID length and then an X.500 OID indicating the nature of the remainder of the certificate section.
            Note: X.509 certificates do not include their X.500 directory-type-designating OID as a prefix.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.SimplePublicKeyInfrastructure">
            <summary>
            RFC 4398.
            SPKI certificate.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.Pgp">
            <summary>
            RFC 4398.
            PGP - Indicates an OpenPGP packet.
            This is used to transfer public key material and revocation signatures.
            The data is binary and must not be encoded into an ASCII armor.
            An implementation should process transferable public keys, but it may handle additional OpenPGP packets.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.IPkix">
            <summary>
            RFC 4398.
            The URL of an X.509 data object.
            Must be used when the content is too large to fit in the CERT RR and may be used at the implementer's discretion.
            Should not be used where the DNS message is 512 octets or smaller and could thus be expected to fit a UDP packet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.IndirectSimplePublicKeyInfrastructure">
            <summary>
            RFC 4398.
            ISPKI - The URL of an SPKI certificate.
            Must be used when the content is too large to fit in the CERT RR and may be used at the implementer's discretion.
            Should not be used where the DNS message is 512 octets or smaller and could thus be expected to fit a UDP packet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.Ipgp">
            <summary>
            RFC 4398.
            Contains both an OpenPGP fingerprint for the key in question, as well as a URL.
            The certificate portion of the IPgp CERT RR is defined as a one-octet fingerprint length, followed by the OpenPGP fingerprint, followed by the URL.
            The OpenPGP fingerprint is calculated as defined in RFC 2440.
            A zero-length fingerprint or a zero-length URL are legal, and indicate URL-only IPGP data or fingerprint-only IPGP data, respectively.
            A zero-length fingerprint and a zero-length URL are meaningless and invalid.
            Must be used when the content is too large to fit in the CERT RR and may be used at the implementer's discretion.
            Should not be used where the DNS message is 512 octets or smaller and could thus be expected to fit a UDP packet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.AttributeCertificatePkix">
            <summary>
            RFC 4398.
            ACPKIX - Attribute Certificate.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.IndirectAttributeCertificatePkix">
            <summary>
            RFC 4398.
            IAcPkix - The URL of an Attribute Certificate.
            Must be used when the content is too large to fit in the CERT RR and may be used at the implementer's discretion.
            Should not be used where the DNS message is 512 octets or smaller and could thus be expected to fit a UDP packet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.Uri">
            <summary>
            RFC 4398.
            Indicates a certificate format defined by an absolute URI.
            The certificate portion of the CERT RR must begin with a null-terminated URI, and the data after the null is the private format certificate itself.
            The URI should be such that a retrieval from it will lead to documentation on the format of the certificate.
            Recognition of private certificate types need not be based on URI equality but can use various forms of pattern matching so that, for example, subtype or version information can also be encoded into the URI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsCertificateType.ObjectIdentifier">
            <summary>
            RFC 4398.
            Indicates a private format certificate specified by an ISO OID prefix.
            The certificate section will start with a one-octet unsigned OID length and then a BER-encoded OID indicating the nature of the remainder of the certificate section.
            This can be an X.509 certificate format or some other format.
            X.509 certificates that conform to the IETF PKIX profile should be indicated by the PKIX type, not the OID private type.
            Recognition of private certificate types need not be based on OID equality but can use various forms of pattern matching such as OID prefix.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsLayer">
            <summary>
            Represents a DNS layer.
            <seealso cref="T:PcapDotNet.Packets.Dns.DnsDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsLayer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsLayer.Equals(PcapDotNet.Packets.Dns.DnsLayer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.Id">
            <summary>
            A 16 bit identifier assigned by the program that generates any kind of query.  
            This identifier is copied the corresponding reply and can be used by the requester to match up replies to outstanding queries.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsResponse">
            <summary>
            A one bit field that specifies whether this message is a query (0), or a response (1).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsQuery">
            <summary>
            Specifies whether this message is a query or a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.OpCode">
            <summary>
            Specifies kind of query in this message.  
            This value is set by the originator of a query and copied into the response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsAuthoritativeAnswer">
            <summary>
            This bit is valid in responses, and specifies that the responding name server is an authority for the domain name in question section.
            Note that the contents of the answer section may have multiple owner names because of aliases.  
            The AA bit corresponds to the name which matches the query name, or the first owner name in the answer section.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsTruncated">
            <summary>
            Specifies that this message was truncated due to length greater than that permitted on the transmission channel.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsRecursionDesired">
            <summary>
            This bit may be set in a query and is copied into the response.  
            If RD is set, it directs the name server to pursue the query recursively. 
            Recursive query support is optional.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsRecursionAvailable">
            <summary>
            This bit is set or cleared in a response, and denotes whether recursive query support is available in the name server.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.FutureUse">
            <summary>
            Reserved for future use.  
            Must be false in all queries and responses.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsAuthenticData">
            <summary>
            The name server side of a security-aware recursive name server must not set the AD bit in a response
            unless the name server considers all RRsets in the Answer and Authority sections of the response to be authentic.
            The name server side should set the AD bit if and only if the resolver side considers all RRsets in the Answer section
            and any relevant negative response RRs in the Authority section to be authentic.
            The resolver side must follow the Authenticating DNS Responses procedure to determine whether the RRs in question are authentic.
            However, for backward compatibility, a recursive name server may set the AD bit when a response includes unsigned CNAME RRs
            if those CNAME RRs demonstrably could have been synthesized from an authentic DNAME RR that is also included in the response
            according to the synthesis rules described in RFC 2672.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.IsCheckingDisabled">
            <summary>
            Exists in order to allow a security-aware resolver to disable signature validation
            in a security-aware name server's processing of a particular query.
            
            The name server side must copy the setting of the CD bit from a query to the corresponding response.
            
            The name server side of a security-aware recursive name server must pass the state of the CD bit to the resolver side
            along with the rest of an initiating query,
            so that the resolver side will know whether it is required to verify the response data it returns to the name server side.
            If the CD bit is set, it indicates that the originating resolver is willing to perform whatever authentication its local policy requires.
            Thus, the resolver side of the recursive name server need not perform authentication on the RRsets in the response.
            When the CD bit is set, the recursive name server should, if possible, return the requested data to the originating resolver, 
            even if the recursive name server's local authentication policy would reject the records in question.
            That is, by setting the CD bit, the originating resolver has indicated that it takes responsibility for performing its own authentication,
            and the recursive name server should not interfere.
            
            If the resolver side implements a BAD cache and the name server side receives a query that matches an entry in the resolver side's BAD cache,
            the name server side's response depends on the state of the CD bit in the original query.
            If the CD bit is set, the name server side should return the data from the BAD cache;
            if the CD bit is not set, the name server side must return RCODE 2 (server failure).
            
            The intent of the above rule is to provide the raw data to clients that are capable of performing their own signature verification checks
            while protecting clients that depend on the resolver side of a security-aware recursive name server to perform such checks.
            Several of the possible reasons why signature validation might fail involve conditions
            that may not apply equally to the recursive name server and the client that invoked it.
            For example, the recursive name server's clock may be set incorrectly, or the client may have knowledge of a relevant island of security
            that the recursive name server does not share.
            In such cases, "protecting" a client that is capable of performing its own signature validation from ever seeing the "bad" data does not help the client.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.ResponseCode">
            <summary>
            A response of the server that can sign errors or other messages.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.Queries">
            <summary>
            The queries resource records.
            Typically exactly one query will exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.Answers">
            <summary>
            The answers resource records.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.Authorities">
            <summary>
            The authorities resource records.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.Additionals">
            <summary>
            The additionals resource records.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.ResourceRecords">
            <summary>
            All the resource records by the order the will be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.DomainNameCompressionMode">
            <summary>
            How to compress the domain names.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram">
            <summary>
            IEEE 802.1Q.
            <pre>
            +-----+-----+-----+------+------------------+
            | bit | 0-2 | 3   | 4-15 | 16-31            |
            +-----+-----+-----+------+------------------+
            | 0   | TCI              | EtherType/Length |
            +-----+-----+-----+------+------------------+
            | 0   | PCP | CFI | VID  | EtherType/Length |
            +-----+-----+-----+------+------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram">
            <summary>
            Base class for all datagrams that behave like Ethernet.
            Contains a header with an Ethernet type and a payload that should be according to this Ethernet type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.HeaderLength">
            <summary>
            Header length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.EtherType">
            <summary>
            Ethernet type (next protocol).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.Payload">
            <summary>
            The Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.Trailer">
            <summary>
            The bytes padding the Ethernet packet beyond the actual Ethernet payload.
            This assumes we know how to calculate the actual payload length (For example, by using the Total Length of the IPv4 payload).
            If we don't know how to calculate the actual payload length <see langword="null"/> will be returned.
            The trailer doesn't include the <see cref="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.FrameCheckSequence"/> if it exists.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.FrameCheckSequence">
            <summary>
            The 4 bytes of the France Check Sequence (FCS).
            Usually, these bytes won't be available because the device remvoed them after checking their validity.
            We assume they exist when we see that the Ethernet padding pads to 68 bytes or more.
            If the padding isn't that long or we don't know how to calculate the real payload length, <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.VLanTaggedFrame">
            <summary>
            The Ethernet payload as a VLAN Tagged Frame datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.IpV4">
            <summary>
            The Ethernet payload as an IPv4 datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseDatagram.Arp">
            <summary>
            The Ethernet payload as an ARP datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.HeaderLengthValue">
            <summary>
            The number of bytes in the header takes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.NullVLanIdentifier">
            <summary>
            The null VLAN ID.
            Indicates that the tag header contains only priority information; no VLAN identifier is present in the frame.
            This VID value shall not be configured as a PVID or a member of a VID Set, or configured in any Filtering Database entry, 
            or used in any Management operation.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.DefaultPortVLanIdentifier">
            <summary>
            The default PVID value used for classifying frames on ingress through a Bridge Port.
            The PVID value of a Port can be changed by management.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.MaxVLanIdentifier">
            <summary>
            Reserved for implementation use.
            This VID value shall not be configured as a PVID or a member of a VID Set, or transmitted in a tag header.
            This VID value may be used to indicate a wildcard match for the VID in management operations or Filtering Database entries.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.CalculateIsValid">
            <summary>
            The datagram is valid if the length is correct according to the header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.HeaderLength">
            <summary>
            Header length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.PriorityCodePoint">
            <summary>
            Indicates the frame priority level.
            Values are from 0 (best effort) to 7 (highest); 1 represents the lowest priority.
            These values can be used to prioritize different classes of traffic (voice, video, data, etc.).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.CanonicalFormatIndicator">
            <summary>
            If reset, all MAC Address information that may be present in the MSDU is in Canonical format and the tag comprises solely the TPID and TCI fields,
            i.e., the tag does not contain an Embedded Routing Information Field (E-RIF).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.VLanIdentifier">
            <summary>
            A VLAN-aware Bridge may not support the full range of VID values but shall support the use of all VID values in the range 0 through a maximum N,
            less than or equal to 4094 and specified for that implementation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.TagControlInformation">
            <summary>
            A combination of pcp (PriorityCodePoint), cfi (CanonicalFormatIndicator) and vid (VLanIdentifier).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram.EtherType">
            <summary>
            Ethernet type (next protocol).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.OptionComplexFactory`1.OptionHeaderLength">
            <summary>
            The header length in bytes for the option (type and size).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.ByteArrayExtensions">
            <summary>
            Extension methods for byte[].
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Compare(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compares all the bytes in the two ranges of the arrays.
            Returns the first non-zero compare value of the bytes in the ranges or zero if the ranges have the same byte values.
            </summary>
            <param name="array">The first array to compare.</param>
            <param name="offset">The offset of the first byte to compare in the first array.</param>
            <param name="other">The second array to compare.</param>
            <param name="otherOffset">The offset of the first byte to compare in the second array.</param>
            <param name="count">The number of bytes to compare.</param>
            <returns>The first non-zero compare value of the bytes in the ranges or zero if the ranges have the same byte values.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.SequenceEqual(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compares all the bytes in the two ranges of the arrays.
            Returns true iff the ranges have the same byte values.
            </summary>
            <param name="array">The first array to compare.</param>
            <param name="offset">The offset of the first byte to compare in the first array.</param>
            <param name="other">The second array to compare.</param>
            <param name="otherOffset">The offset of the first byte to compare in the second array.</param>
            <param name="count">The number of bytes to compare.</param>
            <returns>True iff the ranges have the same byte values.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Find(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the first offset in the array where the other array's range sequence of bytes can be found or the length of the array if no match exists.
            </summary>
            <param name="array">The array to search for the sequence of bytes.</param>
            <param name="offset">The offset of the first byte in the array that should be compared to the sequence to find.</param>
            <param name="count">The number of bytes in the array that the sequence can be searched in.</param>
            <param name="other">The array that contains the sequence of bytes to search.</param>
            <param name="otherOffset">The offset in the array containing the sequence of the first byte of the sequence.</param>
            <param name="otherCount">The number of bytes of the sequence.</param>
            <returns>The first offset in the array where the other array's range sequence of bytes can be found or the length of the array if no match exists.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Find(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Returns the first offset in the array where the other array sequence of bytes can be found or the length of the array if no match exists.
            </summary>
            <param name="array">The array to search for the sequence of bytes.</param>
            <param name="offset">The offset of the first byte in the array that should be compared to the sequence to find.</param>
            <param name="count">The number of bytes in the array that the sequence can be searched in.</param>
            <param name="other">The array that contains the sequence of bytes to search.</param>
            <returns>The first offset in the array where the other array sequence of bytes can be found or the length of the array if no match exists.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.BlockCopy(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies a specified number of bytes from a source array starting at a particular offset to a destination array starting at a particular offset.
            </summary>
            <param name="source">The source buffer.</param>
            <param name="sourceOffset">The byte offset into source.</param>
            <param name="destination">The destination buffer.</param>
            <param name="destinationOffset">The byte offset into destination.</param>
            <param name="count">The number of bytes to copy.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadByte(System.Byte[],System.Int32)">
            <summary>
            Reads a byte from a specific offset.
            </summary>
            <param name="buffer">The buffer to read the byte from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadByte(System.Byte[],System.Int32@)">
            <summary>
            Reads a byte from a specific offset and increments the offset by 1.
            </summary>
            <param name="buffer">The buffer to read the byte from.</param>
            <param name="offset">The offset in the buffer to start reading and to increment.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from a specific offset.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadBytes(System.Byte[],System.Int32@,System.Int32)">
            <summary>
            Reads bytes from a specific offset and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading and to increment.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadShort(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset as a short with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUShort(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset as a ushort with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUShort(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset as a ushort with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt24(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 3 bytes from a specific offset as a UInt24 with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt24(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 3 bytes from a specific offset as a UInt24 with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadInt(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an int with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as a uint with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as a uint with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt48(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a UInt48 with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt48(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a UInt48 with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadLong(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 8 bytes from a specific offset as a long with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadULong(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 8 bytes from a specific offset as a ulong with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt128(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 16 bytes from a specific offset as a UInt128 with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUnsignedBigInteger(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads a given amount of bytes from a specific offset as an unsigned BigInteger with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="length">The number of bytes to read.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadMacAddress(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a MacAddress with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadMacAddress(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a MacAddress with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4Address(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 address with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4Address(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 address with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4TimeOfDay(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 time of day with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4TimeOfDay(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 time of day with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV6Address(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 16 bytes from a specific offset as an IPv6 address with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.Byte)">
            <summary>
            Writes the given value to the buffer.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Writes the given value to the buffer and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Writes the given value to the buffer and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.Int16,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.UInt16,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.UInt16,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Base.UInt24,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Base.UInt24,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.UInt32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.UInt32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Base.UInt48,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Base.UInt48,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.Int64,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.UInt64,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Base.UInt128,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.WriteUnsigned(System.Byte[],System.Int32,System.Numerics.BigInteger,System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given amount of least significant bytes of the value to the buffer using the given endianity.
            Doesn't write leading zero bytes.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="length">The maximum amount of bytes to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.String,System.Text.Encoding)">
            <summary>
            Writes a string to a byte array in a specific offset using the given encoding.
            Increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the string in.</param>
            <param name="offset">The offset in the buffer to start writing the string in. Incremented by the number of bytes written.</param>
            <param name="value">The string to write in the buffer.</param>
            <param name="encoding">The encoding to use to translate the string into a sequence of bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.DataSegment)">
            <summary>
            Writes the given value to the buffer.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.DataSegment)">
            <summary>
            Writes the given value to the buffer and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.IpV6.IpV6Address,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.WriteCarriageReturnLinefeed(System.Byte[],System.Int32@)">
            <summary>
            Writes the endline bytes (CRLF) in the buffer in the given offset.
            Increments the offset by the number of bytes written (2).
            </summary>
            <param name="buffer">The buffer to write the CRLF in.</param>
            <param name="offset">The offset to start writing the CRLF in. Incremented by the number of bytes written (2).</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.WriteDecimal(System.Byte[],System.Int32@,System.UInt32)">
            <summary>
            Writes an integer as a decimal string in ASCII encoding to a buffer of bytes in a specific offset.
            The offset is incremented by the number of bytes (digits) written.
            </summary>
            <param name="buffer">The buffer to write the integer in.</param>
            <param name="offset">The offset in the buffer to start writing the integer. Incremented by the number of bytes (digits) written.</param>
            <param name="value">The integer value to write in the buffer.</param>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4TimeOfDay">
            <summary>
            Represents the time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.#ctor(System.UInt32)">
            <summary>
            Create the time from milliseconds since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.#ctor(System.TimeSpan)">
            <summary>
            Create the time from TimeSpan since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.Equals(PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Two times are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.Equals(System.Object)">
            <summary>
            Two times are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.op_Equality(PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Two times are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.op_Inequality(PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Two times are different if the have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.GetHashCode">
            <summary>
            The hash code of a time is the hash code of the milliseconds since midnight UT value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.MillisecondsSinceMidnightUniversalTime">
            <summary>
            Number of milliseconds passed since midnight UT.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.TimeSinceMidnightUniversalTime">
            <summary>
            Time passed since midnight UT.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel">
            <summary>
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            The bit string values in this table were chosen to achieve a minimum Hamming distance of four (4) between any two valid values.  
            This specific assignment of classification level names to values has been defined for compatibility 
            with security devices which have already been developed and deployed.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.None">
            <summary>
            An invalid value for a classification level.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.TopSecret">
            <summary>
            Top Secret
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.Secret">
            <summary>
            Secret
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.Confidential">
            <summary>
            Confidential
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.Unclassified">
            <summary>
            Unclassified
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity">
             <summary>
             This option identifies the U.S. classification level at which the datagram is to be protected 
             and the authorities whose protection rules apply to each datagram.
             
             <para>
               This option is used by end systems and intermediate systems of an internet to:
               <list type="number">
                 <item>Transmit from source to destination in a network standard representation the common security labels required by computer security models.</item>
                 <item>Validate the datagram as appropriate for transmission from the source and delivery to the destination.</item>
                 <item>
                   Ensure that the route taken by the datagram is protected to the level required by all protection authorities indicated on the datagram.
                   In order to provide this facility in a general Internet environment, interior and exterior gateway protocols must be augmented 
                   to include security label information in support of routing control.
                 </item>
               </list>
             </para>
            
             <para>
               The DoD Basic Security option must be copied on fragmentation.  
               This option appears at most once in a datagram.  
               Some security systems require this to be the first option if more than one option is carried in the IP header, 
               but this is not a generic requirement levied by this specification.
             </para>
             
             <para>
               The format of the DoD Basic Security option is as follows:
               <pre>
             +------------+------------+------------+-------------//----------+
             |  10000010  |  XXXXXXXX  |  SSSSSSSS  |  AAAAAAA[1]    AAAAAAA0 |
             |            |            |            |         [0]             |
             +------------+------------+------------+-------------//----------+
               TYPE = 130     LENGTH   CLASSIFICATION         PROTECTION
                                            LEVEL              AUTHORITY
                                                                 FLAGS
               </pre>
             </para>
             </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel,PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities,System.Byte)">
            <summary>
            Create the security option from the different security field values.
            </summary>
            <param name="classificationLevel">
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            </param>
            <param name="protectionAuthorities">
            This field identifies the National Access Programs or Special Access Programs 
            which specify protection rules for transmission and processing of the information contained in the datagram. 
            </param>
            <param name="length">
            The number of bytes this option will take.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel)">
            <summary>
            Create the security option with only classification level.
            </summary>
            <param name="classificationLevel">
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.#ctor">
            <summary>
            Creates unclassified security option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.Equals(PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity)">
            <summary>
            Two security options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two security options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code 
            with the hash code of the combination of the classification level, protection authority and length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.ClassificationLevel">
            <summary>
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.ProtectionAuthorities">
            <summary>
            This field identifies the National Access Programs or Special Access Programs 
            which specify protection rules for transmission and processing of the information contained in the datagram. 
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer.Pointer">
            <summary>
            The pointer identifies the octet of the original datagram's header where the error was detected (it may be in the middle of an option).  
            For example, 1 indicates something is wrong with the Type of Service, and (if there are options present) 20 indicates something is wrong with the type code of the first option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeTimeExceeded">
            <summary>
            The different ICMP code values for Time Exceeded ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTimeExceeded.TimeToLive">
            <summary>
            RFC 792.
            If the gateway processing a datagram finds the time to live field is zero it must discard the datagram.  
            The gateway may also notify the source host via the time exceeded message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTimeExceeded.FragmentReassembly">
            <summary>
            RFC 792.
            If a host reassembling a fragmented datagram cannot complete the reassembly due to missing fragments within its time limit it discards the datagram, 
            and it may send a time exceeded message.
            If fragment zero is not available then no time exceeded need be sent at all.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreLayer">
            <summary>
            Represents a GRE layer.
            <seealso cref="T:PcapDotNet.Packets.Gre.GreDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetBaseLayer">
            <summary>
            A base class for Ethernet like layers.
            Contains an Ethernet type that can be calculated according to the previous layer 
            and defines that if the next layer is an ARP layer, the hardware type should be Ethernet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetBaseLayer.#ctor">
            <summary>
            Creates an instance with zero values.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseLayer.EtherType">
            <summary>
            Ethernet type (next protocol).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetBaseLayer.PreviousLayerHardwareType">
            <summary>
            The ARP Hardware Type of the layer before the ARP layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.SetKey(System.UInt16,System.UInt16)">
            <summary>
            Sets the key according to the payload length and call id.
            </summary>
            <param name="keyPayloadLength">(High 2 octets of Key) Size of the payload, not including the GRE header.</param>
            <param name="keyCallId">(Low 2 octets of Key) Contains the Peer's Call ID for the session to which this packet belongs.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Equals(PcapDotNet.Packets.Gre.GreLayer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Version">
            <summary>
            The GRE Version Number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.ProtocolType">
            <summary>
            The Protocol Type field contains the protocol type of the payload packet. 
            These Protocol Types are defined in [RFC1700] as "ETHER TYPES" and in [ETYPES]. 
            An implementation receiving a packet containing a Protocol Type which is not listed in [RFC1700] or [ETYPES] SHOULD discard the packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.RecursionControl">
            <summary>
            Recursion control contains a three bit unsigned integer which contains the number of additional encapsulations which are permissible.  
            This SHOULD default to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.FutureUseBits">
            <summary>
            Must be set to zero (0).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.ChecksumPresent">
            <summary>
            If the Checksum Present bit is set to 1, then the Checksum field is present and contains valid information.
            If either the Checksum Present bit or the Routing Present bit are set, BOTH the Checksum and Offset fields are present in the GRE packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Checksum">
            <summary>
            The Checksum field contains the IP (one's complement) checksum sum of the all the 16 bit words in the GRE header and the payload packet.
            For purposes of computing the checksum, the value of the checksum field is zero. 
            This field is present only if the Checksum Present bit is set to one.
            In order to calculate the Checksum automatically, leave null in this field and set the ChecksumPresent field to true.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Key">
            <summary>
            The Key field contains a four octet number which was inserted by the encapsulator.  
            It may be used by the receiver to authenticate the source of the packet.  
            The Key field is only present if the Key Present field is set to 1.
            null iff the Key isn't present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.KeyPayloadLength">
            <summary>
            (High 2 octets of Key) Size of the payload, not including the GRE header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.KeyCallId">
            <summary>
            (Low 2 octets of Key) Contains the Peer's Call ID for the session to which this packet belongs.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.SequenceNumber">
            <summary>
            The Sequence Number field contains an unsigned 32 bit integer which is inserted by the encapsulator.  
            It may be used by the receiver to establish the order in which packets have been transmitted from the encapsulator to the receiver.  
            null off the sequence number present bit is 0.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.AcknowledgmentSequenceNumber">
            <summary>
            Contains the sequence number of the highest numbered GRE packet received by the sending peer for this user session.
            Present if A bit (Bit 8) is one (1).
            null iff not present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.RoutingOffset">
            <summary>
            The offset field indicates the octet offset from the start of the Routing field to the first octet of the active Source Route Entry to be examined.  
            This field is present if the Routing Present or the Checksum Present bit is set to 1, and contains valid information only if the Routing Present bit is set to 1.
            Should be null iff the Routing is null (routing is not present).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Routing">
            <summary>
            The Routing field is optional and is present only if the Routing Present bit is set to 1.
            The Routing field is a list of Source Route Entries (SREs). 
            null iff the routing isn't present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.StrictSourceRoute">
            <summary>
            If the source route is incomplete, then the Strict Source Route bit is checked.  
            If the source route is a strict source route and the next IP destination or autonomous system is NOT an adjacent system, the packet MUST be dropped.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            This is GRE.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding">
            <summary>
            Eastlake.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1SnmpBasicEncodingRules">
            <summary>
            The SNMP subset of ASN.1.
            Basic Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1SnmpDistinguishedEncodingRules">
            <summary>
            The SNMP subset of ASN.1.
            Distinguished Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1SnmpPer">
            <summary>
            The SNMP subset of ASN.1.
            Packed Encoding Rules Aligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1SnmpPerUnaligned">
            <summary>
            The SNMP subset of ASN.1.
            Packed Encoding Rules Unaligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1SnmpCanonicalEncodingRules">
            <summary>
            The SNMP subset of ASN.1.
            Canonical Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1SnmpPrivate">
            <summary>
            The SNMP subset of ASN.1.
            An OID preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private encoding.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1990BasicEncodingRules">
            <summary>
            OSI ASN.1 1990 [ASN.1].
            Basic Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1990DistinguishedEncodingRules">
            <summary>
            OSI ASN.1 1990 [ASN.1].
            Distinguished Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1990Per">
            <summary>
            OSI ASN.1 1990 [ASN.1].
            Packed Encoding Rules Aligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1990PerUnaligned">
            <summary>
            OSI ASN.1 1990 [ASN.1].
            Packed Encoding Rules Unaligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1990CanonicalEncodingRules">
            <summary>
            OSI ASN.1 1990 [ASN.1].
            Canonical Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1990Private">
            <summary>
            OSI ASN.1 1990 [ASN.1].
            An OID preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private encoding.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1994BasicEncodingRules">
            <summary>
            OSI ASN.1 1994.
            Basic Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1994DistinguishedEncodingRules">
            <summary>
            OSI ASN.1 1994.
            Distinguished Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1994Per">
            <summary>
            OSI ASN.1 1994.
            Packed Encoding Rules Aligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1994PerUnaligned">
            <summary>
            OSI ASN.1 1994.
            Packed Encoding Rules Unaligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1994CanonicalEncodingRules">
            <summary>
            OSI ASN.1 1994.
            Canonical Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Asn1Osi1994Private">
            <summary>
            OSI ASN.1 1994.
            An OID preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private encoding.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.AsnPrivateBasicEncodingRules">
            <summary>
            Private abstract syntax notations.
            This coding value will not be assigned to a standard abstract syntax notation.
            An OSI Object Identifier (OID) preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private abstract syntax is being used.
            Basic Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.AsnPrivateDistinguishedEncodingRules">
            <summary>
            Private abstract syntax notations.
            This coding value will not be assigned to a standard abstract syntax notation.
            An OSI Object Identifier (OID) preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private abstract syntax is being used.
            Distinguished Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.AsnPrivatePer">
            <summary>
            Private abstract syntax notations.
            This coding value will not be assigned to a standard abstract syntax notation.
            An OSI Object Identifier (OID) preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private abstract syntax is being used.
            Packed Encoding Rules Aligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.AsnPrivatePerUnaligned">
            <summary>
            Private abstract syntax notations.
            This coding value will not be assigned to a standard abstract syntax notation.
            An OSI Object Identifier (OID) preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private abstract syntax is being used.
            Packed Encoding Rules Unaligned.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.AsnPrivateCanonicalEncodingRules">
            <summary>
            Private abstract syntax notations.
            This coding value will not be assigned to a standard abstract syntax notation.
            An OSI Object Identifier (OID) preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private abstract syntax is being used.
            Canonical Encoding Rules.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.AsnPrivatePrivate">
            <summary>
            Private abstract syntax notations.
            This coding value will not be assigned to a standard abstract syntax notation.
            An OSI Object Identifier (OID) preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private abstract syntax is being used.
            An OID preceded by a one byte unsigned length appears in the data area just after the coding OID.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Mime7Bit">
            <summary>
            MIME structured data [RFC 2045, 2046].
            The data portion is a MIME structured message.
            The "MIME-Version:" header line may be omitted unless the version is other than "1.0".
            Note that, to some extent, the size limitations of DNS RRs may be overcome in the MIME case by using the "Content-Type: message/external-body" mechanism.
            7 bit.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.Mime8Bit">
            <summary>
            MIME structured data [RFC 2045, 2046].
            The data portion is a MIME structured message.
            The "MIME-Version:" header line may be omitted unless the version is other than "1.0".
            Note that, to some extent, the size limitations of DNS RRs may be overcome in the MIME case by using the "Content-Type: message/external-body" mechanism.
            8 bit.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.MimeBinary">
            <summary>
            MIME structured data [RFC 2045, 2046].
            The data portion is a MIME structured message.
            The "MIME-Version:" header line may be omitted unless the version is other than "1.0".
            Note that, to some extent, the size limitations of DNS RRs may be overcome in the MIME case by using the "Content-Type: message/external-body" mechanism.
            Binary.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.MimeQuotedPrintable">
            <summary>
            MIME structured data [RFC 2045, 2046].
            The data portion is a MIME structured message.
            The "MIME-Version:" header line may be omitted unless the version is other than "1.0".
            Note that, to some extent, the size limitations of DNS RRs may be overcome in the MIME case by using the "Content-Type: message/external-body" mechanism.
            Quoted-printable.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.MimeBase64">
            <summary>
            MIME structured data [RFC 2045, 2046].
            The data portion is a MIME structured message.
            The "MIME-Version:" header line may be omitted unless the version is other than "1.0".
            Note that, to some extent, the size limitations of DNS RRs may be overcome in the MIME case by using the "Content-Type: message/external-body" mechanism.
            Base 64.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.MimePrivate">
            <summary>
            MIME structured data [RFC 2045, 2046].
            The data portion is a MIME structured message.
            The "MIME-Version:" header line may be omitted unless the version is other than "1.0".
            Note that, to some extent, the size limitations of DNS RRs may be overcome in the MIME case by using the "Content-Type: message/external-body" mechanism.
            The data portion must start with an "x-" token denoting the private content-transfer-encoding immediately followed by one null (zero) octet 
            followed by the remainder of the MIME object.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.TextTaggedDataAscii">
            <summary>
            Text tagged data.
            The data potion consists of text formated as specified in the TXT RR except that the first and every subsequent odd numbered text item 
            is considered to be a tag labeling the immediately following text item.
            If there are an odd number of text items overall, then the last is considered to label a null text item.
            Syntax of the tags is as specified in RFC 1738 for the "Common Internet Scheme Syntax" without the two leading slashes ("//").
            Thus any organization with a domain name can assign tags without fear of conflict.
            ASCII.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.TextTaggedDataUtf7">
            <summary>
            Text tagged data.
            The data potion consists of text formated as specified in the TXT RR except that the first and every subsequent odd numbered text item 
            is considered to be a tag labeling the immediately following text item.
            If there are an odd number of text items overall, then the last is considered to label a null text item.
            Syntax of the tags is as specified in RFC 1738 for the "Common Internet Scheme Syntax" without the two leading slashes ("//").
            Thus any organization with a domain name can assign tags without fear of conflict.
            UTF-7 [RFC 1642].
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.TextTaggedDataUtf8">
            <summary>
            Text tagged data.
            The data potion consists of text formated as specified in the TXT RR except that the first and every subsequent odd numbered text item 
            is considered to be a tag labeling the immediately following text item.
            If there are an odd number of text items overall, then the last is considered to label a null text item.
            Syntax of the tags is as specified in RFC 1738 for the "Common Internet Scheme Syntax" without the two leading slashes ("//").
            Thus any organization with a domain name can assign tags without fear of conflict.
            UTF-8 [RFC 2044].
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.TextTaggedDataAsciiMimeHeaderEscapes">
            <summary>
            Text tagged data.
            The data potion consists of text formated as specified in the TXT RR except that the first and every subsequent odd numbered text item 
            is considered to be a tag labeling the immediately following text item.
            If there are an odd number of text items overall, then the last is considered to label a null text item.
            Syntax of the tags is as specified in RFC 1738 for the "Common Internet Scheme Syntax" without the two leading slashes ("//").
            Thus any organization with a domain name can assign tags without fear of conflict.
            ASCII with MIME header escapes [RFC 2047].
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding.TextTaggedDataPrivate">
            <summary>
            Text tagged data.
            The data potion consists of text formated as specified in the TXT RR except that the first and every subsequent odd numbered text item 
            is considered to be a tag labeling the immediately following text item.
            If there are an odd number of text items overall, then the last is considered to label a null text item.
            Syntax of the tags is as specified in RFC 1738 for the "Common Internet Scheme Syntax" without the two leading slashes ("//").
            Thus any organization with a domain name can assign tags without fear of conflict.
            Each text item must start with a domain name [RFC 1034] denoting the private text encoding immediately followed by one null (zero) octet
            followed by the remainder of the text item.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataOptions">
            <summary>
            RFC 2671.
            <pre>
            0 Or more of:
            +-----+---------------+
            | bit | 0-15          |
            +-----+---------------+
            | 0   | OPTION-CODE   |
            +-----+---------------+
            | 16  | OPTION-LENGTH |
            +-----+---------------+
            | 32  | OPTION-DATA   |
            | ... |               |
            +-----+---------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataOptions.#ctor(PcapDotNet.Packets.Dns.DnsOptions)">
            <summary>
            Constructs an instance from options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataOptions.Equals(PcapDotNet.Packets.Dns.DnsResourceDataOptions)">
            <summary>
            Two DnsResourceDataOptions are equal if the options are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataOptions.Equals(System.Object)">
            <summary>
            Two DnsResourceDataOptions are equal if the options are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataOptions.GetHashCode">
            <summary>
            The hash code of the options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataOptions.Options">
            <summary>
            The list of options.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataDomainName">
            <summary>
            Contains a single DNS domain name.
            <pre>
            +------+
            | NAME |
            +------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDomainName.#ctor(PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs an instance from the domain name data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDomainName.Equals(PcapDotNet.Packets.Dns.DnsResourceDataDomainName)">
            <summary>
            Two DnsResourceDataDomainName are equal iff their domain name values are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDomainName.Equals(System.Object)">
            <summary>
            Two DnsResourceDataDomainName are equal iff their domain name values are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDomainName.GetHashCode">
            <summary>
            The hash code of the domain name value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDomainName.Data">
            <summary>
            The domain name value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery">
            <summary>
            http://files.dns-sd.org/draft-sekar-dns-llq.txt.
            <pre>
            +-----+------------+
            | bit | 0-15       |
            +-----+------------+
            | 0   | VERSION    |
            +-----+------------+
            | 16  | LLQ-OPCODE |
            +-----+------------+
            | 32  | ERROR-CODE |
            +-----+------------+
            | 48  | LLQ-ID     |
            |     |            |
            |     |            |
            |     |            |
            +-----+------------+
            | 112 | LEASE-LIFE |
            |     |            |
            +-----+------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery.#ctor(System.UInt16,PcapDotNet.Packets.Dns.DnsLongLivedQueryOpCode,PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode,System.UInt64,System.UInt32)">
            <summary>
            Constructs an instance out of the version, opcode, error code, id and lease life fields.
            </summary>
            <param name="version">Version of LLQ protocol implemented.</param>
            <param name="opCode">Identifies LLQ operation.</param>
            <param name="errorCode">Identifies LLQ errors.</param>
            <param name="id">Identifier for an LLQ.</param>
            <param name="leaseLife">Requested or granted life of LLQ, in seconds.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery.Version">
            <summary>
            Version of LLQ protocol implemented.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery.OpCode">
            <summary>
            Identifies LLQ operation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery.ErrorCode">
            <summary>
            Identifies LLQ errors.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery.Id">
            <summary>
            Identifier for an LLQ.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery.LeaseLife">
            <summary>
            Requested or granted life of LLQ, in seconds.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionLongLivedQuery.DataLength">
            <summary>
            The number of bytes the option data takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsKeyNameType">
            <summary>
            RFC 2535.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyNameType.UserOrAccountAtEndEntity">
            <summary>
            Indicates that this is a key associated with a "user" or "account" at an end entity, usually a host.
            The coding of the owner name is that used for the responsible individual mailbox in the SOA and RP RRs:
            The owner name is the user name as the name of a node under the entity name.
            For example, "j_random_user" on host.subdomain.example could have a public key associated through a KEY RR with name j_random_user.host.subdomain.example.
            It could be used in a security protocol where authentication of a user was desired.
            This key might be useful in IP or other security for a user level service such a telnet, ftp, rlogin, etc.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyNameType.ZoneKey">
            <summary>
            Indicates that this is a zone key for the zone whose name is the KEY RR owner name.
            This is the public key used for the primary DNS security feature of data origin authentication.
            Zone KEY RRs occur only at delegation points.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsKeyNameType.NonZoneEntity">
            <summary>
            Indicates that this is a key associated with the non-zone "entity" whose name is the RR owner name.
            This will commonly be a host but could, in some parts of the DNS tree, be some other type of entity such as a telephone number [RFC 1530] or numeric IP address.
            This is the public key used in connection with DNS request and transaction authentication services.
            It could also be used in an IP-security protocol where authentication at the host, rather than user, level was desired, such as routing, NTP, etc.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsGatewayType">
            <summary>
            Indicates the format of the information that is stored in the gateway field.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsGatewayType.None">
            <summary>
            No gateway is present.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsGatewayType.IpV4">
            <summary>
            A 4-byte IPv4 address is present.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsGatewayType.IpV6">
            <summary>
            A 16-byte IPv6 address is present.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsGatewayType.DomainName">
            <summary>
            A wire-encoded domain name is present.
            The wire-encoded format is self-describing, so the length is implicit.
            The domain name must not be compressed.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsAtmAddressFormat">
            <summary>
            The ATM address format values.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAtmAddressFormat.AtmEndSystemAddress">
            <summary>
            ATM  End  System Address (AESA) format.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAtmAddressFormat.E164">
            <summary>
            E.164 format.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpDatagram">
            <summary>
            The following is the packet structure used for ARP requests and replies. 
            On Ethernet networks, these packets use an EtherType of 0x0806, and are sent to the broadcast MAC address of FF:FF:FF:FF:FF:FF. 
            Note that the EtherType (0x0806) is used in the Ethernet header, and should not be used as the PTYPE of the ARP packet. 
            The ARP type (0x0806) should never be used in the PTYPE field of an ARP packet, since a hardware protocol address should never be linked to the ARP protocol. 
            Note that the packet structure shown in the table has SHA and THA as 48-bit fields and SPA and TPA as 32-bit fields but this is just for convenience  
            their actual lengths are determined by the hardware &amp; protocol length fields.
            <pre>
            +-----+------------------------+------------------------+-----------------------------------------------+
            | bit | 0-7                    | 8-15                   | 16-31                                         |
            +-----+------------------------+------------------------+-----------------------------------------------+
            | 0   |	Hardware type (HTYPE)                           | Protocol type (PTYPE)                         |
            +-----+------------------------+------------------------+-----------------------------------------------+
            | 32  | Hardware length (HLEN) | Protocol length (PLEN) | Operation (OPER)                              |
            +-----+------------------------+------------------------+-----------------------------------------------+
            | 64  | Sender hardware address (SHA) (first 32 bits)                                                   |
            +-----+-------------------------------------------------+-----------------------------------------------+
            | 96  | Sender hardware address (SHA) (last 16 bits)    | Sender protocol address (SPA) (first 16 bits) |
            +-----+-------------------------------------------------+-----------------------------------------------+
            | 128 | Sender protocol address (SPA) (last 16 bits)    | Target hardware address (THA) (first 16 bits) |
            +-----+-------------------------------------------------+-----------------------------------------------+
            | 160 |	Target hardware address (THA) (last 32 bits)                                                    |
            +-----+-------------------------------------------------------------------------------------------------+
            | 192 | Target protocol address (TPA)                                                                   |
            +-----+-------------------------------------------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpDatagram.HeaderBaseLength">
            <summary>
            The number of bytes in the ARP header without the addresses (that vary in size).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpDatagram.CalculateIsValid">
            <summary>
            The datagram is valid if the length is correct according to the header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.HeaderLength">
            <summary>
            The number of bytes in the ARP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.HardwareType">
            <summary>
            Each data link layer protocol is assigned a number used in this field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.ProtocolType">
            <summary>
            Each protocol is assigned a number used in this field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.HardwareLength">
            <summary>
            Length in bytes of a hardware address. Ethernet addresses are 6 bytes long.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.ProtocolLength">
            <summary>
            Length in bytes of a logical address. IPv4 address are 4 bytes long.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.Operation">
            <summary>
            Specifies the operation the sender is performing.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.SenderHardwareAddress">
            <summary>
            Hardware address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.SenderProtocolAddress">
            <summary>
            Protocol address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.SenderProtocolIpV4Address">
            <summary>
            Protocol IPv4 address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.TargetHardwareAddress">
            <summary>
            Hardware address of the intended receiver. 
            This field is ignored in requests.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.TargetProtocolAddress">
            <summary>
            Protocol address of the intended receiver.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.TargetProtocolIpV4Address">
            <summary>
            Protocol IPv4 address of the intended receiver.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.PacketBuilder">
             <summary>
             This class is used to build different packets.
             Packets are built from layers.
             This class can be used using static Build methods by giving the Packet's timestamp and layers.
             This class can be instantiated with different layers and then use the Build method by only giving the Packet's timestamp.
             If a layer that an instance of this class holds is modified, the PacketBuilder instance will create different packets.
             <example>This sample shows how to create ICMP Echo Request packets to different servers with different IP ID and ICMP sequence numbers and identifiers.
             <code>
               EthernetLayer ethernetLayer = new EthernetLayer
                                                 {
                                                     Source = new MacAddress("00:01:02:03:04:05"),
                                                     Destination = new MacAddress("A0:A1:A2:A3:A4:A5")
                                                 };
            
               IpV4Layer ipV4Layer = new IpV4Layer
                                         {
                                             Source = new IpV4Address("1.2.3.4"),
                                             Ttl = 128,
                                         };
            
               IcmpEchoLayer icmpLayer = new IcmpEchoLayer();
            
               PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV4Layer, icmpLayer);
            
               List&lt;Packet&gt; packets = new List&lt;Packet&gt;();
            
               for (int i = 0; i != 100; ++i)
               {
                   ipV4Layer.Destination = new IpV4Address("2.3.4." + i);
                   ipV4Layer.Identification = (ushort)i;
                   icmpLayer.SequenceNumber = (ushort)i;
                   icmpLayer.Identifier = (ushort)i;
            
                   packets.Add(builder.Build(DateTime.Now));
               }
             </code>
             </example>
             </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.Build(System.DateTime,PcapDotNet.Packets.ILayer[])">
            <summary>
            Builds a single packet using the given layers with the given timestamp.
            </summary>
            <param name="timestamp">The packet's timestamp.</param>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
            <returns>A packet built from the given layers with the given timestamp.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.Build(System.DateTime,System.Collections.Generic.IEnumerable{PcapDotNet.Packets.ILayer})">
            <summary>
            Builds a single packet using the given layers with the given timestamp.
            </summary>
            <param name="timestamp">The packet's timestamp.</param>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
            <returns>A packet built from the given layers with the given timestamp.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.#ctor(PcapDotNet.Packets.ILayer[])">
            <summary>
            Creates a PacketBuilder that can build packets according to the given layers and with different timestamps.
            The layers' properties can be modified after the builder is built and this will affect the packets built.
            </summary>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.#ctor(System.Collections.Generic.IEnumerable{PcapDotNet.Packets.ILayer})">
            <summary>
            Creates a PacketBuilder that can build packets according to the given layers and with different timestamps.
            The layers' properties can be modified after the builder is built and this will affect the packets built.
            </summary>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.Build(System.DateTime)">
            <summary>
            Builds a single packet using the builder's layers with the given timestamp.
            </summary>
            <param name="timestamp">The packet's timestamp.</param>
            <returns>A packet built from the builder's layers with the given timestamp.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting">
            <summary>
            Loose Source and Record Route
            <pre>
            +--------+--------+--------+---------//--------+
            |10000011| length | pointer|     route data    |
            +--------+--------+--------+---------//--------+
             Type=131
            </pre>
            
            <para>
              The loose source and record route (LSRR) option provides a means for the source of an internet datagram 
              to supply routing information to be used by the gateways in forwarding the datagram to the destination, 
              and to record the route information.
            </para>
            
            <para>
              The option begins with the option type code.  
              The second octet is the option length which includes the option type code and the length octet, 
              the pointer octet, and length-3 octets of route data.  
              The third octet is the pointer into the route data indicating the octet which begins the next source address to be processed.  
              The pointer is relative to this option, and the smallest legal value for the pointer is 4.
            </para>
            
            <para>
              A route data is composed of a series of internet addresses.
              Each internet address is 32 bits or 4 octets.  
              If the pointer is greater than the length, the source route is empty (and the recorded route full) 
              and the routing is to be based on the destination address field.
              If the address in destination address field has been reached and the pointer is not greater than the length, 
              the next address in the source route replaces the address in the destination address field, 
              and the recorded route address replaces the source address just used, and pointer is increased by four.
            </para>
            
            <para>
              The recorded route address is the internet module's own internet address 
              as known in the environment into which this datagram is being forwarded.
            </para>
            
            <para>
              This procedure of replacing the source route with the recorded route 
              (though it is in the reverse of the order it must be in to be used as a source route) means the option (and the IP header as a whole) 
              remains a constant length as the datagram progresses through the internet.
            </para>
            
            <para>
              This option is a loose source route because the gateway or host IP 
              is allowed to use any route of any number of other intermediate gateways to reach the next address in the route.
            </para>
            
            <para>
              Must be copied on fragmentation.  
              Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionRoute">
            <summary>
            The base class for route tracking options (loose, strict, record).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRoute.OptionMinimumLength">
            <summary>
            The minimum option length in bytes (type, length, pointer).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRoute.OptionValueMinimumLength">
            <summary>
            The minimum option value length in bytes (pointer).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRoute.PointedAddressIndexMaxValue">
            <summary>
            The maximum value for the index pointed the route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Equals(PcapDotNet.Packets.IpV4.IpV4OptionRoute)">
            <summary>
            Two routes options are equal iff they have the same type, same pointed address index and same route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two routes options are equal iff they have the same type, same pointed address index and same route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.GetHashCode">
            <summary>
            The hash code of the route option is the xor of the following hash codes: base class, pointed address index and all the addresses in the route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.TryRead(PcapDotNet.Packets.IpV4.IpV4Address[]@,System.Byte@,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the value of the route option from the given buffer.
            </summary>
            <param name="addresses">The route read from the buffer.</param>
            <param name="pointedAddressIndex">The index pointed in the route read from the buffer.</param>
            <param name="buffer">The buffer to read the value from.</param>
            <param name="offset">The offset in the buffer to start reading the value from.</param>
            <param name="valueLength">The number of bytes that the value should be.</param>
            <returns>True iff the read was successful.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},System.Byte)">
            <summary>
            Construct a route option from the given values.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.PointedAddressIndex">
            <summary>
            The pointed index in the route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Route">
            <summary>
            The route tracked - the collection of addresses written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},System.Byte)">
            <summary>
            Constructs the option from the given values.
            </summary>
            <param name="route">The route addresses values.</param>
            <param name="pointedAddressIndex">The pointed index in the route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting.#ctor">
            <summary>
            Empty loose source routing.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampReplyDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Originate Timestamp           |
            +-----+-------------------------------+
            | 96  | Receive Timestamp             |
            +-----+-------------------------------+
            | 128 | Transmit Timestamp            |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | Internet Header         |
            |     | + 64 bits of            |
            |     | Original Data Datagram  |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationRequestLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpInformationRequestLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpFieldParameters">
            <summary>
            Represents a set of HTTP field parameters.
            Used for some of HTTP fields.
            All parameters must have different names.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.#ctor(System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            Creates the parameters from an array of parameters. Keys are the parameters names and values are the parameters values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Creates the parameters from an enumerable of parameters. Keys are the parameters names and values are the parameters values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.GetEnumerator">
            <summary>
            Enumerates over the parameters.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.Equals(PcapDotNet.Packets.Http.HttpFieldParameters)">
            <summary>
            Two HTTP field parameters are equal if all of their parameters are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.Equals(System.Object)">
            <summary>
            Two HTTP field parameters are equal if all of their parameters are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.GetHashCode">
            <summary>
            Xor of all of the hash codes of the parameters names and values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.ToString">
            <summary>
            Returns a string of parameters beginning and separated by semicolon and equal sign between keys and values.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpFieldParameters.Count">
            <summary>
            Number of parameters.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpFieldParameters.Item(System.String)">
            <summary>
            Returns the value of the given parameter name.
            </summary>
            <param name="name">The name of the parameter.</param>
            <returns>The value of the parameter.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.MacAddress">
            <summary>
            Ethernet MacAddress struct.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.MacAddress.SizeOf">
            <summary>
            The number of bytes the struct takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.#ctor(PcapDotNet.Base.UInt48)">
            <summary>
            Constructs the address from a 48 bit integer.
            </summary>
            <param name="value">The 48 bit integer to create the address from.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.#ctor(System.String)">
            <summary>
            Create the address from a string in the format XX:XX:XX:XX:XX:XX.
            </summary>
            <param name="address">The string value in hexadecimal format. Every two digits are separated by a colon.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.ToValue">
            <summary>
            Converts the address to a 48 bit integer.
            </summary>
            <returns>A 48 bit integer representing the address.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.Equals(PcapDotNet.Packets.Ethernet.MacAddress)">
            <summary>
            Two addresses are equal if they have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.Equals(System.Object)">
            <summary>
            Two addresses are equal if they have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.op_Equality(PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Ethernet.MacAddress)">
            <summary>
            Two addresses are equal if they have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.op_Inequality(PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Ethernet.MacAddress)">
            <summary>
            Two addresses are different if they have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.GetHashCode">
            <summary>
            The hash code of the address is the hash code of its 48 bit integer value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.ToString">
            <summary>
            Converts the address to a string in the format XX:XX:XX:XX:XX:XX.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.MacAddress.Zero">
            <summary>
            A MAC Address of all zeros (00:00:00:00:00:00).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetPayloadDatagrams.IpV4">
            <summary>
            The Ethernet payload as an IPv4 datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetPayloadDatagrams.Arp">
            <summary>
            The Ethernet payload as an ARP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetPayloadDatagrams.Payload">
            <summary>
            The Ethernet payload.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer">
            <summary>
            RFC 2163.
            <pre>
            +-----+------------+
            | bit | 0-15       |
            +-----+------------+
            | 0   | Preference |
            +-----+------------+
            | 16  | MAP822     |
            | ... |            |
            +-----+------------+
            |     | MAPX400    |
            | ... |            |
            +-----+------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer.#ctor(System.UInt16,PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs an instance out of the preference, map822 and mapX400 fields.
            </summary>
            <param name="preference">The preference given to this RR among others at the same owner. Lower values are preferred.</param>
            <param name="map822">RFC 822 domain. The RFC 822 part of the MCGAM.</param>
            <param name="mapX400">The value of x400-in-domain-syntax derived from the X.400 part of the MCGAM.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer.Equals(PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer)">
            <summary>
            Two DnsResourceDataX400Pointer are equal iff their preference, map822 and mapX400 fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer.Equals(System.Object)">
            <summary>
            Two DnsResourceDataX400Pointer are equal iff their preference, map822 and mapX400 fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer.GetHashCode">
            <summary>
            A hash code of the combination of the preference, map822 and mapX400 fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer.Preference">
            <summary>
            The preference given to this RR among others at the same owner.
            Lower values are preferred.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer.Map822">
            <summary>
            RFC 822 domain.
            The RFC 822 part of the MCGAM.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataX400Pointer.MapX400">
            <summary>
            The value of x400-in-domain-syntax derived from the X.400 part of the MCGAM.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataUri">
            <summary>
            Faltstrom.
            <pre>
            +-----+----------+--------+
            | bit | 0-15     | 16-31  |
            +-----+----------+--------+
            | 0   | Priority | Weight |
            +-----+----------+--------+
            | 32  | Target            |
            | ... |                   |
            +-----+-------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataUri.#ctor(System.UInt16,System.UInt16,System.Collections.Generic.IList{PcapDotNet.Packets.DataSegment})">
            <summary>
            Constructs an instance out of the priority, weight and target fields.
            </summary>
            <param name="priority">
            The priority of the target URI in this RR.
            A client must attempt to contact the URI with the lowest-numbered priority it can reach;
            URIs with the same priority should be tried in the order defined by the weight field.
            </param>
            <param name="weight">
            A server selection mechanism.
            The weight field specifies a relative weight for entries with the same priority.
            Larger weights should be given a proportionately higher probability of being selected.
            </param>
            <param name="target">The URI of the target. Resolution of the URI is according to the definitions for the Scheme of the URI.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataUri.Equals(PcapDotNet.Packets.Dns.DnsResourceDataUri)">
            <summary>
            Two DnsResourceDataUri are equal iff their priority, weight and target fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataUri.Equals(System.Object)">
            <summary>
            Two DnsResourceDataUri are equal iff their priority, weight and target fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataUri.GetHashCode">
            <summary>
            A hash code of the combination of the priority, weight and target fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataUri.Priority">
            <summary>
            The priority of the target URI in this RR.
            A client must attempt to contact the URI with the lowest-numbered priority it can reach;
            URIs with the same priority should be tried in the order defined by the weight field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataUri.Weight">
            <summary>
            A server selection mechanism.
            The weight field specifies a relative weight for entries with the same priority.
            Larger weights should be given a proportionately higher probability of being selected.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataUri.Target">
            <summary>
            The URI of the target.
            Resolution of the URI is according to the definitions for the Scheme of the URI.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation">
            <summary>
            RFC 1876.
            <pre>
            +-----+---------+------+-----------+----------+
            | bit | 0-7     | 8-15 | 16-23     | 24-31    |
            +-----+---------+------+-----------+----------+
            | 0   | VERSION | SIZE | HORIZ PRE | VERT PRE |
            +-----+---------+------+-----------+----------+
            | 32  | LATITUDE                              |
            +-----+---------------------------------------+
            | 64  | LONGITUDE                             |
            +-----+---------------------------------------+
            | 96  | ALTITUDE                              |
            +-----+---------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.MaxSizeValue">
            <summary>
            The maximum value for the size field.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Length">
            <summary>
            The number of bytes this resource data takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.#ctor(System.Byte,System.UInt64,System.UInt64,System.UInt64,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructs an instance from the version, size, horizontal precision, vertical precision, latitude, longitude and altitude fields.
            </summary>
            <param name="version">
            Version number of the representation.
            This must be zero.
            Implementations are required to check this field and make no assumptions about the format of unrecognized versions.
            </param>
            <param name="size">
            The diameter of a sphere enclosing the described entity, in centimeters.
            Only numbers of the form decimal digit times 10 in the power of a decimal digit are allowed since it is expressed as a pair of four-bit unsigned integers, 
            each ranging from zero to nine, with the most significant four bits representing the base and the second number representing the power of ten by which to multiply the base.
            This allows sizes from 0e0 (&lt;1cm) to 9e9(90,000km) to be expressed.
            This representation was chosen such that the hexadecimal representation can be read by eye; 0x15 = 1e5.
            Four-bit values greater than 9 are undefined, as are values with a base of zero and a non-zero exponent.
            
            Since 20000000m (represented by the value 0x29) is greater than the equatorial diameter of the WGS 84 ellipsoid (12756274m),
            it is therefore suitable for use as a "worldwide" size.
            </param>
            <param name="horizontalPrecision">
            The horizontal precision of the data, in centimeters, expressed using the same representation as Size.
            This is the diameter of the horizontal "circle of error", rather than a "plus or minus" value.
            (This was chosen to match the interpretation of Size; to get a "plus or minus" value, divide by 2.)
            </param>
            <param name="verticalPrecision">
            The vertical precision of the data, in centimeters, expressed using the sane representation as for Size.
            This is the total potential vertical error, rather than a "plus or minus" value.
            (This was chosen to match the interpretation of SIize; to get a "plus or minus" value, divide by 2.)
            Note that if altitude above or below sea level is used as an approximation for altitude relative to the ellipsoid, the precision value should be adjusted.
            </param>
            <param name="latitude">
            The latitude of the center of the sphere described by the Size field, expressed as a 32-bit integer,
            most significant octet first (network standard byte order), in thousandths of a second of arc.
            2^31 represents the equator; numbers above that are north latitude.
            </param>
            <param name="longitude">
            The longitude of the center of the sphere described by the Size field, expressed as a 32-bit integer,
            most significant octet first (network standard byte order), in thousandths of a second of arc, rounded away from the prime meridian.
            2^31 represents the prime meridian; numbers above that are east longitude.
            </param>
            <param name="altitude">
            The altitude of the center of the sphere described by the Size field, expressed as a 32-bit integer,
            most significant octet first (network standard byte order), in centimeters,
            from a base of 100,000m below the reference spheroid used by GPS (semimajor axis a=6378137.0, reciprocal flattening rf=298.257223563).
            Altitude above (or below) sea level may be used as an approximation of altitude relative to the the spheroid,
            though due to the Earth's surface not being a perfect spheroid, there will be differences.
            (For example, the geoid (which sea level approximates) for the continental US ranges from 10 meters to 50 meters below the spheroid.
            Adjustments to Altitude and/or VerticalPrecision will be necessary in most cases.
            The Defense Mapping Agency publishes geoid height values relative to the ellipsoid.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Equals(PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation)">
            <summary>
            Two DnsResourceDataLocationInformation are equal iff their version, size, horizontal precision, vertical precision, latitude, 
            longitude and altitude fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Equals(System.Object)">
            <summary>
            Two DnsResourceDataLocationInformation are equal iff their version, size, horizontal precision, vertical precision, latitude, 
            longitude and altitude fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.GetHashCode">
            <summary>
            A hash code based on the version, size, horizontal precision, vertical precision, latitude, longitude and altitude fields
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Version">
            <summary>
            Version number of the representation.
            This must be zero.
            Implementations are required to check this field and make no assumptions about the format of unrecognized versions.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Size">
            <summary>
            The diameter of a sphere enclosing the described entity, in centimeters.
            Only numbers of the form decimal digit times 10 in the power of a decimal digit are allowed since it is expressed as a pair of four-bit unsigned integers, 
            each ranging from zero to nine, with the most significant four bits representing the base and the second number representing the power of ten by which to multiply the base.
            This allows sizes from 0e0 (&lt;1cm) to 9e9(90,000km) to be expressed.
            This representation was chosen such that the hexadecimal representation can be read by eye; 0x15 = 1e5.
            Four-bit values greater than 9 are undefined, as are values with a base of zero and a non-zero exponent.
            
            Since 20000000m (represented by the value 0x29) is greater than the equatorial diameter of the WGS 84 ellipsoid (12756274m),
            it is therefore suitable for use as a "worldwide" size.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.HorizontalPrecision">
            <summary>
            The horizontal precision of the data, in centimeters, expressed using the same representation as Size.
            This is the diameter of the horizontal "circle of error", rather than a "plus or minus" value.
            (This was chosen to match the interpretation of Size; to get a "plus or minus" value, divide by 2.)
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.VerticalPrecision">
            <summary>
            The vertical precision of the data, in centimeters, expressed using the sane representation as for Size.
            This is the total potential vertical error, rather than a "plus or minus" value.
            (This was chosen to match the interpretation of SIize; to get a "plus or minus" value, divide by 2.)
            Note that if altitude above or below sea level is used as an approximation for altitude relative to the ellipsoid, the precision value should be adjusted.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Latitude">
            <summary>
            The latitude of the center of the sphere described by the Size field, expressed as a 32-bit integer,
            most significant octet first (network standard byte order), in thousandths of a second of arc.
            2^31 represents the equator; numbers above that are north latitude.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Longitude">
            <summary>
            The longitude of the center of the sphere described by the Size field, expressed as a 32-bit integer,
            most significant octet first (network standard byte order), in thousandths of a second of arc, rounded away from the prime meridian.
            2^31 represents the prime meridian; numbers above that are east longitude.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataLocationInformation.Altitude">
            <summary>
            The altitude of the center of the sphere described by the Size field, expressed as a 32-bit integer,
            most significant octet first (network standard byte order), in centimeters,
            from a base of 100,000m below the reference spheroid used by GPS (semimajor axis a=6378137.0, reciprocal flattening rf=298.257223563).
            Altitude above (or below) sea level may be used as an approximation of altitude relative to the the spheroid,
            though due to the Earth's surface not being a perfect spheroid, there will be differences.
            (For example, the geoid (which sea level approximates) for the continental US ranges from 10 meters to 50 meters below the spheroid.
            Adjustments to Altitude and/or VerticalPrecision will be necessary in most cases.
            The Defense Mapping Agency publishes geoid height values relative to the ellipsoid.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataIpV4">
            <summary>
            RFC 1035.
            <pre>
            +-----+------+
            | bit | 0-31 |
            +-----+------+
            | 0   | IP   |
            +-----+------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV4.#ctor(PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Constructs an IPv4 resource data from the given IP.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV4.Equals(PcapDotNet.Packets.Dns.DnsResourceDataIpV4)">
            <summary>
            Two IPv4 resource datas are equal if their IP is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV4.Equals(System.Object)">
            <summary>
            Two IPv4 resource datas are equal if their IP is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpV4.GetHashCode">
            <summary>
            Returns the hash code of the IPv4 value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIpV4.Data">
            <summary>
            The IPv4 value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptionAnything">
            <summary>
            An option that can hold any data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptionAnything.#ctor(PcapDotNet.Packets.Dns.DnsOptionCode,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs the option from a code and data.
            </summary>
            <param name="code">The option code.</param>
            <param name="data">The option data.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionAnything.Data">
            <summary>
            The option data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptionAnything.DataLength">
            <summary>
            The number of bytes the option data takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptFlags">
            <summary>
            RFCs 2671, 3225.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOptFlags.DnsSecOk">
            <summary>
            RFC 3225.
            Setting the this bit to one in a query indicates to the server that the resolver is able to accept DNSSEC security RRs.
            Cleareing (setting to zero) indicates that the resolver is unprepared to handle DNSSEC security RRs 
            and those RRs must not be returned in the response (unless DNSSEC security RRs are explicitly queried for).
            The bit of the query MUST be copied in the response.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.DataLink">
            <summary>
            Represents the DataLink type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IDataLink">
            <summary>
            Represents a datalink.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IDataLink.Kind">
            <summary>
            The kind of the datalink.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.#ctor(PcapDotNet.Packets.DataLinkKind)">
            <summary>
            Create the DataLink from a kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.Equals(PcapDotNet.Packets.DataLink)">
            <summary>
            Two DataLinks are equal if they are of the same kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.Equals(System.Object)">
            <summary>
            Two DataLinks are equal if they are of the same type and the same kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.op_Equality(PcapDotNet.Packets.DataLink,PcapDotNet.Packets.DataLink)">
            <summary>
            Two DataLinks are equal if they are of the same kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.op_Inequality(PcapDotNet.Packets.DataLink,PcapDotNet.Packets.DataLink)">
            <summary>
            Two DataLinks are different if they have different kinds.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.GetHashCode">
            <summary>
            The hash code of the datalink is the hash code of its kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.ToString">
            <summary>
            The string is the kind's string.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataLink.Ethernet">
            <summary>
            Etherent DataLink.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataLink.IpV4">
            <summary>
            IPv4 DataLink.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataLink.Kind">
            <summary>
            The kind of the DataLink.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.ClassOfService">
            <summary>
            IEEE P802.1p.
            Eight different classes of service are available as expressed through the 3-bit PCP field in an IEEE 802.1Q header added to the frame.
            The way traffic is treated when assigned to any particular class is undefined and left to the implementation.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.BestEffort">
            <summary>
            BE.
            Best Effort.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.Background">
            <summary>
            BK.
            Background.
            Lowest.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.ExcellentEffort">
            <summary>
            EE.
            Excellent Effort.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.CriticalApplications">
            <summary>
            CA.
            Critical Applications.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.Video">
            <summary>
            VI.
            Video
            Under 100 ms latency.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.Voice">
            <summary>
            VO.
            Voice.
            Under 10 ms latency.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.InternetworkControl">
            <summary>
            IC.
            Internetwork Control.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.ClassOfService.NetworkControl">
            <summary>
            NC.
            Network Control.
            Highest.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress">
            <summary>
            A pair of address and its time in the day.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.#ctor(PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Create a timed address accroding to the given values.
            </summary>
            <param name="address">The address in the pair.</param>
            <param name="timeOfDay">The time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.Equals(PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress)">
            <summary>
            Two options are equal if they have the same address and time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.Equals(System.Object)">
            <summary>
            Two options are equal if they have the same address and time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.op_Equality(PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress,PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress)">
            <summary>
            Two options are equal if they have the same address and time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.op_Inequality(PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress,PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress)">
            <summary>
            Two options are different if they have different addresses or time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.GetHashCode">
            <summary>
            Returns the xor of the address hash code and the time in the day hash code.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.Address">
            <summary>
            The address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.TimeOfDay">
            <summary>
            The time passed since midnight UT.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Layer">
            <summary>
            Represents IPv4 layer.
            <seealso cref="T:PcapDotNet.Packets.IpV4.IpV4Datagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.#ctor">
            <summary>
            Creates an IPv4 layer with all zero values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Equals(PcapDotNet.Packets.IpV4.IpV4Layer)">
            <summary>
            True iff the two IPv4 layers have the same TypeOfService, Identification, Fragmentation, Ttl, Protocol, HeaderChecksum, Source, Destination and Options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two IPv4 layers have the same TypeOfService, Identification, Fragmentation, Ttl, Protocol, HeaderChecksum, Source, Destination and Options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the TypeOfService and Identification combined and the hash codes of the layer length, data link, Fragmentation, Protocol, HeaderChecksum, Source, Destination, Options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.ToString">
            <summary>
            Contains the Source, Destination and Protocol.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.TypeOfService">
            <summary>
            Type of Service field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Identification">
            <summary>
            The value of the IPv4 ID field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Fragmentation">
            <summary>
            The fragmentation information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Ttl">
            <summary>
            The TTL field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Protocol">
            <summary>
            The IPv4 (next) protocol field.
            null means that this value should be calculated according to the next layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.HeaderChecksum">
            <summary>
            The header checksum value.
            null means that this value should be calculated to be correct according to the data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Source">
            <summary>
            The source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.CurrentDestination">
            <summary>
            The current destination address.
            This might not be the final destination when source routing options exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Destination">
            <summary>
            The final destination address.
            Takes into account the current destination and source routing options if they exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Options">
            <summary>
            The options field with all the parsed options if any exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.PreviousLayerEtherType">
            <summary>
            The Ethernet Type the Ethernet layer should write when this layer is the Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer (in this case: IP).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.PreviousLayerDefaultDestination">
            <summary>
            The default MAC Address value when this layer is the Ethernet payload.
            null means there is no default value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.DataLink">
            <summary>
            The kind of the data link of the layer.
            Can be null if this is not the first layer in the packet.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpMessageType">
            <summary>
            The type of the IGMP message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.None">
            <summary>
            Illegal type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.CreateGroupRequestVersion0">
            <summary>
            Create Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.CreateGroupReplyVersion0">
            <summary>
            Create Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.JoinGroupRequestVersion0">
            <summary>
            Join Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.JoinGroupReplyVersion0">
            <summary>
            Join Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.LeaveGroupRequestVersion0">
            <summary>
            Leave Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.LeaveGroupReplyVersion0">
            <summary>
            Leave Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.ConfirmGroupRequestVersion0">
            <summary>
            Confirm Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.ConfirmGroupReplyVersion0">
            <summary>
            Confirm Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipQuery">
            <summary>
            Membership Query (RFC3376).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipReportVersion3">
            <summary>
            Version 3 Membership Report (RFC3376).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipReportVersion1">
            <summary>
            Version 1 Membership Report (RFC1112).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipReportVersion2">
            <summary>
            Version 2 Membership Report (RFC2236).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.LeaveGroupVersion2">
            <summary>
            Version 2 Leave Group (RFC2236).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MulticastTraceRouteResponse">
            <summary>
            Multicast Traceroute Response.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MulticastTraceRoute">
            <summary>
            Multicast Traceroute.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpDatagram">
            <summary>
            RFC 1112.
            Version 1 (query or report):
            <pre>
            +-----+---------+------+--------+----------+
            | Bit | 0-3     | 4-7  | 8-15   | 16-31    |
            +-----+---------+------+--------+----------+
            | 0   | Version | Type | Unused | Checksum |
            +-----+---------+------+--------+----------+
            | 32  | Group Address                      |
            +-----+------------------------------------+
            </pre>
            
            RFC 2236.
            Version 2 (query, report or leave group):
            <pre>
            +-----+------+---------------+----------+
            | Bit | 0-7  | 8-15          | 16-31    |
            +-----+------+---------------+----------+
            | 0   | Type | Max Resp Time | Checksum |
            +-----+------+---------------+----------+
            | 32  | Group Address                   |
            +-----+---------------------------------+
            </pre>
            
            RFC 3376.
            Version 3 query:
            <pre>
            +-----+------+---+-----+---------------+-----------------------+
            | Bit | 0-3  | 4 | 5-7 | 8-15          | 16-31                 |
            +-----+------+---+-----+---------------+-----------------------+
            | 0   | Type = 0x11    | Max Resp Code | Checksum              |
            +-----+----------------+---------------+-----------------------+
            | 32  | Group Address                                          |
            +-----+------+---+-----+---------------+-----------------------+
            | 64  | Resv | S | QRV | QQIC          | Number of Sources (N) |
            +-----+------+---+-----+---------------+-----------------------+
            | 96  | Source Address [1]                                     |
            +-----+--------------------------------------------------------+
            | 128 | Source Address [2]                                     |
            +-----+--------------------------------------------------------+
            .     .                         .                              .
            .     .                         .                              .
            +-----+--------------------------------------------------------+
            | 64  | Source Address [N]                                     |
            | +   |                                                        |
            | 32N |                                                        |
            +-----+--------------------------------------------------------+
            </pre>
            
            RFC 3376.
            Version 3 report:
            <pre>
            +-----+-------------+----------+-----------------------------+
            | Bit | 0-7         | 8-15     | 16-31                       |
            +-----+-------------+----------+-----------------------------+
            | 0   | Type = 0x22 | Reserved | Checksum                    |
            +-----+-------------+----------+-----------------------------+
            | 32  | Reserved               | Number of Group Records (M) |
            +-----+------------------------+-----------------------------+
            | 64  | Group Record [1]                                     |
            .     .                                                      .
            .     .                                                      .
            .     .                                                      .
            |     |                                                      |
            +-----+------------------------------------------------------+
            |     | Group Record [2]                                     |
            .     .                                                      .
            .     .                                                      .
            .     .                                                      .
            |     |                                                      |
            +-----+------------------------------------------------------+
            |     |                         .                            |
            .     .                         .                            .
            |     |                         .                            |
            +-----+------------------------------------------------------+
            |     | Group Record [M]                                     |
            .     .                                                      .
            .     .                                                      .
            .     .                                                      .
            |     |                                                      |
            +-----+------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpDatagram.HeaderLength">
            <summary>
            The number of bytes the IGMP header takes for all messages but query version 3.
            All the bytes but the records of the report version 3.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryVersion3HeaderLength">
            <summary>
            The number of bytes the query version 3 IGMP message header takes.
            All the bytes but the source addresses.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxQueryRobustnessVariable">
            <summary>
            The maximum value for the query robustness varialbe.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpDatagram.CalculateIsValid">
            <summary>
            IGMP is valid if the checksum is correct, the length fits the message type and data and the MaxResponseCode is 0 in messages where it is not used.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpDatagram.CodeToValue(System.Byte)">
            <summary>
            Calculates the value from the given code as follows:
            <pre>
             0 1 2 3 4 5 6 7
            +-+-+-+-+-+-+-+-+
            |1| exp | mant  |
            +-+-+-+-+-+-+-+-+
            </pre>
            Value = (mant | 0x10) &lt;&lt; (exp + 3).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxMaxResponseTime">
            <summary>
            The Max Resp Code field specifies the maximum time allowed before sending a responding report.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxVersion3MaxResponseTime">
            <summary>
            The maximum value for the max response time in version 3 messages.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxQueryInterval">
            <summary>
            The maximum value for the query interval.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.Version">
            <summary>
            The version of the IGMP protocol for this datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message is determined as follows:
            <list type="bullet">
              <item>IGMPv1 Query: length = 8 octets AND Max Resp Code field is zero.</item>
              <item>IGMPv2 Query: length = 8 octets AND Max Resp Code field is non-zero.</item>
              <item>IGMPv3 Query: length >= 12 octets.</item>
            </list>
            If the type is not a query, None will be returned.
            If the query message do not match any of the above conditions (e.g., a Query of length 10 octets) Unknown will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxResponseCode">
            <summary>
            The Max Resp Code field specifies the maximum time allowed before sending a responding report.  
            The actual time allowed, called the Max Resp Time, is represented in units of 1/10 second and is derived from the Max Resp Code as follows:
            <list type="bullet">
              <item>If Max Resp Code &lt; 128, Max Resp Time = Max Resp Code.</item>
              <item>
                If Max Resp Code >= 128, Max Resp Code represents a floating-point value as follows:
                <pre>
                0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                Max Resp Time = (mant | 0x10) &lt;&lt; (exp + 3).
              </item>
            </list>
            
            <para>
            Small values of Max Resp Time allow IGMPv3 routers to tune the "leave latency" 
            (the time between the moment the last host leaves a group and the moment the routing protocol is notified that there are no more members).
            Larger values, especially in the exponential range, allow tuning of the burstiness of IGMP traffic on a network.
            </para>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxResponseTime">
            <summary>
            The actual time allowed, called the Max Resp Time, is represented in units of 1/10 second and is derived from the Max Resp Code as follows:
            <list type="bullet">
              <item>If the query version is 1 or 2 or if Max Resp Code &lt; 128, Max Resp Time = Max Resp Code.</item>
              <item>
                If Max Resp Code >= 128, Max Resp Code represents a floating-point value as follows:
                <pre>
                 0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                Max Resp Time = (mant | 0x10) &lt;&lt; (exp + 3).
              </item>
            </list>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.Checksum">
            <summary>
            The Checksum is the 16-bit one's complement of the one's complement sum of the whole IGMP message (the entire IP payload).  
            For computing the checksum, the Checksum field is set to zero.  
            When receiving packets, the checksum MUST be verified before processing a packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.IsChecksumCorrect">
            <summary>
            True iff the checksum value is correct according to the datagram data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.IsSuppressRouterSideProcessing">
            <summary>
            When set to one, the S Flag indicates to any receiving multicast routers that they are to suppress the normal timer updates they perform upon hearing a Query.  
            It does not, however, suppress the querier election or the normal "host-side" processing of a Query 
            that a router may be required to perform as a consequence of itself being a group member.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryRobustnessVariable">
            <summary>
            If non-zero, the QRV field contains the [Robustness Variable] value used by the querier, i.e., the sender of the Query.  
            If the querier's [Robustness Variable] exceeds 7, the maximum value of the QRV field, the QRV is set to zero.  
            Routers adopt the QRV value from the most recently received Query as their own [Robustness Variable] value, 
            unless that most recently received QRV was zero, in which case the receivers use the default [Robustness Variable] value or a statically configured value.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryIntervalCode">
            <summary>
            The Querier's Query Interval Code field specifies the [Query Interval] used by the querier.  
            The actual interval, called the Querier's Query Interval (QQI), is represented in units of seconds and is derived from the Querier's Query Interval Code as follows:
            <list type="bullet">
              <item>If QQIC &lt; 128, QQI = QQIC</item>
              <item>
                If QQIC >= 128, QQIC represents a floating-point value as follows:
                <pre>
                 0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                QQI = (mant | 0x10) &lt;&lt; (exp + 3)
              </item>
            </list>
            Multicast routers that are not the current querier adopt the QQI value from the most recently received Query as their own [Query Interval] value, 
            unless that most recently received QQI was zero, in which case the receiving routers use the default [Query Interval] value.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryInterval">
            <summary>
            The actual interval, called the Querier's Query Interval (QQI), is represented in units of seconds and is derived from the Querier's Query Interval Code as follows:
            <list type="bullet">
              <item>If QQIC &lt; 128, QQI = QQIC</item>
              <item>
                If QQIC >= 128, QQIC represents a floating-point value as follows:
                <pre>
                 0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                QQI = (mant | 0x10) &lt;&lt; (exp + 3)
              </item>
            </list>
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.NumberOfSources">
            <summary>
            The Number of Sources (N) field specifies how many source addresses are present in the Query.  
            This number is zero in a General Query or a Group-Specific Query, and non-zero in a Group-and-Source-Specific Query.  
            This number is limited by the MTU of the network over which the Query is transmitted.  
            For example, on an Ethernet with an MTU of 1500 octets, the IP header including the Router Alert option consumes 24 octets, 
            and the IGMP fields up to including the Number of Sources (N) field consume 12 octets, leaving 1464 octets for source addresses, 
            which limits the number of source addresses to 366 (1464/4).
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses,
            where n is the value in the Number of Sources (N) field.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.NumberOfGroupRecords">
            <summary>
            The Number of Group Records (M) field specifies how many Group Records are present in this Report.
            </summary>
            <remarks>
            Valid only on report of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.GroupRecords">
            <summary>
            Each Group Record is a block of fields containing information pertaining to the sender's membership in a single multicast group on the interface from which the Report is sent.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain">
            <summary>
            RFC 2535.
            <pre>
            +------------------+
            | next domain name |
            |                  |
            +------------------+
            | type bit map     |
            |                  |
            +------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.MaxTypeBitmapLength">
            <summary>
            The maximum length in bytes of the type bitmap.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.MaxTypeBitmapDnsType">
            <summary>
            The maximum DNS type that can be in the type bitmap.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance from next domain name and type bitmap.
            </summary>
            <param name="nextDomainName">The next domain name according to the canonical DNS name order.</param>
            <param name="typeBitmap">
            One bit per RR type present for the owner name.
            A one bit indicates that at least one RR of that type is present for the owner name.
            A zero indicates that no such RR is present.
            All bits not specified because they are beyond the end of the bit map are assumed to be zero.
            Note that bit 30, for NXT, will always be on so the minimum bit map length is actually four octets.
            Trailing zero octets are prohibited in this format.
            The first bit represents RR type zero (an illegal type which can not be present) and so will be zero in this format.
            This format is not used if there exists an RR with a type number greater than 127.
            If the zero bit of the type bit map is a one, it indicates that a different format is being used which will always be 
            the case if a type number greater than 127 is present.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.IsTypePresentForOwner(PcapDotNet.Packets.Dns.DnsType)">
            <summary>
            True iff the given type exists in the bitmap.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.CreateTypeBitmap(System.Collections.Generic.IEnumerable{PcapDotNet.Packets.Dns.DnsType})">
            <summary>
            Creates a type bitmap from a given list of DNS types.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.Equals(PcapDotNet.Packets.Dns.DnsResourceDataNextDomain)">
            <summary>
            Two DnsResourceDataNextDomain are equal iff their next domain name and type bitmap fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.Equals(System.Object)">
            <summary>
            Two DnsResourceDataNextDomain are equal iff their next domain name and type bitmap fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.GetHashCode">
            <summary>
            A hash code based on the next domain name and type bitmap fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.NextDomainName">
            <summary>
            The next domain name according to the canonical DNS name order.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.TypeBitmap">
            <summary>
            One bit per RR type present for the owner name.
            A one bit indicates that at least one RR of that type is present for the owner name.
            A zero indicates that no such RR is present.
            All bits not specified because they are beyond the end of the bit map are assumed to be zero.
            Note that bit 30, for NXT, will always be on so the minimum bit map length is actually four octets.
            Trailing zero octets are prohibited in this format.
            The first bit represents RR type zero (an illegal type which can not be present) and so will be zero in this format.
            This format is not used if there exists an RR with a type number greater than 127.
            If the zero bit of the type bit map is a one, it indicates that a different format is being used which will always be 
            the case if a type number greater than 127 is present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomain.TypesExist">
            <summary>
            Returns all the types that exist in the type bitmap.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionType">
            <summary>
            An enum for all the different tcp option types.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.EndOfOptionList">
            <summary>
            End of Option List (RFC793)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.NoOperation">
            <summary>
            No-Operation (RFC793)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.MaximumSegmentSize">
            <summary>
            Maximum Segment Size (RFC793)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.WindowScale">
            <summary>
            WSOPT - Window Scale (RFC1323)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.SelectiveAcknowledgmentPermitted">
            <summary>
            SACK Permitted (RFC2018)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.SelectiveAcknowledgment">
            <summary>
            SACK (RFC2018)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Echo">
            <summary>
            Echo (obsoleted by option 8) (RFC1072)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.EchoReply">
            <summary>
            Echo Reply (obsoleted by option 8) (RFC1072)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Timestamp">
            <summary>
            TSOPT - Time Stamp Option (RFC1323)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.PartialOrderConnectionPermitted">
            <summary>
            Partial Order Connection Permitted (RFC1693)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.PartialOrderServiceProfile">
            <summary>
            Partial Order Service Profile (RFC1693)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.ConnectionCount">
            <summary>
            CC (RFC1644)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.ConnectionCountNew">
            <summary>
            CC.NEW (RFC1644)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.ConnectionCountEcho">
            <summary>
            CC.ECHO (RFC1644)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.AlternateChecksumRequest">
            <summary>
            TCP Alternate Checksum Request (RFC1146)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.AlternateChecksumData">
            <summary>
            TCP Alternate Checksum Data (RFC1146)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Md5Signature">
            <summary>
            MD5 Signature Option (RFC2385)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.SelectiveNegativeAcknowledgements">
            <summary>
            Selective Negative Acknowledgements.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Mood">
            <summary>
            Denote Packet Mood (RFC5841)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.QuickStartResponse">
            <summary>
            Quick-Start Response (RFC4782)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.UserTimeout">
            <summary>
            User Timeout Option (RFC5482)
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionTimestamp">
            <summary>
            TCP Timestamps Option (TSopt):
            <pre>
            +-------+-------+---------------------+---------------------+
            |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|
            +-------+-------+---------------------+---------------------+
                1       1              4                     4
            </pre>
            
            <para>
            The Timestamps option carries two four-byte timestamp fields.
            The Timestamp Value field (TSval) contains the current value of the timestamp clock of the TCP sending the option.
            </para>
            
            <para>
            The Timestamp Echo Reply field (TSecr) is only valid if the ACK bit is set in the TCP header; 
            if it is valid, it echos a timestamp value that was sent by the remote TCP in the TSval field of a Timestamps option.  
            When TSecr is not valid, its value must be zero.  
            The TSecr value will generally be from the most recent Timestamp option that was received; however, there are exceptions that are explained below.
            </para>
            
            <para>
            A TCP may send the Timestamps option (TSopt) in an initial &lt;SYN&gt; segment (i.e., segment containing a SYN bit and no ACK bit), 
            and may send a TSopt in other segments only if it received a TSopt in the initial &lt;SYN&gt; segment for the connection.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionTimestamp.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionTimestamp.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates the option from the given timestamp value and echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.#ctor">
            <summary>
            The default values for the timestamp value and echo reply are 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.Equals(PcapDotNet.Packets.Transport.TcpOptionTimestamp)">
            <summary>
            Two timestamp options are equal if they have the same timestamp value and echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two timestamp options are equal if they have the same timestamp value and echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.GetHashCode">
            <summary>
            The hash code of the timestamp option is the hash code of the option type xored with the hash code of the timestamp echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.TimestampValue">
            <summary>
            The timestamp value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.TimestampEchoReply">
            <summary>
            The echo reply value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment">
            <summary>
            The SACK option is to be used to convey extended acknowledgment information from the receiver to the sender over an established TCP connection.
            
            <pre>
                              +--------+--------+
                              | Kind=5 | Length |
            +--------+--------+--------+--------+
            |      Left Edge of 1st Block       |
            +--------+--------+--------+--------+
            |      Right Edge of 1st Block      |
            +--------+--------+--------+--------+
            |                                   |
            /            . . .                  /
            |                                   |
            +--------+--------+--------+--------+
            |      Left Edge of nth Block       |
            +--------+--------+--------+--------+
            |      Right Edge of nth Block      |
            +--------+--------+--------+--------+
            </pre>
            
            <para>
            The SACK option is to be sent by a data receiver to inform the data sender of non-contiguous blocks of data that have been received and queued.  
            The data receiver awaits the receipt of data (perhaps by means of retransmissions) to fill the gaps in sequence space between received blocks.  
            When missing segments are received, the data receiver acknowledges the data normally by advancing 
            the left window edge in the Acknowledgement Number Field of the TCP header.  
            The SACK option does not change the meaning of the Acknowledgement Number field.
            </para>
            
            <para>
            This option contains a list of some of the blocks of contiguous sequence space occupied by data that has been received and queued within the window.
            Each contiguous block of data queued at the data receiver is defined in the SACK option by two 32-bit unsigned integers in network byte order:
            <list type="bullet">
              <item>Left Edge of Block - This is the first sequence number of this block.</item>
              <item>Right Edge of Block - This is the sequence number immediately following the last sequence number of this block.</item>
            </list>
            </para>
            Each block represents received bytes of data that are contiguous and isolated; 
            that is, the bytes just below the block, (Left Edge of Block - 1), and just above the block, (Right Edge of Block), have not been received.
            
            A SACK option that specifies n blocks will have a length of 8*n+2 bytes, so the 40 bytes available for TCP options can specify a maximum of 4 blocks.
            It is expected that SACK will often be used in conjunction with the Timestamp option used for RTTM [Jacobson92], 
            which takes an additional 10 bytes (plus two bytes of padding); thus a maximum of 3 SACK blocks will be allowed in this case.
            
            The SACK option is advisory, in that, while it notifies the data sender that the data receiver has received the indicated segments,
            the data receiver is permitted to later discard data which have been reported in a SACK option.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock})">
            <summary>
            Creates the option from the given list of selective ack blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.#ctor">
            <summary>
            The default is no blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Equals(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment)">
            <summary>
            Two selective ack options are equal if they have the same selective ack blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two selective ack options are equal if they have the same selective ack blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.GetHashCode">
            <summary>
            The hash code of the selective acknowledgement option is the hash code of the option type xored with all the hash codes of the blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Blocks">
            <summary>
            The collection of selective ack blocks.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMd5Signature">
            <summary>
            <pre>
            +---------+---------+-------------------+
            | Kind=19 |Length=18|   MD5 digest...   |
            +---------+---------+-------------------+
            |                                       |
            +---------------------------------------+
            |                                       |
            +---------------------------------------+
            |                                       |
            +-------------------+-------------------+
            |                   |
            +-------------------+
            </pre>
            
            <para>
            The MD5 digest is always 16 bytes in length, and the option would appear in every segment of a connection.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.#ctor(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates the option using the given signature data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.#ctor">
            <summary>
            The default signature is all zeroes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Equals(PcapDotNet.Packets.Transport.TcpOptionMd5Signature)">
            <summary>
            Two MD5 signature options are equal if they have the same signature value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two MD5 signature options are equal if they have the same signature value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.GetHashCode">
            <summary>
            The hash code of the MD5 signature option is the hash code of the option type xored with the hash code of the signature.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Data">
            <summary>
            The signature value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IOptionUnknownFactory`1">
            <summary>
            A factory interface for an unknown option.
            </summary>
            <typeparam name="TOptionType">The option type enum type.</typeparam>
        </member>
        <member name="M:PcapDotNet.Packets.IOptionUnknownFactory`1.CreateInstance(`0,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Creates an unknown option from its type and by reading a buffer for its value.
            </summary>
            <param name="optionType">The type of the unknown option.</param>
            <param name="buffer">The buffer of bytes to read the value of the unknown option.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="valueLength">The number of bytes to read from the buffer.</param>
            <returns>An option created from the given type and buffer.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram">
            <summary>
            Each Group Record is a block of fields containing information pertaining 
            to the sender's membership in a single multicast group on the interface from which the Report is sent.
            A Group Record has the following internal format:
            <pre>
            +-----+-------------+--------------+--------+--------------+
            | Bit | 0-7         | 8-15         | 16-31  |              |
            +-----+-------------+--------------+--------+--------------+
            | 0   | Record Type | Aux Data Len | Number of Sources (N) |
            +-----+-------------+--------------+--------+--------------+
            | 32  | Multicast Address                                  |
            +-----+----------------------------------------------------+
            | 64  | Source Address [1]                                 |
            +-----+----------------------------------------------------+
            | 96  | Source Address [2]                                 |
            +-----+----------------------------------------------------+
            .     .                         .                          .
            .     .                         .                          .
            +-----+----------------------------------------------------+
            | 32  | Source Address [N]                                 |
            | +   |                                                    |
            | 32N |                                                    |
            +-----+----------------------------------------------------+
            | 64  | Auxiliary Data                                     |
            . +   .                                                    .
            . 32N .                                                    .
            .     .                                                    .
            |     |                                                    |
            +-----+----------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.HeaderLength">
            <summary>
            The number of bytes the group record header takes (without the source addresses and auxiliary data).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.ToGroupRecord">
            <summary>
            Creates an IGMP group record from the given datagram.
            Useful to create a new IGMP packet with group records.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.CalculateIsValid">
            <summary>
            The record is valid if the length is correct according to the header fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.RecordType">
            <summary>
            The type of group record included in the report message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.AuxiliaryDataLength">
            <summary>
            The Aux Data Len field contains the length of the Auxiliary Data field in this Group Record, in bytes (after a translation from 32 bit words length).  
            It may contain zero, to indicate the absence of any auxiliary data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.NumberOfSources">
            <summary>
            The Number of Sources (N) field specifies how many source addresses are present in this Group Record.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.MulticastAddress">
            <summary>
            The Multicast Address field contains the IP multicast address to which this Group Record pertains.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.AuxiliaryData">
            <summary>
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram">
            <summary>
            RFC 1393.
            <pre>
            +-----+------+-------------+------------------+
            | Bit | 0-7  | 8-15        | 16-31            |
            +-----+------+-------------+------------------+
            | 0   | Type | Code        | Checksum         |
            +-----+------+-------------+------------------+
            | 32  | ID Number          | unused           |
            +-----+--------------------+------------------+
            | 64  | Outbound Hop Count | Return Hop Count |
            +-----+--------------------+------------------+
            | 96  | Output Link Speed                     |
            +-----+---------------------------------------+
            | 128 | Output Link MTU                       |
            +-----+---------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.DatagramLength">
            <summary>
            The number of bytes this datagram should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.PayloadLength">
            <summary>
            The number of bytes this ICMP payload should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutboundReturnHopCountValue">
            <summary>
            The value the Return Hop Count should be for an outbound ICMP packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.Identification">
            <summary>
            The ID Number as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.  
            This is NOT related to the ID number in the IP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutboundHopCount">
            <summary>
            The Outbound Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.ReturnHopCount">
            <summary>
            The Return Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutputLinkSpeed">
            <summary>
            The speed, in OCTETS per second, of the link over which the Outbound/Return Packet will be sent.  
            Since it will not be long before network speeds exceed 4.3Gb/s, and since some machines deal poorly with fields longer than 32 bits, octets per second was chosen over bits per second.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutputLinkMaximumTransmissionUnit">
            <summary>
            The MTU, in bytes, of the link over which the Outbound/Return Packet will be sent.  
            MTU refers to the data portion (includes IP header; excludes datalink header/trailer) of the packet.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.IsOutbound">
            <summary>
            Is the packet an Outbound packet.
            This is indicated by a value of  0xFFFF in the ReturnHopCount field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram">
            <summary>
            RFC 1475.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | pointer to problem area |
            +-----+-------------------------+
            | 64  | copy of datagram that   |
            |     | could not be converted  |
            |     | ...                     |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.OriginalDatagramLengthForUnsupportedTransportProtocol">
            <summary>
            The number of bytes that should be taken from the original datagram for an unsupported transport protocol ICMP code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range
            and the IPv4 payload contains at least an IPv4 header and the transport header.
            If the code is for unsupported transport protocol, the IPv4 payload should contain 256 bytes of the original datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.Pointer">
            <summary>
            An offset from the start of the original datagram to the beginning of the offending field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRedirectLayer">
            <summary>
            RFC 792.
            Represents an ICMP Redirect message layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.GatewayInternetAddress">
            <summary>
            Address of the gateway to which traffic for the network specified in the internet destination network field of the original datagram's data should be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationRequestDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpInformationRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer">
            <summary>
            RFC 792 and RFC 1191.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.NextHopMaximumTransmissionUnit">
            <summary>
            The size in octets of the largest datagram that could be forwarded, 
            along the path of the original datagram, without being fragmented at this router.  
            The size includes the IP header and IP data, and does not include any lower-level headers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer">
            <summary>
            RFC 1475.
            Represents a Conversion Failed ICMP layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.Pointer">
            <summary>
            An offset from the start of the original datagram to the beginning of the offending field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpVersion">
            <summary>
            Represents an HTTP version.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates a version from the major and minor version numbers.
            </summary>
            <param name="major">The major version number. 0 for 0.9, 1 for 1.0 or 1.1.</param>
            <param name="minor">The minor version number. 9 for 0.9, 0, for 1.0 and 1 for 1.1.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.ToString">
            <summary>
            A string represneting the version.
            Example: &quot;HTTP/1.1&quot;.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.Equals(PcapDotNet.Packets.Http.HttpVersion)">
            <summary>
            Two HTTP versions are equal iff they have the same major and minor versions.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.Equals(System.Object)">
            <summary>
            Two HTTP versions are equal iff they have the same major and minor versions.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.GetHashCode">
            <summary>
            The hash code of an http version is the xor of the hash codes of the minor version and the major version.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Version10">
            <summary>
            A built version for HTTP/1.0.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Version11">
            <summary>
            A built version for HTTP/1.1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Major">
            <summary>
            The major version number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Minor">
            <summary>
            The minor version number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Length">
            <summary>
            The number of bytes this version takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpContentLengthField">
            <summary>
            RFC 2616.
            The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, 
            in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpField">
            <summary>
            An HTTP field with a name and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.CreateField(System.String,System.Byte[])">
            <summary>
            Creates a field according to the field name and value.
            </summary>
            <param name="fieldName">The name of the field to create.</param>
            <param name="fieldValue">The bytes value of the field to create.</param>
            <returns>The constructed HTTP field.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.CreateField(System.String,System.String,System.Text.Encoding)">
            <summary>
            Creates a field according to the field name and encoded string value.
            </summary>
            <param name="fieldName">The name of the field to create.</param>
            <param name="fieldValue">The value of the field to create encoded in the given encoding.</param>
            <param name="fieldValueEncoding">The encoding that encodes the given field value.</param>
            <returns>The constructed HTTP field.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.CreateField(System.String,System.String)">
            <summary>
            Creates a field according to the field name and encoded string value.
            </summary>
            <param name="fieldName">The name of the field to create.</param>
            <param name="fieldValue">The value of the field to create encoded in ISO-8859-1 encoding.</param>
            <returns>The constructed HTTP field.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.Equals(PcapDotNet.Packets.Http.HttpField)">
            <summary>
            True iff the two HTTP fields are of equal value.
            Two fields are equal iff they have the same name (case insensitive) and the same bytes value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.Equals(System.Object)">
            <summary>
            True iff the two HTTP fields are of equal value.
            Two fields are equal iff they have the same name (case insensitive) and the same bytes value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.GetHashCode">
            <summary>
            Returns a hash code of this field according to the name and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.ToString">
            <summary>
            A string representing the field similar to how it would like in the HTTP protocol.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.Name">
            <summary>
            The name of the field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.Value">
            <summary>
            The Value of the field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.ValueString">
            <summary>
            The Value of the field as a string using ISO-8859-1 encoding.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.Length">
            <summary>
            The number of bytes the field will take in the HTTP protocol.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentLengthField.FieldName">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentLengthField.FieldNameUpper">
            <summary>
            The field name in uppercase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentLengthField.#ctor(System.UInt32)">
            <summary>
            Creates a Content Length Field according to a given content length.
            </summary>
            <param name="contentLength">
            The size of the entity-body, in decimal number of OCTETs, sent to the recipient or, 
            in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
            </param>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentLengthField.ContentLength">
            <summary>
            The size of the entity-body, in decimal number of OCTETs, sent to the recipient or, 
            in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreVersion">
            <summary>
            The GRE Version Number.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreVersion.Gre">
            <summary>
            RFC 1701, RFC 2784
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreVersion.EnhancedGre">
            <summary>
            RFC 2637
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataSink">
            <summary>
            Eastlake.
            <pre>
            +-----+--------+-----------+
            | bit | 0-7    | 8-15      |
            +-----+--------+-----------+
            | 0   | coding | subcoding |
            +-----+--------+-----------+
            | 16  | data               |
            | ... |                    |
            +-----+--------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSink.#ctor(PcapDotNet.Packets.Dns.DnsSinkCodingSubCoding,PcapDotNet.Packets.DataSegment)">
            <summary>
            Construct an instance out of the coding subcoding and data fields.
            </summary>
            <param name="codingSubCoding">
            A combination of coding and subcoding.
            Has a valid enum value if the subcoding is defined specifically for the coding.
            </param>
            <param name="data">Variable length and could be null in some cases.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSink.#ctor(PcapDotNet.Packets.Dns.DnsSinkCoding,System.Byte,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the coding, subcoding and data fields.
            </summary>
            <param name="coding">Gives the general structure of the data.</param>
            <param name="subCoding">Provides additional information depending on the value of the coding.</param>
            <param name="data">Variable length and could be null in some cases.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSink.Equals(PcapDotNet.Packets.Dns.DnsResourceDataSink)">
            <summary>
            Two are equal iff their coding, subcoding and data fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSink.Equals(System.Object)">
            <summary>
            Two are equal iff their coding, subcoding and data fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSink.GetHashCode">
            <summary>
            A hash code based on the coding, subcoding and data fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSink.Coding">
            <summary>
            Gives the general structure of the data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSink.SubCoding">
            <summary>
            Provides additional information depending on the value of the coding.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSink.CodingSubCoding">
            <summary>
            Returns a combination of coding and subcoding.
            Has a valid enum value if the subcoding is defined specifically for the coding.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSink.Data">
            <summary>
            Variable length and could be null in some cases.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsGatewayIpV6">
            <summary>
            Represents an IPv6 gateway to which an IPsec tunnel may be created in order to reach the entity named by an IPsec resource record.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsGateway">
            <summary>
            Represents a gateway to which an IPsec tunnel may be created in order to reach the entity named by an IPsec resource record.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGateway.Equals(PcapDotNet.Packets.Dns.DnsGateway)">
            <summary>
            Two gateway representations are equal if they are of the same type and the value is the same.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGateway.Equals(System.Object)">
            <summary>
            Two gateway representations are equal if they are of the same type and the value is the same.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGateway.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>A hash code for the current gateway represnetation.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGateway.None">
            <summary>
            An instance that represents that no gateway exists.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGateway.GatewayType">
            <summary>
            The gateway represnetation type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGateway.Length">
            <summary>
            The number of bytes the gateway represnetation takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayIpV6.#ctor(PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Creates a gateway using the given IPv6 address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayIpV6.Equals(PcapDotNet.Packets.Dns.DnsGatewayIpV6)">
            <summary>
            Two DnsGatewayIpV6 are equal if their IPv6 addresses are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayIpV6.Equals(PcapDotNet.Packets.Dns.DnsGateway)">
            <summary>
            Two gateway representations are equal if they are of the same type and the value is the same.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayIpV6.Value">
            <summary>
            The IPv6 address value of the gateway.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayIpV6.GatewayType">
            <summary>
            The gateway represnetation type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayIpV6.Length">
            <summary>
            The number of bytes the gateway represnetation takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsDomainName">
            <summary>
            A domain name represented as a series of labels, and terminated by a label with zero length.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDomainName.RootLength">
            <summary>
            The number of bytes a root ('.') domain name takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDomainName.#ctor(System.String)">
            <summary>
            Creates a domain name out of a string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDomainName.ToString">
            <summary>
            Returns a string representation of the domain name.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDomainName.Equals(PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Two domain names are equal if their labels are equal ignoring any casing.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDomainName.Equals(System.Object)">
            <summary>
            Two domain names are equal if their labels are equal ignoring any casing.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDomainName.GetHashCode">
            <summary>
            Returns the hash code of the domain name.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDomainName.Root">
            <summary>
            The root ('.') domain name.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDomainName.LabelsCount">
            <summary>
            The number of labels the domain name has.
            For example, root ('.') has 0 labels.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDomainName.IsRoot">
            <summary>
            Returns true iff the domain name is the root ('.') domain name.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDomainName.NonCompressedLength">
            <summary>
            The number of bytes the domain name takes assuming it won't be compressed.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer">
            <summary>
            Represents an VLAN Tagged Frame layer.
            <seealso cref="T:PcapDotNet.Packets.Ethernet.VLanTaggedFrameDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.#ctor">
            <summary>
            Creates an instance with zero values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.Equals(PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer)">
            <summary>
            Two VLAN Tagged Frame layers are equal iff their PriorityCodePoint, CanonicalFormatIndicator, VLanIdentifier and EtherType are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two VLAN Tagged Frame layers are equal iff their PriorityCodePoint, CanonicalFormatIndicator, VLanIdentifier and EtherType are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the hash codes of the layer length, data link, TagControlInformation and the ethernet type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.PriorityCodePoint">
            <summary>
            Indicates the frame priority level.
            Values are from 0 (best effort) to 7 (highest); 1 represents the lowest priority.
            These values can be used to prioritize different classes of traffic (voice, video, data, etc.).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.CanonicalFormatIndicator">
            <summary>
            If reset, all MAC Address information that may be present in the MSDU is in Canonical format and the tag comprises solely the TPID and TCI fields,
            i.e., the tag does not contain an Embedded Routing Information Field (E-RIF).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.VLanIdentifier">
            <summary>
            A VLAN-aware Bridge may not support the full range of VID values but shall support the use of all VID values in the range 0 through a maximum N,
            less than or equal to 4094 and specified for that implementation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.TagControlInformation">
            <summary>
            A combination of pcp (PriorityCodePoint), cfi (CanonicalFormatIndicator) and vid (VLanIdentifier).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.PreviousLayerEtherType">
            <summary>
            The Ethernet Type the Ethernet layer should write when this layer is the Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.VLanTaggedFrameLayer.PreviousLayerDefaultDestination">
            <summary>
            The default MAC Address value when this layer is the Ethernet payload.
            null means there is no default value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.UdpLayer">
            <summary>
            RFC 768.
            Represents the UDP layer.
            <seealso cref="T:PcapDotNet.Packets.Transport.UdpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TransportLayer">
            <summary>
            Contains the common part of UDP and TCP layers.
            <seealso cref="T:PcapDotNet.Packets.Transport.TransportDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer">
            <summary>
            A Transport layer under an IPv4 layer.
            Must supply information about the Transport layer checksum.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the Transport header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.
            If null is given, the Checksum will be calculated to be correct according to the data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.CalculateChecksum">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.Equals(PcapDotNet.Packets.Transport.TransportLayer)">
            <summary>
            Two Transport layers are equal if they have they have the same previous layer protocol value, checksum, source and destination ports, 
            and if the specific transport protocol fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two Transport layers are equal if they have they have the same previous layer protocol value, checksum, source and destination ports, 
            and if the specific transport protocol fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the combination of the source and destination ports and the hash codes of the layer length, data link and checksum.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.EqualFields(PcapDotNet.Packets.Transport.TransportLayer)">
            <summary>
            True iff the specific transport layer fields are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the Transport header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.SourcePort">
            <summary>
            Indicates the port of the sending process.
            In UDP, this field is optional and may only be assumed to be the port 
            to which a reply should be addressed in the absence of any other information.
            If not used in UDP, a value of zero is inserted.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.DestinationPort">
            <summary>
            Destination Port has a meaning within the context of a particular internet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.CalculateChecksum">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.UdpLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.CalculateChecksum">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.CalculateChecksumValue">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock">
            <summary>
            Represents a block to ack when using the selective ack option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.SizeOf">
            <summary>
            The number of bytes this struct take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates a selective ack block.
            </summary>
            <param name="leftEdge">The sequence number of the first byte to ack.</param>
            <param name="rightEdge">The sequence number of the byte after the last byte to ack.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.ToString">
            <summary>
            Creates a string that represents the selective block.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.Equals(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock)">
            <summary>
            Two blocks are equal if the have the same left and right edges.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.Equals(System.Object)">
            <summary>
            Two blocks are equal if the have the same left and right edges.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.op_Equality(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock,PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock)">
            <summary>
            Two blocks are equal if the have the same left and right edges.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.op_Inequality(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock,PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock)">
            <summary>
            Two blocks are different if the have the different left or right edge.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.GetHashCode">
            <summary>
            The hash code of a block is the xor between the hash code of left and right edges.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.LeftEdge">
            <summary>
            The sequence number of the first byte to ack.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.RightEdge">
            <summary>
            The sequence number of the byte after the last byte to ack.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile">
            <summary>
            TCP POC-service-profile Option (RFC 1693).
            
            <pre>
                                      1 bit        1 bit    6 bits
            +----------+----------+------------+----------+--------+
            |  Kind=10 | Length=3 | Start_flag | End_flag | Filler |
            +----------+----------+------------+----------+--------+
            </pre>
            
            <para>
            Contains two 1-bit flags necessary to handle the case where the service profile does not fit in a single TCP segment.  
            The "Start_flag" indicates that the information in the data section represents the beginning of the service profile 
            and the "End_flag" represents the converse.  
            For service profiles which fit completely in a single segment, both flags will be set to 1. 
            Otherwise, the Start_flag is set in the initial segment and the End_flag in the final segment 
            allowing the peer entity to reconstrcut the entire service profile (using the normal sequence numbers in the segment header).  
            The "Filler" field serves merely to complete the third byte of the option.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Creates the option using the given isStart and isEnd values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.#ctor">
            <summary>
            The default is for service profiles which fit completely in a single segment.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.Equals(PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile)">
            <summary>
            Two partial order service profile options are equal if they agree on both IsStart and IsEnd.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two partial order service profile options are equal if they agree on both IsStart and IsEnd.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.GetHashCode">
            <summary>
            The hash code of the partial order service profile option is the hash code of the option type xored with a combination of the IsStart and IsEnd values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.IsStart">
            <summary>
            Indicates that the information in the data section represents the beginning of the service profile.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.IsEnd">
            <summary>
            Indicates that the information in the data section represents the end of the service profile.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpControlBits">
            <summary>
            TCP control bits format
            <pre>
            +-----+-----+----+-----+-----+-----+-----+-----+-----+-----+-----+
            | Bit | 0-6 | 7  | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
            +-----+-----+----+-----+-----+-----+-----+-----+-----+-----+-----+
            | 0   |     | NS | CWR | ECE | URG | ACK | PSH | RST | SYN | FIN |
            +-----+-----+----+-----+-----+-----+-----+-----+-----+-----+-----+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.None">
            <summary>
            No control bits are turned on.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Fin">
            <summary>
            No more data from sender.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Synchronize">
            <summary>
            Synchronize sequence numbers.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Reset">
            <summary>
            Reset the connection.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Push">
            <summary>
            Push Function.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Acknowledgment">
            <summary>
            Acknowledgment field significant.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Urgent">
            <summary>
            Urgent Pointer field significant.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.ExplicitCongestionNotificationEcho">
            <summary>
            RFC 3168.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.CongestionWindowReduced">
            <summary>
            RFC 3168.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.NonceSum">
            <summary>
            RFC 3540.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart">
            <summary>
            The Quick-Start Option for IPv4
            
            <para>
              The Quick-Start Request for IPv4 is defined as follows:
              <pre>
            +--------+----------+-------+---------+-------+-------+
            | 0-7    | 8-15     | 16-19 | 20-23   | 24-29 | 30-31 |
            +--------+----------+-------+---------+-------+-------+
            | Option | Length=8 | Func. | Rate    | QS TTL        |
            |        |          | 0000  | Request |               |
            +--------+----------+-------+---------+-------+-------+
            | QS Nonce                                    | R     |
            +---------------------------------------------+-------+
              </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.OptionValueLength">
            <summary>
            The number of bytes this option's value take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.RateMaximumValue">
            <summary>
            The maximum value for the rate field.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction,System.Byte,System.Byte,System.UInt32)">
            <summary>
            Create a quick start option according to the given field values.
            </summary>
            <param name="function">The function of this quick start option.</param>
            <param name="rate">Either the rate requested or reported.</param>
            <param name="ttl">
            The Quick-Start TTL (QS TTL) field.  
            The sender MUST set the QS TTL field to a random value.
            Routers that approve the Quick-Start Request decrement the QS TTL (mod 256) by the same amount that they decrement the IP TTL.  
            The QS TTL is used by the sender to detect if all the routers along the path understood and approved the Quick-Start option.
            </param>
            <param name="nonce">
            The QS Nonce gives the Quick-Start sender some protection against receivers lying about the value of the received Rate Request. 
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.#ctor">
            <summary>
            Creates a request with 0 fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Equals(PcapDotNet.Packets.IpV4.IpV4OptionQuickStart)">
            <summary>
            Two quick start options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two trace route options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code with the following values hash code:
            The combination of function, rate and ttl and the nonce.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Function">
            <summary>
            The function of this quick start option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Rate">
            <summary>
            If function is request then this field is the rate request.
            If function is report then this field is the rate report.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.RateKbps">
            <summary>
            The rate translated to KBPS.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Ttl">
            <summary>
            The Quick-Start TTL (QS TTL) field.  
            The sender MUST set the QS TTL field to a random value.
            Routers that approve the Quick-Start Request decrement the QS TTL (mod 256) by the same amount that they decrement the IP TTL.  
            The QS TTL is used by the sender to detect if all the routers along the path understood and approved the Quick-Start option.
            
            <para>
              For a Rate Request, the transport sender MUST calculate and store the TTL Diff, 
              the difference between the IP TTL value, and the QS TTL value in the Quick-Start Request packet, as follows:
              TTL Diff = ( IP TTL - QS TTL ) mod 256                 
            </para>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Nonce">
            <summary>
            The QS Nonce gives the Quick-Start sender some protection against receivers lying about the value of the received Rate Request. 
            This is particularly important if the receiver knows the original value of the Rate Request 
            (e.g., when the sender always requests the same value, and the receiver has a long history of communication with that sender).  
            Without the QS Nonce, there is nothing to prevent the receiver from reporting back to the sender a Rate Request of K, 
            when the received Rate Request was, in fact, less than K.
            
            <para>
              The format for the 30-bit QS Nonce.
              <list type="table">
                <listheader>
                    <term>Bits</term>
                    <description>Purpose</description>
                </listheader>
                <item><term>Bits 0-1</term><description>Rate 15 -> Rate 14</description></item>
                <item><term>Bits 2-3</term><description>Rate 14 -> Rate 13</description></item>
                <item><term>Bits 4-5</term><description>Rate 13 -> Rate 12</description></item>
                <item><term>Bits 6-7</term><description>Rate 12 -> Rate 11</description></item>
                <item><term>Bits 8-9</term><description>Rate 11 -> Rate 10</description></item>
                <item><term>Bits 10-11</term><description>Rate 10 -> Rate 9</description></item>
                <item><term>Bits 12-13</term><description>Rate 9 -> Rate 8</description></item>
                <item><term>Bits 14-15</term><description>Rate 8 -> Rate 7</description></item>
                <item><term>Bits 16-17</term><description>Rate 7 -> Rate 6</description></item>
                <item><term>Bits 18-19</term><description>Rate 6 -> Rate 5</description></item>
                <item><term>Bits 20-21</term><description>Rate 5 -> Rate 4</description></item>
                <item><term>Bits 22-23</term><description>Rate 4 -> Rate 3</description></item>
                <item><term>Bits 24-25</term><description>Rate 3 -> Rate 2</description></item>
                <item><term>Bits 26-27</term><description>Rate 2 -> Rate 1</description></item>
                <item><term>Bits 28-29</term><description>Rate 1 -> Rate 0</description></item>
              </list>
            </para>
            
            <para>
            The transport sender MUST initialize the QS Nonce to a random value. 
            If the router reduces the Rate Request from rate K to rate K-1, 
            then the router MUST set the field in the QS Nonce for "Rate K -> Rate K-1" to a new random value.  
            Similarly, if the router reduces the Rate Request by N steps, 
            the router MUST set the 2N bits in the relevant fields in the QS Nonce to a new random value.  
            The receiver MUST report the QS Nonce back to the sender.
            </para>
            
            <para>
            If the Rate Request was not decremented in the network, then the QS Nonce should have its original value.  
            Similarly, if the Rate Request was decremented by N steps in the network, 
            and the receiver reports back a Rate Request of K, then the last 2K bits of the QS Nonce should have their original value.
            </para>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions">
            <summary>
            Fragmentation information flags for IPv4 datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions.None">
            <summary>
            May Fragment, Last Fragment.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions.MoreFragments">
            <summary>
            More Fragments.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions.DoNotFragment">
            <summary>
            Don't Fragment.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer">
            <summary>
            RFC 3376.
            Represents an IGMP Query version 3 layer.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.#ctor">
            <summary>
            Creates an instance of an IGMP Query Version 3 layer.
            Default SourceAddresses is no addresses.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.GetHashCode">
            <summary>
            Xor of the combination of the IsSuppressRouterSideProcessing and QueryRobustnessVariable fields with
            the hash codes of the layer length, datalink, message type, query version, group address and all the source addresses.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the GroupAddress, IsSuppressRouterSideProcessing, QueryRobustnessVariable and SourceAddresses fields are equal
            and the QueryInterval is similar.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer)">
            <summary>
            true iff the GroupAddress, IsSuppressRouterSideProcessing, QueryRobustnessVariable and SourceAddresses fields are equal
            and the QueryInterval is similar.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.MaxResponseTime">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.IsSuppressRouterSideProcessing">
            <summary>
            When set to one, the S Flag indicates to any receiving multicast routers that they are to suppress the normal timer updates they perform upon hearing a Query.  
            It does not, however, suppress the querier election or the normal "host-side" processing of a Query 
            that a router may be required to perform as a consequence of itself being a group member.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.QueryRobustnessVariable">
            <summary>
            If non-zero, the QRV field contains the [Robustness Variable] value used by the querier, i.e., the sender of the Query.  
            If the querier's [Robustness Variable] exceeds 7, the maximum value of the QRV field, the QRV is set to zero.  
            Routers adopt the QRV value from the most recently received Query as their own [Robustness Variable] value, 
            unless that most recently received QRV was zero, in which case the receivers use the default [Robustness Variable] value or a statically configured value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.QueryInterval">
            <summary>
            The actual interval, called the Querier's Query Interval (QQI).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses,
            where n is the value in the Number of Sources (N) field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationLayer">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpEchoLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpResponseLayer">
            <summary>
            RFC 2616.
            Represents an HTTP response layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpResponseLayer.Equals(PcapDotNet.Packets.Http.HttpLayer)">
            <summary>
            Two HTTP response layers are equal iff they have the same version, header, body, status code and reason phrase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpResponseLayer.Equals(PcapDotNet.Packets.Http.HttpResponseLayer)">
            <summary>
            Two HTTP response layers are equal iff they have the same version, header, body, status code and reason phrase.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseLayer.IsRequest">
            <summary>
            false since this is a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseLayer.StatusCode">
            <summary>
            The status code of the response.
            null if no status code exists.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseLayer.ReasonPhrase">
            <summary>
            The data of the reason phrase.
            Example: OK
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestLayer">
            <summary>
            RFC 2616.
            Represents an HTTP request layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestLayer.Equals(PcapDotNet.Packets.Http.HttpLayer)">
            <summary>
            Two HTTP Request layers are equal iff they have the same version, header, body, method and uri.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestLayer.Equals(PcapDotNet.Packets.Http.HttpRequestLayer)">
            <summary>
            Two HTTP Request layers are equal iff they have the same version, header, body, method and uri.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestLayer.IsRequest">
            <summary>
            True since the message is a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestLayer.Method">
            <summary>
            The HTTP Request Method.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestLayer.Uri">
            <summary>
            The HTTP Request URI.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsTypeBitmaps">
            <summary>
            RFCs 4034, 5155.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint">
            <summary>
            RFC 4255.
            <pre>
            +-----+-----------+-----------+
            | bit | 0-7       | 8-15      |
            +-----+-----------+-----------+
            | 0   | algorithm | fp type   |
            +-----+-----------+-----------+
            | 16  | fingerprint           |
            | ... |                       |
            +-----+-----------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint.#ctor(PcapDotNet.Packets.Dns.DnsFingerprintPublicKeyAlgorithm,PcapDotNet.Packets.Dns.DnsFingerprintType,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the algorithm, fingerprint type and fingerprint fields.
            </summary>
            <param name="algorithm">Describes the algorithm of the public key.</param>
            <param name="fingerprintType">Describes the message-digest algorithm used to calculate the fingerprint of the public key.</param>
            <param name="fingerprint">
            The fingerprint is calculated over the public key blob.
            The message-digest algorithm is presumed to produce an opaque octet string output, which is placed as-is in the RDATA fingerprint field.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint.Equals(PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint)">
            <summary>
            Two DnsResourceDataSshFingerprint are equal iff the algorithm, fingerprint type and fingerprint fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint.Equals(System.Object)">
            <summary>
            Two DnsResourceDataSshFingerprint are equal iff the algorithm, fingerprint type and fingerprint fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint.GetHashCode">
            <summary>
            A hash code based on the algorithm, fingerprint type and fingerprint fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint.Algorithm">
            <summary>
            Describes the algorithm of the public key.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint.FingerprintType">
            <summary>
            Describes the message-digest algorithm used to calculate the fingerprint of the public key.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataSshFingerprint.Fingerprint">
            <summary>
            The fingerprint is calculated over the public key blob.
            The message-digest algorithm is presumed to produce an opaque octet string output, which is placed as-is in the RDATA fingerprint field.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol">
            <summary>
            RFC 5205.
            <pre>
            +-----+------------+--------------+-----------+
            | bit | 0-7        | 8-15         | 16-31     |
            +-----+------------+--------------+-----------+
            | 0   | HIT Length | PK Algorithm | PK Length |
            +-----+------------+--------------+-----------+
            | 32  | HIT                                   |
            | ... |                                       |
            +-----+---------------------------------------+
            |     | Public Key                            |
            | ... |                                       |
            +-----+---------------------------------------+
            |     | Rendezvous Servers                    |
            | ... |                                       |
            +-----+---------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.#ctor(PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.Dns.DnsPublicKeyAlgorithm,PcapDotNet.Packets.DataSegment,System.Collections.Generic.IEnumerable{PcapDotNet.Packets.Dns.DnsDomainName})">
            <summary>
            Constructs an instance out of the host identity tag, public key algorithm, public key and rendezvous servers fields.
            </summary>
            <param name="hostIdentityTag">Stored as a binary value in network byte order.</param>
            <param name="publicKeyAlgorithm">Identifies the public key's cryptographic algorithm and determines the format of the public key field.</param>
            <param name="publicKey">Contains the algorithm-specific portion of the KEY RR RDATA.</param>
            <param name="rendezvousServers">
            Indicates one or more domain names of rendezvous server(s).
            Must not be compressed.
            The rendezvous server(s) are listed in order of preference (i.e., first rendezvous server(s) are preferred),
            defining an implicit order amongst rendezvous servers of a single RR.
            When multiple HIP RRs are present at the same owner name,
            this implicit order of rendezvous servers within an RR must not be used to infer a preference order between rendezvous servers stored in different RRs.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.Equals(PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol)">
            <summary>
            Two DnsResourceDataHostIdentityProtocol are equal iff their host identity tag, public key algorithm, public key and rendezvous servers fields 
            are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.Equals(System.Object)">
            <summary>
            Two DnsResourceDataHostIdentityProtocol are equal iff their host identity tag, public key algorithm, public key and rendezvous servers fields 
            are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.GetHashCode">
            <summary>
            A hash code of the combination of the host identity tag, public key algorithm, public key and rendezvous servers fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.HostIdentityTag">
            <summary>
            Stored as a binary value in network byte order.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.PublicKeyAlgorithm">
            <summary>
            Identifies the public key's cryptographic algorithm and determines the format of the public key field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.PublicKey">
            <summary>
            Contains the algorithm-specific portion of the KEY RR RDATA.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataHostIdentityProtocol.RendezvousServers">
            <summary>
            Indicates one or more domain names of rendezvous server(s).
            Must not be compressed.
            The rendezvous server(s) are listed in order of preference (i.e., first rendezvous server(s) are preferred),
            defining an implicit order amongst rendezvous servers of a single RR.
            When multiple HIP RRs are present at the same owner name,
            this implicit order of rendezvous servers within an RR must not be used to infer a preference order between rendezvous servers stored in different RRs.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataCertificate">
            <summary>
            RFC 4398.
            <pre>
            +-----+-----------+------+------------+
            | bit | 0-7       | 8-15 | 16-31      |
            +-----+-----------+------+------------+
            | 0   | type             | key tag    |
            +-----+-----------+------+------------+
            | 32  | algorithm | certificate or CRL|
            +-----+-----------+                   |
            |     |                               |
            | ... |                               |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.#ctor(PcapDotNet.Packets.Dns.DnsCertificateType,System.UInt16,PcapDotNet.Packets.Dns.DnsAlgorithm,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance from the certificate type, key tag, algorithm and certificate fields.
            </summary>
            <param name="certificateType">The certificate type.</param>
            <param name="keyTag">
            Value computed for the key embedded in the certificate, using the RRSIG Key Tag algorithm.
            This field is used as an efficiency measure to pick which CERT RRs may be applicable to a particular key.
            The key tag can be calculated for the key in question, and then only CERT RRs with the same key tag need to be examined.
            Note that two different keys can have the same key tag.
            However, the key must be transformed to the format it would have as the public key portion of a DNSKEY RR before the key tag is computed.
            This is only possible if the key is applicable to an algorithm and complies to limits (such as key size) defined for DNS security.
            If it is not, the algorithm field must be zero and the tag field is meaningless and should be zero.
            </param>
            <param name="algorithm">
            Has the same meaning as the algorithm field in DNSKEY and RRSIG RRs,
            except that a zero algorithm field indicates that the algorithm is unknown to a secure DNS, 
            which may simply be the result of the algorithm not having been standardized for DNSSEC.
            </param>
            <param name="certificate">The certificate data according to the type.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.Equals(PcapDotNet.Packets.Dns.DnsResourceDataCertificate)">
            <summary>
            Two DnsResourceDataCertificate are equal iff their certificate type, key tag, algorithm and certificate fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.Equals(System.Object)">
            <summary>
            Two DnsResourceDataCertificate are equal iff their certificate type, key tag, algorithm and certificate fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.GetHashCode">
            <summary>
            A hash code of the combination of the certificate type, key tag, algorithm and certificate fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.CertificateType">
            <summary>
            The certificate type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.KeyTag">
            <summary>
            Value computed for the key embedded in the certificate, using the RRSIG Key Tag algorithm.
            This field is used as an efficiency measure to pick which CERT RRs may be applicable to a particular key.
            The key tag can be calculated for the key in question, and then only CERT RRs with the same key tag need to be examined.
            Note that two different keys can have the same key tag.
            However, the key must be transformed to the format it would have as the public key portion of a DNSKEY RR before the key tag is computed.
            This is only possible if the key is applicable to an algorithm and complies to limits (such as key size) defined for DNS security.
            If it is not, the algorithm field must be zero and the tag field is meaningless and should be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.Algorithm">
            <summary>
            Has the same meaning as the algorithm field in DNSKEY and RRSIG RRs,
            except that a zero algorithm field indicates that the algorithm is unknown to a secure DNS, 
            which may simply be the result of the algorithm not having been standardized for DNSSEC.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataCertificate.Certificate">
            <summary>
            The certificate data according to the type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataA6">
            <summary>
            RFC 2874.
            <pre>
            +-------------+----------------+-----------------+
            | Prefix len. | Address suffix | Prefix name     |
            | (1 octet)   | (0..16 octets) | (0..255 octets) |
            +-------------+----------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsResourceDataA6.MaxPrefixLength">
            <summary>
            The maximum value for the prefix length.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataA6.#ctor(System.Byte,PcapDotNet.Packets.IpV6.IpV6Address,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs the resource data from the prefix length, address suffix and prefix name fields.
            </summary>
            <param name="prefixLength">Encoded as an eight-bit unsigned integer with value between 0 and 128 inclusive.</param>
            <param name="addressSuffix">
            An IPv6 address suffix, encoded in network order (high-order octet first).
            There must be exactly enough octets in this field to contain a number of bits equal to 128 minus prefix length, 
            with 0 to 7 leading pad bits to make this field an integral number of octets.
            Pad bits, if present, must be set to zero when loading a zone file and ignored (other than for SIG verification) on reception.
            </param>
            <param name="prefixName">The name of the prefix, encoded as a domain name. This name must not be compressed. </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataA6.Equals(PcapDotNet.Packets.Dns.DnsResourceDataA6)">
            <summary>
            Two A6 resource datas are equal iff their prefix length, address suffix and prefix name fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataA6.Equals(System.Object)">
            <summary>
            Two A6 resource datas are equal iff their prefix length, address suffix and prefix name fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataA6.GetHashCode">
            <summary>
            The combined hash code of the prefix length, address suffix and prefix name fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataA6.PrefixLength">
            <summary>
            Encoded as an eight-bit unsigned integer with value between 0 and 128 inclusive.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataA6.AddressSuffix">
            <summary>
            An IPv6 address suffix, encoded in network order (high-order octet first).
            There must be exactly enough octets in this field to contain a number of bits equal to 128 minus prefix length, 
            with 0 to 7 leading pad bits to make this field an integral number of octets.
            Pad bits, if present, must be set to zero when loading a zone file and ignored (other than for SIG verification) on reception.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataA6.AddressSuffixLength">
            <summary>
            The number of bytes the address suffix takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataA6.PrefixName">
            <summary>
            The name of the prefix, encoded as a domain name.
            This name must not be compressed.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsGatewayNone">
            <summary>
            A gateway representation that represents that no gateway is present.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayNone.Equals(PcapDotNet.Packets.Dns.DnsGatewayNone)">
            <summary>
            Two DnsGatewayNone are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayNone.Equals(PcapDotNet.Packets.Dns.DnsGateway)">
            <summary>
            Two gateway representations are equal if they are of the same type and the value is the same.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayNone.GatewayType">
            <summary>
            The gateway represnetation type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayNone.Length">
            <summary>
            The number of bytes the gateway represnetation takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsAfsDatabaseSubtype">
            <summary>
            RFC 1183.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAfsDatabaseSubtype.None">
            <summary>
            An invalid value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAfsDatabaseSubtype.AfsCell">
            <summary>
            The host has an AFS version 3.0 Volume Location Server for the named AFS cell.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAfsDatabaseSubtype.DceNcaCell">
            <summary>
            The host has an authenticated name server holding the cell-root directory node for the named DCE/NCA cell.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsDatagram">
            <summary>
            RFC 1035, 4035.
            All communications inside of the domain protocol are carried in a single format called a message. 
            The top level format of message is divided into 5 sections (some of which are empty in certain cases) shown below:
            <pre>
            +-----+----+--------+----+----+----+----+---+----+----+-------+
            | bit | 0  | 1-4    | 5  | 6  | 7  | 8  | 9 | 10 | 11 | 12-15 |
            +-----+----+--------+----+----+----+----+---+----+----+-------+
            | 0   | ID                                                    |
            +-----+----+--------+----+----+----+----+---+----+----+-------+
            | 16  | QR | Opcode | AA | TC | RD | RA | Z | AD | CD | RCODE |
            +-----+----+--------+----+----+----+----+---+----+----+-------+
            | 32  | QDCOUNT                                               |
            +-----+-------------------------------------------------------+
            | 48  | ANCOUNT                                               |
            +-----+-------------------------------------------------------+
            | 64  | NSCOUNT                                               |
            +-----+-------------------------------------------------------+
            | 80  | ARCOUNT                                               |
            +-----+-------------------------------------------------------+
            | 96  | Question - the question for the name server           |
            +-----+-------------------------------------------------------+
            |     | Answer - RRs answering the question                   |
            +-----+-------------------------------------------------------+
            |     | Authority - RRs pointing toward an authority          |
            +-----+-------------------------------------------------------+
            |     | Additional - RRs holding additional information       |
            +-----+-------------------------------------------------------+
            </pre>
            The header section is always present.  
            The header includes fields that specify which of the remaining sections are present, 
            and also specify whether the message is a query or a response, a standard query or some other opcode, etc.
            The names of the sections after the header are derived from their use in standard queries.  
            The question section contains fields that describe a question to a name server.  
            These fields are a query type (QTYPE), a query class (QCLASS), and a query domain name (QNAME).  
            The last three sections have the same format: a possibly empty list of concatenated resource records (RRs).  
            The answer section contains RRs that answer the question; the authority section contains RRs that point toward an authoritative name server; 
            the additional records section contains RRs which relate to the query, but are not strictly answers for the question.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDatagram.HeaderLength">
            <summary>
            The number of bytes the DNS header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsDatagram.CalculateIsValid">
            <summary>
            A DNS datagram is valid if parsing of all sections was successful.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.Id">
            <summary>
            A 16 bit identifier assigned by the program that generates any kind of query.  
            This identifier is copied the corresponding reply and can be used by the requester to match up replies to outstanding queries.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsResponse">
            <summary>
            A one bit field that specifies whether this message is a query (0), or a response (1).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsQuery">
            <summary>
            Specifies whether this message is a query or a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.OpCode">
            <summary>
            Specifies kind of query in this message.  
            This value is set by the originator of a query and copied into the response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsAuthoritativeAnswer">
            <summary>
            This bit is valid in responses, and specifies that the responding name server is an authority for the domain name in question section.
            Note that the contents of the answer section may have multiple owner names because of aliases.  
            The AA bit corresponds to the name which matches the query name, or the first owner name in the answer section.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsTruncated">
            <summary>
            Specifies that this message was truncated due to length greater than that permitted on the transmission channel.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsRecursionDesired">
            <summary>
            This bit may be set in a query and is copied into the response.  
            If RD is set, it directs the name server to pursue the query recursively. 
            Recursive query support is optional.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsRecursionAvailable">
            <summary>
            This bit is set or cleared in a response, and denotes whether recursive query support is available in the name server.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.FutureUse">
            <summary>
            Reserved for future use.  
            Must be false in all queries and responses.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsAuthenticData">
            <summary>
            The name server side of a security-aware recursive name server must not set the AD bit in a response
            unless the name server considers all RRsets in the Answer and Authority sections of the response to be authentic.
            The name server side should set the AD bit if and only if the resolver side considers all RRsets in the Answer section
            and any relevant negative response RRs in the Authority section to be authentic.
            The resolver side must follow the Authenticating DNS Responses procedure to determine whether the RRs in question are authentic.
            However, for backward compatibility, a recursive name server may set the AD bit when a response includes unsigned CNAME RRs
            if those CNAME RRs demonstrably could have been synthesized from an authentic DNAME RR that is also included in the response
            according to the synthesis rules described in RFC 2672.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.IsCheckingDisabled">
            <summary>
            Exists in order to allow a security-aware resolver to disable signature validation
            in a security-aware name server's processing of a particular query.
            
            The name server side must copy the setting of the CD bit from a query to the corresponding response.
            
            The name server side of a security-aware recursive name server must pass the state of the CD bit to the resolver side
            along with the rest of an initiating query,
            so that the resolver side will know whether it is required to verify the response data it returns to the name server side.
            If the CD bit is set, it indicates that the originating resolver is willing to perform whatever authentication its local policy requires.
            Thus, the resolver side of the recursive name server need not perform authentication on the RRsets in the response.
            When the CD bit is set, the recursive name server should, if possible, return the requested data to the originating resolver, 
            even if the recursive name server's local authentication policy would reject the records in question.
            That is, by setting the CD bit, the originating resolver has indicated that it takes responsibility for performing its own authentication,
            and the recursive name server should not interfere.
            
            If the resolver side implements a BAD cache and the name server side receives a query that matches an entry in the resolver side's BAD cache,
            the name server side's response depends on the state of the CD bit in the original query.
            If the CD bit is set, the name server side should return the data from the BAD cache;
            if the CD bit is not set, the name server side must return RCODE 2 (server failure).
            
            The intent of the above rule is to provide the raw data to clients that are capable of performing their own signature verification checks
            while protecting clients that depend on the resolver side of a security-aware recursive name server to perform such checks.
            Several of the possible reasons why signature validation might fail involve conditions
            that may not apply equally to the recursive name server and the client that invoked it.
            For example, the recursive name server's clock may be set incorrectly, or the client may have knowledge of a relevant island of security
            that the recursive name server does not share.
            In such cases, "protecting" a client that is capable of performing its own signature validation from ever seeing the "bad" data does not help the client.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.ResponseCode">
            <summary>
            A response of the server that can sign errors or other messages.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.QueryCount">
            <summary>
            An unsigned 16 bit integer specifying the number of entries in the question section.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.AnswerCount">
            <summary>
            An unsigned 16 bit integer specifying the number of resource records in the answer section.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.AuthorityCount">
            <summary>
            An unsigned 16 bit integer specifying the number of name server resource records in the authority records section.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.AdditionalCount">
            <summary>
            An unsigned 16 bit integer specifying the number of resource records in the additional records section.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.Queries">
            <summary>
            The queries resource records.
            The amount of records here should be equal to <see cref="P:PcapDotNet.Packets.Dns.DnsDatagram.QueryCount"/>.
            Typically exactly one query will exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.Answers">
            <summary>
            The answers resource records.
            The amount of records here should be equal to <see cref="P:PcapDotNet.Packets.Dns.DnsDatagram.AnswerCount"/>.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.Authorities">
            <summary>
            The authorities resource records.
            The amount of records here should be equal to <see cref="P:PcapDotNet.Packets.Dns.DnsDatagram.AuthorityCount"/>.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.Additionals">
            <summary>
            The additionals resource records.
            The amount of records here should be equal to <see cref="P:PcapDotNet.Packets.Dns.DnsDatagram.AdditionalCount"/>.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.ResourceRecords">
            <summary>
            All the resource records in the datagram by order of appearance.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.DataResourceRecords">
            <summary>
            All the data resource records (all resource records but the queries) in the datagram by order of appearance.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsDatagram.OptionsRecord">
            <summary>
            The special OPT resource record.
            This takes the first OPT resource record in additional section.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpOperation">
            <summary>
            Specifies the operation the ARP sender is performing.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.None">
            <summary>
            Invalid operation.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Request">
            <summary>
            [RFC826][RFC5227]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Reply">
            <summary>
            [RFC826][RFC5227]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.ReverseRequest">
            <summary>
            [RFC903]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.ReverseReply">
            <summary>
            [RFC903]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.DynamicReverseRequest">
            <summary>
            [RFC1931]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.DynamicReverseReply">
            <summary>
            [RFC1931]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.DynamicReverseError">
            <summary>
            [RFC1931]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.InverseRequest">
            <summary>
            [RFC1293]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.InverseReply">
            <summary>
            [RFC1293]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.NegativeAtmReply">
            <summary>
            [RFC1577]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.MultipleAccessOverSynchronousOpticalNetworkingOrSynchronousDigitalHierarchyUnsolicitedArp">
            <summary>
            [RFC2176]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Experimental1">
            <summary>
            [RFC5494]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Experimental2">
            <summary>
            [RFC5494]
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew">
            <summary>
            CC.NEW Option (RFC 1644).
            <pre>
            +--------+--------+--------+--------+--------+--------+
            |00001100|00000110|    Connection Count:  SEG.CC      |
            +--------+--------+--------+--------+--------+--------+
             Kind=12  Length=6
            </pre>
            
            <para>
            This option may be sent instead of a CC option in an initial &lt;SYN&gt; segment (i.e., SYN but not ACK bit), 
            to indicate that the SEG.CC value may not be larger than the previous value.  
            Its SEG.CC value is the TCB.CCsend value from the sender's TCB.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase">
            <summary>
            The base class for connection count TCP options.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.Equals(PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase)">
            <summary>
            Two connection count options are equal of they are of the same option type and have the same connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two connection count options are equal of they are of the same option type and have the same connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.GetHashCode">
            <summary>
            The hash code of the connection count option is the hash code of the option type xored with the hash code of the connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.#ctor(PcapDotNet.Packets.Transport.TcpOptionType,System.UInt32)">
            <summary>
            Creates a connection count option according to the given option type and given connection count value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.TryRead(System.UInt32@,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Reads the connection count value from the buffer.
            </summary>
            <param name="connectionCount">The result connection count.</param>
            <param name="buffer">The buffer to read the connection count from.</param>
            <param name="offset">The offset to start reading the connection byte from.</param>
            <param name="valueLength">The number of bytes available for read in this buffer.</param>
            <returns>True iff the connection count could be read (there were enough bytes to read).</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.ConnectionCount">
            <summary>
            The connection count value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given connection count value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew.#ctor">
            <summary>
            The default connection count value is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho">
            <summary>
            CC.ECHO Option (RFC 1644).
            <pre>
            +--------+--------+--------+--------+--------+--------+
            |00001101|00000110|    Connection Count:  SEG.CC      |
            +--------+--------+--------+--------+--------+--------+
             Kind=13  Length=6
            </pre>
            
            <para>
            This option must be sent (in addition to a CC option) in a segment containing both a SYN and an ACK bit, 
            if the initial SYN segment contained a CC or CC.NEW option.  
            Its SEG.CC value is the SEG.CC value from the initial SYN.
            </para>
            
            <para>
            A CC.ECHO option should be sent only in a &lt;SYN,ACK&gt; segment and should be ignored if it is received in any other segment.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given connection count value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho.#ctor">
            <summary>
            The default connection count value is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCount">
            <summary>
            CC Option (RFC 1644).
            <pre>
            +--------+--------+--------+--------+--------+--------+
            |00001011|00000110|    Connection Count:  SEG.CC      |
            +--------+--------+--------+--------+--------+--------+
             Kind=11  Length=6
            </pre>
            
            <para>
            This option may be sent in an initial SYN segment, and it may be sent in other segments if a CC or CC.NEW option 
            has been received for this incarnation of the connection.  
            Its SEG.CC value is the TCB.CCsend value from the sender's TCB.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCount.#ctor(System.UInt32)">
            <summary>
            Create a connection count tcp option by a given connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCount.#ctor">
            <summary>
            The default connection count is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCount.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpLayer">
            <summary>
            RFC 793.
            Represents the TCP layer.
            <seealso cref="T:PcapDotNet.Packets.Transport.TcpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.#ctor">
            <summary>
            Default constructor.
            No TCP options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.EqualFields(PcapDotNet.Packets.Transport.TransportLayer)">
            <summary>
            True iff the SequenceNumber, AcknowledgmentNumber, ControlBits, Window, UrgentPointer and Options fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.EqualFields(PcapDotNet.Packets.Transport.TcpLayer)">
            <summary>
            True iff the SequenceNumber, AcknowledgmentNumber, ControlBits, Window, UrgentPointer and Options fields are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.SequenceNumber">
            <summary>
            The sequence number of the first data octet in this segment (except when SYN is present). 
            If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.AcknowledgmentNumber">
            <summary>
            If the ACK control bit is set this field contains the value of the next sequence number 
            the sender of the segment is expecting to receive.  
            Once a connection is established this is always sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.ControlBits">
            <summary>
            A collection of bits for the TCP control.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.Window">
            <summary>
            The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.UrgentPointer">
            <summary>
            This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
            The urgent pointer points to the sequence number of the octet following the urgent data.  
            This field is only be interpreted in segments with the URG control bit set.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.Options">
            <summary>
            The TCP options contained in this TCP Datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert">
            <summary>
            The Router Alert option has the semantic "routers should examine this packet more closely".  
            By including the Router Alert option in the IP header of its protocol message, 
            RSVP can cause the message to be intercepted while causing little or no performance 
            penalty on the forwarding of normal data packets.
            
            <para>
            Routers that support option processing in the fast path already demultiplex processing based on the option type field.  
            If all option types are supported in the fast path, then the addition of another option type to process is unlikely to impact performance.  
            If some option types are not supported in the fast path, 
            this new option type will be unrecognized and cause packets carrying it to be kicked out into the slow path, 
            so no change to the fast path is necessary, and no performance penalty will be incurred for regular data packets.
            </para>
            
            <para>
            Routers that do not support option processing in the fast path will cause packets carrying this new option 
            to be forwarded through the slow path, so no change to the fast path is necessary and no performance penalty 
            will be incurred for regular data packets.
            </para>
            
            <para>
            The Router Alert option has the following format:
            <pre>
            +--------+--------+--------+--------+
            |10010100|00000100|  2 octet value  |
            +--------+--------+--------+--------+
            </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.OptionValueLength">
            <summary>
            The number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.#ctor(System.UInt16)">
            <summary>
            Create the option according to the given value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.#ctor">
            <summary>
            Creates a 0 value router alert option
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Equals(PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.GetHashCode">
            <summary>
            The hash code value is the xor of the base class hash code and the value hash code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Value">
            <summary>
            The value of the alert.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.NetUnreachable">
            <summary>
            If, according to the information in the gateway's routing tables, 
            the network specified in the internet destination field of a datagram is unreachable, 
            e.g., the distance to the network is infinity, 
            the gateway may send a destination unreachable message to the internet source host of the datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.HostUnreachable">
            <summary>
            RFC 792.
            In some networks, the gateway may be able to determine if the internet destination host is unreachable.  
            Gateways in these networks may send destination unreachable messages to the source host when the destination host is unreachable.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.ProtocolUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated protocol module is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.PortUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated process port is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.FragmentationNeededAndDoNotFragmentSet">
            <summary>
            RFC 792.
            A datagram must be fragmented to be forwarded by a gateway yet the Don't Fragment flag is on.  
            In this case the gateway must discard the datagram and may return a destination unreachable message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.SourceRouteFailed">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsSecNSec3HashAlgorithm">
            <summary>
            RFC 5155.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSecNSec3HashAlgorithm.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSecNSec3HashAlgorithm.Sha1">
            <summary>
            RFC 5155.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey">
            <summary>
            RFC 2930.
            <pre>
            +------+------------+------------+
            | bit  | 0-15       | 16-31      |
            +------+------------+------------+
            | 0    | Algorithm               |
            | ...  |                         |
            +------+-------------------------+
            | X    | Inception               |
            +------+-------------------------+
            | X+32 | Expiration              |
            +------+------------+------------+
            | X+64 | Mode       | Error      |
            +------+------------+------------+
            | X+96 | Key Size   |            |
            +------+------------+ Key Data   |
            | ...  |                         |
            +------+------------+------------+
            |      | Other Size |            |
            +------+------------+ Other Data |
            | ...  |                         |
            +------+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Base.SerialNumber32,PcapDotNet.Base.SerialNumber32,PcapDotNet.Packets.Dns.DnsTransactionKeyMode,PcapDotNet.Packets.Dns.DnsResponseCode,PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the algorithm, inception, expiration, mode, error, key and other fields.
            </summary>
            <param name="algorithm">
            Name of the algorithm in domain name syntax.
            The algorithm determines how the secret keying material agreed to using the TKEY RR is actually used to derive the algorithm specific key.
            </param>
            <param name="inception">
            Number of seconds since the beginning of 1 January 1970 GMT ignoring leap seconds treated as modulo 2**32 using ring arithmetic.
            In messages between a DNS resolver and a DNS server where this field is meaningful,
            it is either the requested validity interval start for the keying material asked for or
            specify the validity interval start of keying material provided.
            
            To avoid different interpretations of the inception time in TKEY RRs,
            resolvers and servers exchanging them must have the same idea of what time it is.
            One way of doing this is with the NTP protocol [RFC 2030] but that or any other time synchronization used for this purpose must be done securely.
            </param>
            <param name="expiration">
            Number of seconds since the beginning of 1 January 1970 GMT ignoring leap seconds treated as modulo 2**32 using ring arithmetic.
            In messages between a DNS resolver and a DNS server where this field is meaningful,
            it is either the requested validity interval end for the keying material asked for or
            specify the validity interval end of keying material provided.
            
            To avoid different interpretations of the expiration time in TKEY RRs,
            resolvers and servers exchanging them must have the same idea of what time it is.
            One way of doing this is with the NTP protocol [RFC 2030] but that or any other time synchronization used for this purpose must be done securely.
            </param>
            <param name="mode">
            Specifies the general scheme for key agreement or the purpose of the TKEY DNS message.
            Servers and resolvers supporting this specification must implement the Diffie-Hellman key agreement mode and the key deletion mode for queries.
            All other modes are optional.
            A server supporting TKEY that receives a TKEY request with a mode it does not support returns the BADMODE error.
            </param>
            <param name="error">
            When the TKEY Error Field is non-zero in a response to a TKEY query, the DNS header RCODE field indicates no error.
            However, it is possible if a TKEY is spontaneously included in a response the TKEY RR and DNS header error field 
            could have unrelated non-zero error codes.
            </param>
            <param name="key">The key exchange data. The meaning of this data depends on the mode.</param>
            <param name="other">May be used in future extensions.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Equals(PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey)">
            <summary>
            Two DnsResourceDataTransactionKey are equal iff their algorithm, inception, expiration, mode, error, key and other fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Equals(System.Object)">
            <summary>
            Two DnsResourceDataTransactionKey are equal iff their algorithm, inception, expiration, mode, error, key and other fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.GetHashCode">
            <summary>
            A hash code of the combination of the algorithm, inception, expiration, mode, error, key and other fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Algorithm">
            <summary>
            Name of the algorithm in domain name syntax.
            The algorithm determines how the secret keying material agreed to using the TKEY RR is actually used to derive the algorithm specific key.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Inception">
            <summary>
            Number of seconds since the beginning of 1 January 1970 GMT ignoring leap seconds treated as modulo 2**32 using ring arithmetic.
            In messages between a DNS resolver and a DNS server where this field is meaningful,
            it is either the requested validity interval start for the keying material asked for or
            specify the validity interval start of keying material provided.
            
            To avoid different interpretations of the inception time in TKEY RRs,
            resolvers and servers exchanging them must have the same idea of what time it is.
            One way of doing this is with the NTP protocol [RFC 2030] but that or any other time synchronization used for this purpose must be done securely.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Expiration">
            <summary>
            Number of seconds since the beginning of 1 January 1970 GMT ignoring leap seconds treated as modulo 2**32 using ring arithmetic.
            In messages between a DNS resolver and a DNS server where this field is meaningful,
            it is either the requested validity interval end for the keying material asked for or
            specify the validity interval end of keying material provided.
            
            To avoid different interpretations of the expiration time in TKEY RRs,
            resolvers and servers exchanging them must have the same idea of what time it is.
            One way of doing this is with the NTP protocol [RFC 2030] but that or any other time synchronization used for this purpose must be done securely.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Mode">
            <summary>
            Specifies the general scheme for key agreement or the purpose of the TKEY DNS message.
            Servers and resolvers supporting this specification must implement the Diffie-Hellman key agreement mode and the key deletion mode for queries.
            All other modes are optional.
            A server supporting TKEY that receives a TKEY request with a mode it does not support returns the BADMODE error.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Error">
            <summary>
            When the TKEY Error Field is non-zero in a response to a TKEY query, the DNS header RCODE field indicates no error.
            However, it is possible if a TKEY is spontaneously included in a response the TKEY RR and DNS header error field 
            could have unrelated non-zero error codes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Key">
            <summary>
            The key exchange data.
            The meaning of this data depends on the mode.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTransactionKey.Other">
            <summary>
            May be used in future extensions.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataStrings">
            <summary>
            Base class for any resource data that contains DNS strings.
            Each DNS string is a segment of up to 255 bytes.
            The format of each DNS string is one byte for the length of the string and then the specified number of bytes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataStrings.Equals(PcapDotNet.Packets.Dns.DnsResourceDataStrings)">
            <summary>
            Two strings resources datas are equal if they are of the same concrete type and their strings are equal and in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataStrings.Equals(System.Object)">
            <summary>
            Two strings resources datas are equal if they are of the same concrete type and their strings are equal and in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataStrings.GetHashCode">
            <summary>
            A hash code based on the concrete type and the strings.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection">
            <summary>
            RFC 2782.
            <pre>
            +-----+----------+
            | bit | 0-15     |
            +-----+----------+
            | 0   | Priority |
            +-----+----------+
            | 16  | Weight   |
            +-----+----------+
            | 32  | Port     |
            +-----+----------+
            | 48  | Target   |
            | ... |          |
            +-----+----------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.#ctor(System.UInt16,System.UInt16,System.UInt16,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs an instance out of the priority, weight, port and target fields.
            </summary>
            <param name="priority">
            The priority of this target host.
            A client must attempt to contact the target host with the lowest-numbered priority it can reach; 
            target hosts with the same priority should be tried in an order defined by the weight field.
            </param>
            <param name="weight">
            A server selection mechanism.
            The weight field specifies a relative weight for entries with the same priority.
            Larger weights should be given a proportionately higher probability of being selected.
            Domain administrators should use Weight 0 when there isn't any server selection to do, to make the RR easier to read for humans (less noisy).
            In the presence of records containing weights greater than 0, records with weight 0 should have a very small chance of being selected.
            
            In the absence of a protocol whose specification calls for the use of other weighting information, a client arranges the SRV RRs of the same Priority in the order in which target hosts,
            specified by the SRV RRs, will be contacted. 
            The following algorithm SHOULD be used to order the SRV RRs of the same priority:
            To select a target to be contacted next, arrange all SRV RRs (that have not been ordered yet) in any order, except that all those with weight 0 are placed at the beginning of the list.
            Compute the sum of the weights of those RRs, and with each RR associate the running sum in the selected order.
            Then choose a uniform random number between 0 and the sum computed (inclusive), and select the RR whose running sum value is the first in the selected order which is greater than or equal to the random number selected.
            The target host specified in the selected SRV RR is the next one to be contacted by the client.
            Remove this SRV RR from the set of the unordered SRV RRs and apply the described algorithm to the unordered SRV RRs to select the next target host.
            Continue the ordering process until there are no unordered SRV RRs.
            This process is repeated for each Priority.
            </param>
            <param name="port">The port on this target host of this service. This is often as specified in Assigned Numbers but need not be.</param>
            <param name="target">
            The domain name of the target host.
            There must be one or more address records for this name, the name must not be an alias (in the sense of RFC 1034 or RFC 2181).
            Implementors are urged, but not required, to return the address record(s) in the Additional Data section.
            Unless and until permitted by future standards action, name compression is not to be used for this field.
            
            A Target of "." means that the service is decidedly not available at this domain.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.Equals(PcapDotNet.Packets.Dns.DnsResourceDataServerSelection)">
            <summary>
            Two DnsResourceDataServerSelection are equal iff their priority, weight, port and target fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.Equals(System.Object)">
            <summary>
            Two DnsResourceDataServerSelection are equal iff their priority, weight, port and target fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.GetHashCode">
            <summary>
            A hash code of the combination of the priority, weight, port and target fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.Priority">
            <summary>
            The priority of this target host.
            A client must attempt to contact the target host with the lowest-numbered priority it can reach; 
            target hosts with the same priority should be tried in an order defined by the weight field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.Weight">
            <summary>
            A server selection mechanism.
            The weight field specifies a relative weight for entries with the same priority.
            Larger weights should be given a proportionately higher probability of being selected.
            Domain administrators should use Weight 0 when there isn't any server selection to do, to make the RR easier to read for humans (less noisy).
            In the presence of records containing weights greater than 0, records with weight 0 should have a very small chance of being selected.
            
            In the absence of a protocol whose specification calls for the use of other weighting information, a client arranges the SRV RRs of the same Priority in the order in which target hosts,
            specified by the SRV RRs, will be contacted. 
            The following algorithm SHOULD be used to order the SRV RRs of the same priority:
            To select a target to be contacted next, arrange all SRV RRs (that have not been ordered yet) in any order, except that all those with weight 0 are placed at the beginning of the list.
            Compute the sum of the weights of those RRs, and with each RR associate the running sum in the selected order.
            Then choose a uniform random number between 0 and the sum computed (inclusive), and select the RR whose running sum value is the first in the selected order which is greater than or equal to the random number selected.
            The target host specified in the selected SRV RR is the next one to be contacted by the client.
            Remove this SRV RR from the set of the unordered SRV RRs and apply the described algorithm to the unordered SRV RRs to select the next target host.
            Continue the ordering process until there are no unordered SRV RRs.
            This process is repeated for each Priority.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.Port">
            <summary>
            The port on this target host of this service. 
            This is often as specified in Assigned Numbers but need not be.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataServerSelection.Target">
            <summary>
            The domain name of the target host.
            There must be one or more address records for this name, the name must not be an alias (in the sense of RFC 1034 or RFC 2181).
            Implementors are urged, but not required, to return the address record(s) in the Additional Data section.
            Unless and until permitted by future standards action, name compression is not to be used for this field.
            
            A Target of "." means that the service is decidedly not available at this domain.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataRouteThrough">
            <summary>
            RFC 1183.
            <pre>
            +-----+-------------------+
            | bit | 0-15              |
            +-----+-------------------+
            | 0   | preference        |
            +-----+-------------------+
            | 16  | intermediate-host |
            | ... |                   |
            +-----+-------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataRouteThrough.#ctor(System.UInt16,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs a route through resource data from the given preference and intermediate host.
            </summary>
            <param name="preference">
            Representing the preference of the route.
            Smaller numbers indicate more preferred routes.
            </param>
            <param name="intermediateHost">
            The domain name of a host which will serve as an intermediate in reaching the host specified by the owner.
            The DNS RRs associated with IntermediateHost are expected to include at least one A, X25, or ISDN record.
            </param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataRouteThrough.Preference">
            <summary>
            Representing the preference of the route.
            Smaller numbers indicate more preferred routes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataRouteThrough.IntermediateHost">
            <summary>
            The domain name of a host which will serve as an intermediate in reaching the host specified by the owner.
            The DNS RRs associated with IntermediateHost are expected to include at least one A, X25, or ISDN record.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataKeyExchanger">
            <summary>
            RFC 2230.
            <pre>
            +-----+-------------------+
            | bit | 0-15              |
            +-----+-------------------+
            | 0   | PREFERENCE        |
            +-----+-------------------+
            | 16  | EXCHANGER         |
            | ... |                   |
            +-----+-------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataKeyExchanger.#ctor(System.UInt16,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs a key exchanger resource data from the given preference and key exchanger domain.
            </summary>
            <param name="preference">
            Specifies the preference given to this RR among other KX records at the same owner.
            Lower values are preferred.
            </param>
            <param name="keyExchanger">
            Specifies a host willing to act as a key exchange for the owner name.
            </param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKeyExchanger.Preference">
            <summary>
            Specifies the preference given to this RR among other KX records at the same owner.
            Lower values are preferred.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataKeyExchanger.KeyExchangeHost">
            <summary>
            Specifies a host willing to act as a key exchange for the owner name.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization">
            <summary>
            Hallam-Baker.
            <pre>
            +-----+----------+----------+------------+
            | bit | 0        | 1-7      | 8-15       |
            +-----+----------+----------+------------+
            | 0   | Critical | Reserved | Tag Length |
            +-----+----------+----------+------------+
            | 16  | Tag                              |
            | ... |                                  |
            +-----+----------------------------------+
            | ... | Value                            |
            +-----+----------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization.#ctor(PcapDotNet.Packets.Dns.DnsCertificationAuthorityAuthorizationFlags,PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the flags, tag and value fields.
            </summary>
            <param name="flags">Flags of the record.</param>
            <param name="tag">
            The property identifier, a sequence of ASCII characters.
            Tag values may contain ASCII characters a through z and the numbers 0 through 9.
            Tag values must not contain any other characters.
            Matching of tag values is case insensitive.
            </param>
            <param name="value">Represents the property value. Property values are encoded as binary values and may employ sub-formats.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization.Equals(PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization)">
            <summary>
            Two DnsResourceDataCertificationAuthorityAuthorization are equal iff their flags, tag and value fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization.Equals(System.Object)">
            <summary>
            Two DnsResourceDataCertificationAuthorityAuthorization are equal iff their flags, tag and value fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization.GetHashCode">
            <summary>
            A hash code of the combination of the flags, tag and value fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization.Flags">
            <summary>
            Flags of the record.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization.Tag">
            <summary>
            The property identifier, a sequence of ASCII characters.
            Tag values may contain ASCII characters a through z and the numbers 0 through 9.
            Tag values must not contain any other characters.
            Matching of tag values is case insensitive.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataCertificationAuthorityAuthorization.Value">
            <summary>
            Represents the property value.
            Property values are encoded as binary values and may employ sub-formats.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptions">
            <summary>
            RFC 2671.
            A set of options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptions.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.Dns.DnsOption})">
            <summary>
            Constructs options from the given list of options.
            The given otpions list should be modified after the call to this constructor.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptions.#ctor(PcapDotNet.Packets.Dns.DnsOption[])">
            <summary>
            Constructs options from the given list of options.
            The given otpions list should be modified after the call to this constructor.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptions.Equals(PcapDotNet.Packets.Dns.DnsOptions)">
            <summary>
            Two options objects are equal if they have the same options in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptions.Equals(System.Object)">
            <summary>
            Two options objects are equal if they have the same options in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsOptions.GetHashCode">
            <summary>
            A hash code based on the list of options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptions.None">
            <summary>
            Empty options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptions.Options">
            <summary>
            The list of options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsOptions.BytesLength">
            <summary>
            The total number of bytes the options take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode">
            <summary>
            The DNS LLQ Error code values.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode.NoError">
            <summary>
            The LLQ Setup Request was successful.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode.ServerFull">
            <summary>
            The server cannot grant the LLQ request because it is overloaded,
            or the request exceeds the server's rate limit (see Section 8 "Security Considerations").
            Upon returning this error, the server MUST include in the LEASE-LIFE field a time interval, in seconds,
            after which the client may re-try the LLQ Setup.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode.Static">
            <summary>
            The data for this name and type is not expected to change frequently, and the server therefore does not support the requested LLQ.
            The client must not poll for this name and type, nor should it re-try the LLQ Setup, and should instead honor the normal resource record TTLs returned.
            To reduce server load, an administrator MAY return this error for all records with types other than PTR and TXT as a matter of course.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode.FormatError">
            <summary>
            The LLQ was improperly formatted.
            Note that if the rest of the DNS message is properly formatted, the DNS header error code must not include a format error code,
             as this would cause confusion between a server that does not understand the LLQ format, and a client that sends malformed LLQs.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode.NoSuchLlq">
            <summary>
            The client attempts to refresh an expired or non-existent LLQ (as determined by the LLQ-ID in the request).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode.BadVersion">
            <summary>
            The protocol version specified in the client's request is not supported by the server.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryErrorCode.UnknownError">
            <summary>
            The LLQ was not granted for an unknown reason.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsGatewayIpV4">
            <summary>
            Represents an IPv4 gateway to which an IPsec tunnel may be created in order to reach the entity named by an IPsec resource record.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayIpV4.#ctor(PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Creates a gateway using the given IPv4 address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayIpV4.Equals(PcapDotNet.Packets.Dns.DnsGatewayIpV4)">
            <summary>
            Two DnsGatewayIpV4 are equal if their IPv4 addresses are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayIpV4.Equals(PcapDotNet.Packets.Dns.DnsGateway)">
            <summary>
            Two gateway representations are equal if they are of the same type and the value is the same.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayIpV4.Value">
            <summary>
            The IPv4 address value of the gateway.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayIpV4.GatewayType">
            <summary>
            The gateway represnetation type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayIpV4.Length">
            <summary>
            The number of bytes the gateway represnetation takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsDigestType">
            <summary>
            The type of digest that is used to create a digest value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDigestType.None">
            <summary>
            No definition for digest type.
            Should not be used.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDigestType.Sha1">
            <summary>
            RFC 3658.
            SHA-1.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDigestType.Sha256">
            <summary>
            RFC 4509.
            SHA-256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsDigestType.GostR341194">
            <summary>
            RFC 5933.
            GOST R 34.11-94.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptions">
            <summary>
            A collection of TCP options.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptions.MaximumBytesLength">
            <summary>
            The maximum number of bytes the options can take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptions.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.Transport.TcpOption})">
            <summary>
            Creates the options collection from the given list of options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptions.#ctor(PcapDotNet.Packets.Transport.TcpOption[])">
            <summary>
            Creates options from a list of options.
            </summary>
            <param name="options">The list of options.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptions.None">
            <summary>
            An empty options collection.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType">
            <summary>
            The type of the checksum to be used.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType.TcpChecksum">
            <summary>
            TCP checksum.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType.FletchersAlgorithm8Bit">
            <summary>
            8-bit Fletcher's algorithm.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType.FletchersAlgorithm16Bit">
            <summary>
            16-bit Fletcher's algorithm.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute">
            <summary>
            Record Route
            <pre>
            +--------+--------+--------+---------//--------+
            |00000111| length | pointer|     route data    |
            +--------+--------+--------+---------//--------+
             Type=7
            </pre>
            
            <para>
            The record route option provides a means to record the route of an internet datagram.
            </para>
            
            <para>
            The option begins with the option type code.  
            The second octet is the option length which includes the option type code and the length octet, 
            the pointer octet, and length-3 octets of route data.  
            The third octet is the pointer into the route data indicating the octet which begins the next area to store a route address.  
            The pointer is relative to this option, and the smallest legal value for the pointer is 4.
            </para>
            
            <para>
            A recorded route is composed of a series of internet addresses.
            Each internet address is 32 bits or 4 octets.  
            If the pointer is greater than the length, the recorded route data area is full.
            The originating host must compose this option with a large enough route data area to hold all the address expected.  
            The size of the option does not change due to adding addresses.  
            The intitial contents of the route data area must be zero.
            </para>
            
            <para>
            When an internet module routes a datagram it checks to see if the record route option is present.  
            If it is, it inserts its own internet address as known in the environment into which this datagram is being forwarded 
            into the recorded route begining at the octet indicated by the pointer, 
            and increments the pointer by four.
            </para>
            
            <para>
            If the route data area is already full (the pointer exceeds the length) 
            the datagram is forwarded without inserting the address into the recorded route.  
            If there is some room but not enough room for a full address to be inserted, 
            the original datagram is considered to be in error and is discarded.  
            In either case an ICMP parameter problem message may be sent to the source host.
            </para>
            
            <para>
            Not copied on fragmentation, goes in first fragment only.
            Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.#ctor(System.Byte,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address})">
            <summary>
            Constructs the option from the given values.
            </summary>
            <param name="route">The route addresses values.</param>
            <param name="pointedAddressIndex">The pointed index in the route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.#ctor(System.Byte,PcapDotNet.Packets.IpV4.IpV4Address[])">
            <summary>
            Constructs the option from the given values.
            </summary>
            <param name="route">The route addresses values.</param>
            <param name="pointedAddressIndex">The pointed index in the route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.#ctor">
            <summary>
            Constructs an empty record route option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer">
            <summary>
            RFC 3376.
            Represents an IGMP Report version 3 layer.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.#ctor">
            <summary>
            Creates an instance of an IGMP Report Version 3 Layer with a default of no Group Records.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.GetHashCode">
            <summary>
            Xor of the hash codes of the layer length, datalink, message type, query version and the group records.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the group records are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer)">
            <summary>
            true iff the group records are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.GroupRecords">
            <summary>
            Each Group Record is a block of fields containing information pertaining to the sender's membership in a single multicast group on the interface from which the Report is sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoReplyLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpEchoReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyDatagram">
            <summary>
            RFC 950.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Address Mask                  |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram">
            <summary>
            RFC 950.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Address Mask                  |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.DatagramLength">
            <summary>
            The number of bytes this Datagram should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.PayloadLength">
            <summary>
            The number of bytes this ICMP payload should take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.CalculateIsValid">
            <summary>
            ICMP is valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.AddressMask">
            <summary>
            A 32-bit mask.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpTransferEncodingField">
            <summary>
            RFC 2616.
            The Transfer-Encoding general-header field indicates what (if any) type of transformation has been applied to the message body 
            in order to safely transfer it between the sender and the recipient. 
            This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity.
            
            <pre>
            Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding
            </pre>
            
            Example:
            
            <pre>
            Transfer-Encoding: chunked
            </pre>
            
            If multiple encodings have been applied to an entity, the transfer-codings MUST be listed in the order in which they were applied.
            Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpTransferEncodingField.FieldName">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpTransferEncodingField.FieldNameUpper">
            <summary>
            The field name in uppercase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.#ctor(System.Collections.Generic.IList{System.String})">
            <summary>
            Creates an HTTP transfer encoding field from a set of transfer codings.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.#ctor(System.String[])">
            <summary>
            Creates an HTTP transfer encoding field from a set of transfer codings.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.Equals(PcapDotNet.Packets.Http.HttpTransferEncodingField)">
            <summary>
            True iff the two HTTP transfer encoding fields are of equal value.
            Two HTTP transfer encoding fields are equal iff they have the same transfer codings.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.Equals(PcapDotNet.Packets.Http.HttpField)">
            <summary>
            True iff the two HTTP transfer encoding fields are of equal value.
            Two HTTP transfer encoding fields are equal iff they have the same transfer codings.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpTransferEncodingField.TransferCodings">
            <summary>
            Transfer-coding values are used to indicate an encoding transformation that has been, can be, 
            or may need to be applied to an entity-body in order to ensure "safe transport" through the network.
            This differs from a content coding in that the transfer-coding is a property of the message, not of the original entity.
            
            <pre>
            transfer-coding         = "chunked" | transfer-extension
            transfer-extension      = token *( ";" parameter )
            </pre>
            
            Parameters are in the form of attribute/value pairs.
            
            <pre>
            parameter               = attribute "=" value
            attribute               = token
            value                   = token | quoted-string
            </pre>
            
            All transfer-coding values are case-insensitive. 
            Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include "chunked", 
            unless the message is terminated by closing the connection. 
            When the "chunked" transfer-coding is used, it MUST be the last transfer-coding applied to the message-body. 
            The "chunked" transfer-coding MUST NOT be applied more than once to a message-body. 
            These rules allow the recipient to determine the transfer-length of the message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestKnownMethod">
            <summary>
            Known HTTP request method.
            RFC 2616.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Options">
            <summary>
            RFC 2616.
            <para>
            The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. 
            This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.
            </para>
            <para>
            Responses to this method are not cacheable.
            </para>
            <para>
            If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), 
            then the media type MUST be indicated by a Content-Type field. 
            Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server. 
            A server that does not support such an extension MAY discard the request body. 
            </para>
            <para>
            If the Request-URI is an asterisk ("*"), the OPTIONS request is intended to apply to the server in general rather than to a specific resource. 
            Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; 
            it does nothing beyond allowing the client to test the capabilities of the server. 
            For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof).
            </para>
            <para>
            If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource.
            </para>
            <para>
            A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), 
            possibly including extensions not defined by this specification. 
            The response body, if any, SHOULD also include information about the communication options. 
            The format for such a body is not defined by this specification, but might be defined by future extensions to HTTP. 
            Content negotiation MAY be used to select the appropriate response format. If no response body is included, the response MUST include a Content-Length field with a field-value of "0".
            </para>
            <para>
            The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain. 
            When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field. 
            If the Max-Forwards field-value is zero ("0"), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options.
            If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request. 
            If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Get">
            <summary>
            RFC 2616.
            <para>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. 
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process,
            unless that text happens to be the output of the process.
            </para>
            <para>
            The semantics of the GET method change to a "conditional GET" if the request message includes an If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. 
            A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s). 
            The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client.
            </para>
            <para>
            The semantics of the GET method change to a "partial GET" if the request message includes a Range header field. 
            A partial GET requests that only part of the entity be transferred.
            The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client.
            </para>
            <para>
            The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Head">
            <summary>
            RFC 2616.
            <para>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. 
            This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. 
            This method is often used for testing hypertext links for validity, accessibility, and recent modification.
            </para>
            <para>
            The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource. 
            If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), 
            then the cache MUST treat the cache entry as stale.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Post">
            <summary>
            RFC 2616.
            <para>
            The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. 
            POST is designed to allow a uniform method to cover the following functions: 
            <list type="bullet">
              <item>Annotation of existing resources;</item>
              <item>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</item>
              <item>Providing a block of data, such as the result of submitting a form, to a data-handling process;</item>
              <item>Extending a database through an append operation.</item>
            </list>
            </para>
            <para>
            The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. 
            The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, 
            a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
            </para>
            <para>
            The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status,
            depending on whether or not the response includes an entity that describes the result.
            </para>
            <para>
            If a resource has been created on the origin server, 
            the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.
            </para>
            <para>
            Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. 
            However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource.
            </para>
            <para>
            POST requests MUST obey the message transmission requirements.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Put">
            <summary>
            RFC 2616.
            <para>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI. 
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. 
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. 
            If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. 
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. 
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. 
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </para>
            <para>
            If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. 
            Responses to this method are not cacheable.
            </para>
            <para>
            The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. 
            The URI in a POST request identifies the resource that will handle the enclosed entity. 
            That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. 
             In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.
            If the server desires that the request be applied to a different URI, it MUST send a 301 (Moved Permanently) response; 
            the user agent MAY then make its own decision regarding whether or not to redirect the request.
            </para>
            <para>
            A single resource MAY be identified by many different URIs. 
            For example, an article might have a URI for identifying "the current version" which is separate from the URI identifying each particular version. 
            In this case, a PUT request on a general URI might result in several other URIs being defined by the origin server.
            </para>
            <para>
            HTTP/1.1 does not define how a PUT method affects the state of an origin server.
            </para>
            <para>
            PUT requests MUST obey the message transmission requirements.
            </para>
            <para>
            Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Delete">
            <summary>
            RFC 2616.
            <para>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI. 
            This method MAY be overridden by human intervention (or other means) on the origin server. 
            The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. 
            However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.
            </para>
            <para>
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, 
            or 204 (No Content) if the action has been enacted but the response does not include an entity.
            </para>
            <para>
            If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. 
            Responses to this method are not cacheable.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Trace">
            <summary>
            RFC 2616.
            <para>
            The TRACE method is used to invoke a remote, application-layer loop-back of the request message. 
            The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response. 
            The final recipient is either the origin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see section 14.31). 
            A TRACE request MUST NOT include an entity.
            </para>
            <para>
            TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. 
            The value of the Via header field is of particular interest, since it acts as a trace of the request chain.
            Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
            </para>
            <para>
            If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of "message/http". 
            Responses to this method MUST NOT be cached.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Connect">
            <summary>
            RFC 2616.
            <para>
            This specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g. SSL tunneling).
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Unknown">
            <summary>
            Unknown request method.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsSinkCoding">
            <summary>
            Eastlake.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.Asn1Snmp">
            <summary>
            The SNMP subset of ASN.1.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.Asn1Osi1990">
            <summary>
            OSI ASN.1 1990 [ASN.1].
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.Asn1Osi1994">
            <summary>
            OSI ASN.1 1994.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.AsnPrivate">
            <summary>
            Private abstract syntax notations.
            This coding value will not be assigned to a standard abstract syntax notation.
            An OSI Object Identifier (OID) preceded by a one byte unsigned length appears at the beginning of the data area to indicate which private abstract syntax is being used.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.DnsResourceRecords">
            <summary>
            DNS RRs.
            The data portion consists of DNS resource records as they would be transmitted in a DNS response section.
            The subcoding octet is the number of RRs in the data area as an unsigned integer.
            Domain names may be compressed via pointers as in DNS replies.
            The origin for the pointers is the beginning of the RDATA section of the SINK RR.
            Thus the SINK RR is safe to cache since only code that knows how to parse the data portion need know of and can expand these compressions.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.Mime">
            <summary>
            MIME structured data [RFC 2045, 2046].
            The data portion is a MIME structured message.
            The "MIME-Version:" header line may be omitted unless the version is other than "1.0".
            The top level Content-Transfer-Encoding may be encoded into the subcoding octet.
            Note that, to some extent, the size limitations of DNS RRs may be overcome in the MIME case by using the "Content-Type: message/external-body" mechanism.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.TextTaggedData">
            <summary>
            Text tagged data.
            The data potion consists of text formated as specified in the TXT RR except that the first and every subsequent odd numbered text item 
            is considered to be a tag labeling the immediately following text item.
            If there are an odd number of text items overall, then the last is considered to label a null text item.
            Syntax of the tags is as specified in RFC 1738 for the "Common Internet Scheme Syntax" without the two leading slashes ("//").
            Thus any organization with a domain name can assign tags without fear of conflict.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSinkCoding.PrivateByUrl">
            <summary>
            Private formats indicated by a URL.
            The format of the data portion is indicated by an initial URL [RFC 1738] which is terminated by a zero valued octet
            followed by the data with that format.
            The subcoding octet is available for whatever use the private formating wishes to make of it.
            The manner in which the URL specifies the format is not defined but presumably the retriever will recognize the URL or the data it points to.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint">
            <summary>
            RFC 1706.
            <pre>
            +-----+-----+----------------------+----------+-----------+
            | bit | 0-7 | 8-7+X                | 8+X-55+X | 56+X-63+X |
            +-----+-----+----------------------+----------+-----------+
            | 0   | AFI | Domain Specific Area | ID       | Sel       |
            +-----+-----+-----+----------------+----------+-----------+
            | 0   | AFI | IDI | HO-DSP         | ID       | Sel       |
            +-----+-----+-----+----------------+----------+-----------+
            | 0   | Area Address               | ID       | Sel       |
            +-----+-----------+----------------+----------+-----------+
            | 0   | IDP       | DSP                                   |
            +-----+-----------+---------------------------------------+
            </pre>
            IDP is Initial Domain Part.
            DSP is Domain Specific Part.
            HO-DSP may use any format as defined by the authority identified by IDP.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.#ctor(PcapDotNet.Packets.DataSegment,PcapDotNet.Base.UInt48,System.Byte)">
            <summary>
            Constructs an instance out of the area address, system identifier and selector fields.
            </summary>
            <param name="areaAddress">
            The combination of [IDP, HO-DSP] identify both the routing domain and the area within the routing domain.
            Hence the combination [IDP, HO-DSP] is called the "Area Address".
            All nodes within the area must have same Area address.
            </param>
            <param name="systemIdentifier">System Identifier.</param>
            <param name="selector">NSAP Selector.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.Equals(PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint)">
            <summary>
            Two DnsResourceDataNetworkServiceAccessPoint are iff their area address, system identifier and selector fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.Equals(System.Object)">
            <summary>
            Two DnsResourceDataNetworkServiceAccessPoint are iff their area address, system identifier and selector fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.GetHashCode">
            <summary>
            A hash code of the combination of the area address, system identifier and selector fields. 
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.AuthorityAndFormatIdentifier">
            <summary>
            Authority and Format Identifier.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.AreaAddress">
            <summary>
            The combination of [IDP, HO-DSP] identify both the routing domain and the area within the routing domain.
            Hence the combination [IDP, HO-DSP] is called the "Area Address".
            All nodes within the area must have same Area address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.SystemIdentifier">
            <summary>
            System Identifier.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNetworkServiceAccessPoint.Selector">
            <summary>
            NSAP Selector.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress">
            <summary>
            <pre>
            +-----+---------+
            | bit | 0-7     |
            +-----+---------+
            | 0   | FORMAT  |
            +-----+---------+
            | 8   | ADDRESS |
            | ... |         |
            +-----+---------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress.#ctor(PcapDotNet.Packets.Dns.DnsAtmAddressFormat,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance from the format and address fields.
            </summary>
            <param name="format">The format of Address.</param>
            <param name="address">
            Variable length string of octets containing the ATM address of the node to which this RR pertains.
            When the format is AESA, the address is coded as described in ISO 8348/AD 2 using the preferred binary encoding of the ISO NSAP format.
            When the format value is E.164, the Address/Number Digits appear in the order in which they would be entered on a numeric keypad.
            Digits are coded in IA5 characters with the leftmost bit of each digit set to 0.
            This ATM address appears in ATM End System Address Octets field (AESA format) or the Address/Number Digits field (E.164 format) of the Called party number information element [ATMUNI3.1].
            Subaddress information is intentionally not included because E.164 subaddress information is used for routing.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress.Equals(PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress)">
            <summary>
            Two DnsResourceDataAtmAddress are equal iff their format and address fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress.Equals(System.Object)">
            <summary>
            Two DnsResourceDataAtmAddress are equal iff their format and address fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress.GetHashCode">
            <summary>
            A hash code based on the format and address fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress.Format">
            <summary>
            The format of Address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataAtmAddress.Address">
            <summary>
            Variable length string of octets containing the ATM address of the node to which this RR pertains.
            When the format is AESA, the address is coded as described in ISO 8348/AD 2 using the preferred binary encoding of the ISO NSAP format.
            When the format value is E.164, the Address/Number Digits appear in the order in which they would be entered on a numeric keypad.
            Digits are coded in IA5 characters with the leftmost bit of each digit set to 0.
            This ATM address appears in ATM End System Address Octets field (AESA format) or the Address/Number Digits field (E.164 format) of the Called party number information element [ATMUNI3.1].
            Subaddress information is intentionally not included because E.164 subaddress information is used for routing.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpHardwareType">
            <summary>
            The data link layer protocol of the ARP protocol.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.None">
            <summary>
            Invalid hardware type
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Ethernet">
            <summary>
            Ethernet (10Mb)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ExperimentalEthernet">
            <summary>
            Experimental Ethernet (3Mb)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AmateurRadioAx25">
            <summary>
            Amateur Radio AX.25
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ProteonProNetTokenRing">
            <summary>
            Proteon ProNET Token Ring
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Chaos">
            <summary>
            Chaos
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Ieee802Networks">
            <summary>
            IEEE 802 Networks
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AttachedResourceComputerNetwork">
            <summary>
            ARCNET
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.HyperChannel">
            <summary>
            Hyperchannel
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.LanStar">
            <summary>
            Lanstar
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AutonetShortAddress">
            <summary>
            Autonet Short Address
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.LocalTalk">
            <summary>
            LocalTalk
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.LocalNet">
            <summary>
            LocalNet (IBM PCNet or SYTEK LocalNET)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.UltraLink">
            <summary>
            Ultra link
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.SwitchedMultimegabitDataService">
            <summary>
            SMDS
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.FrameRelay">
            <summary>
            Frame Relay
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AsynchronousTransmissionMode16">
            <summary>
            Asynchronous Transmission Mode (ATM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.HighLevelDataLinkControl">
            <summary>
            HDLC
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.FibreChannel">
            <summary>
            Fibre Channel
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AsynchronousTransmissionMode19">
            <summary>
            Asynchronous Transmission Mode (ATM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.SerialLine">
            <summary>
            Serial Line
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AsynchronousTransmissionMode21">
            <summary>
            Asynchronous Transmission Mode (ATM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.MilStd188Hyphen220">
            <summary>
            MIL-STD-188-220
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Metricom">
            <summary>
            Metricom
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Ieee1394Dot1995">
            <summary>
            IEEE 1394.1995
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.MultipleAccessOverSynchronousOpticalNetworkingOrSynchronousDigitalHierarchy">
            <summary>
            MAPOS
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Twinaxial">
            <summary>
            Twinaxial
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ExtendedUniqueIdentifier64">
            <summary>
            EUI-64
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Hiparp">
            <summary>
            HIPARP
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.IpAndArpOverIso7816Hyphen3">
            <summary>
            IP and ARP over ISO 7816-3
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ArpSec">
            <summary>
            ARPSec
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.IpSecTunnel">
            <summary>
            IPsec tunnel
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.InfiniBand">
            <summary>
            InfiniBand (TM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Tia102Project25CommonAirInterface">
            <summary>
            TIA-102 Project 25 Common Air Interface (CAI)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.WiegandInterface">
            <summary>
            Wiegand Interface
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.PureIp">
            <summary>
            Pure IP
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Experimental1">
            <summary>
            HW_EXP1
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Experimental2">
            <summary>
            HW_EXP2
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionUnknown">
            <summary>
            An unknown TCP option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionUnknown.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionUnknown.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.#ctor(PcapDotNet.Packets.Transport.TcpOptionType,System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates an unknown TCP option by the given type and data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.#ctor">
            <summary>
            The default unknown option is with type 255 and no data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.Equals(PcapDotNet.Packets.Transport.TcpOptionUnknown)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.GetHashCode">
            <summary>
            The hash code for an unknown option is the hash code for the option type xored with the hash code of the data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.CreateInstance(PcapDotNet.Packets.Transport.TcpOptionType,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Creates an unknown option from its type and by reading a buffer for its value.
            </summary>
            <param name="optionType">The type of the unknown option.</param>
            <param name="buffer">The buffer of bytes to read the value of the unknown option.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="valueLength">The number of bytes to read from the buffer.</param>
            <returns>An option created from the given type and buffer.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionUnknown.Data">
            <summary>
            The data of the unknown option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionUnknown.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionUnknown.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted">
            <summary>
            Sack-Permitted Option (RFC 2018)
            This two-byte option may be sent in a SYN by a TCP that has been extended to receive (and presumably process) 
            the SACK option once the connection has opened.  
            It MUST NOT be sent on non-SYN segments.
            
            <pre>
            +---------+---------+
            | Kind=4  | Length=2|
            +---------+---------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.#ctor">
            <summary>
            Creates a selective ack permitted option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.Equals(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted)">
            <summary>
            Two selective ack permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two selective ack permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize">
            <summary>
            Maximum Segment Size (RFC 793)
            <pre>
            +--------+--------+---------+--------+
            |00000010|00000100|   max seg size   |
            +--------+--------+---------+--------+
             Kind=2   Length=4
            </pre>
            
            <para>
            If this option is present, then it communicates the maximum receive segment size at the TCP which sends this segment.
            This field must only be sent in the initial connection request (i.e., in segments with the SYN control bit set).  
            If this option is not used, any segment size is allowed.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.#ctor(System.UInt16)">
            <summary>
            Creates the option using the given maximum segment size.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.#ctor">
            <summary>
            The default maximum segment size is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.Equals(PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize)">
            <summary>
            Two maximum segment size options are equal if they have the same maximum segment size.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two maximum segment size options are equal if they have the same maximum segment size.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.GetHashCode">
            <summary>
            The hash code of the option is the hash code of the option type xored with the hash code of the maximum segment size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.MaximumSegmentSize">
            <summary>
            The maximum segment size value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting">
            <summary>
            Strict Source and Record Route
            <pre>
            +--------+--------+--------+---------//--------+
            |10001001| length | pointer|     route data    |
            +--------+--------+--------+---------//--------+
             Type=137
            </pre>
            
            <para>
            The strict source and record route (SSRR) option provides a means for the source of an internet datagram 
            to supply routing information to be used by the gateways in forwarding the datagram to the destination, 
            and to record the route information.
            </para>
            
            <para>
            The option begins with the option type code.  
            The second octet is the option length which includes the option type code and the length octet, 
            the pointer octet, and length-3 octets of route data.  
            The third octet is the pointer into the route data indicating the octet which begins the next source address to be processed.  
            The pointer is relative to this option, and the smallest legal value for the pointer is 4.
            </para>
            
            <para>
            A route data is composed of a series of internet addresses.
            Each internet address is 32 bits or 4 octets.  
            If the pointer is greater than the length, the source route is empty (and the recorded route full) 
            and the routing is to be based on the destination address field.
            </para>
            
            <para>
            If the address in destination address field has been reached and the pointer is not greater than the length, 
            the next address in the source route replaces the address in the destination address field, 
            and the recorded route address replaces the source address just used, and pointer is increased by four.
            </para>
            
            <para>
            The recorded route address is the internet module's own internet address as known in the environment 
            into which this datagram is being forwarded.
            </para>
            
            <para>
            This procedure of replacing the source route with the recorded route 
            (though it is in the reverse of the order it must be in to be used as a source route) 
            means the option (and the IP header as a whole) remains a constant length as the datagram progresses through the internet.
            </para>
            
            <para>
            This option is a strict source route because the gateway or host IP 
            must send the datagram directly to the next address in the source route through only the directly connected network 
            indicated in the next address to reach the next gateway or host specified in the route.
            </para>
            
            <para>
            Must be copied on fragmentation.  
            Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},System.Byte)">
            <summary>
            Create the option according to the given values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting.#ctor">
            <summary>
            Creates an empty strict source routing option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities">
            <summary>
            This field identifies the National Access Programs or Special Access Programs 
            which specify protection rules for transmission and processing of the information contained in the datagram. 
            Protection authority flags do NOT represent accreditation authorities, though the semantics are superficially similar.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.None">
            <summary>
            No protection authorities.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.Genser">
            <summary>
            Designated Approving Authority per DOD 5200.28
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.SingleIntegrationOptionalPlanExtremelySensitiveInformation">
            <summary>
            Single Integrated Operational Plan - Extremely Sensitive Information (SIOP-ESI).
            Department of Defense Organization of the Joint Chiefs of Staff 
            Attn: J6 Washington, DC  20318-6000
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.SensitiveCompartmentedInformation">
            <summary>
            Sensitive Compartmented Information (SCI).
            Director of Central Intelligence 
            Attn: Chairman, Information Handling Committee, Intelligence Community Staff Washington, D.C. 20505
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.Nsa">
            <summary>
            National Security Agency (NSA).
            9800 Savage Road Attn: T03 Ft. Meade, MD 20755-6000
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.DepartmentOfEnergy">
            <summary>
            Department of Energy (DOE).
            Attn:  DP343.2 Washington, DC  20545
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion2Layer">
            <summary>
            RFC 2236.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpVersion2Layer">
            <summary>
            RFC 2236.
            Represents a generic IGMP version 2 datagram.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpVersion2Layer.MaxResponseTime">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpVersion2Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion2Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion2Layer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+------------+
            | Bit | 0-7  | 8-15 | 16-31      |
            +-----+------+------+------------+
            | 0   | Type | Code | Checksum   |
            +-----+------+------+------------+
            | 0   | Gateway Internet Address |
            +-----+--------------------------+
            | 32  | Internet Header          |
            |     | + 64 bits of             |
            |     | Original Data Datagram   |
            +-----+--------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.GatewayInternetAddress">
            <summary>
            Address of the gateway to which traffic for the network specified in the internet destination network field of the original datagram's data should be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoDatagram">
            <summary>
            Echo
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 0   | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 32  | Data...                       |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpEchoDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampLayer">
            <summary>
            RFC 792.
            Represents an ICMP Timestamp layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the OriginateTimestamp, ReceiveTimestamp and the TransmitTimestamp fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpTimestampLayer)">
            <summary>
            True iff the OriginateTimestamp, ReceiveTimestamp and the TransmitTimestamp fields are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.OriginateTimestamp">
            <summary>
            The time the sender last touched the message before sending it.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.ReceiveTimestamp">
            <summary>
            The time the echoer first touched it on receipt.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.TransmitTimestamp">
            <summary>
            The time the echoer last touched the message on sending it.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSourceQuenchLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSourceQuenchLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoReplyDatagram">
            <summary>
            Echo Reply
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 0   | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 32  | Data...                       |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpEchoReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram">
            <summary>
            RFC 792 and RFC 1191.
            <pre>
            +-----+------+------+--------------+
            | Bit | 0-7  | 8-15 | 16-31        |
            +-----+------+------+--------------+
            | 0   | Type | Code | Checksum     |
            +-----+------+------+--------------+
            | 32  | unused      | Next-Hop MTU |
            +-----+-------------+--------------+
            | 64  | Internet Header            |
            |     | + 64 bits of               |
            |     | Original Data Datagram     |
            +-----+----------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.MinimumMaximumTransmissionUnit">
            <summary>
            The minimum value of the maximum transmission unit for FragmentationNeededAndDoNotFragmentSet code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header, the IPv4's payload is in the expected size
            and if the NextHopMaximumTransmissionUnit is at least 68 for FragmentationNeededAndDoNotFragmentSet code or exactly 0 for other codes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.NextHopMaximumTransmissionUnit">
            <summary>
            The size in octets of the largest datagram that could be forwarded, 
            along the path of the original datagram, without being fragmented at this router.  
            The size includes the IP header and IP data, and does not include any lower-level headers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp">
            <summary>
            RFC 1702.
            Represents a source route entry consisting of a list of IP addresses and indicates an IP source route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{PcapDotNet.Packets.IpV4.IpV4Address},System.Int32)">
            <summary>
            Initializes using the given IP addresses and the next as number index.
            </summary>
            <param name="addresses">IP addresses of the source route.</param>
            <param name="nextAddressIndex">The next IP address index in the source route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the IP addresses are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.PayloadHashCode">
            <summary>
            The xor of the hash code of the IP addresses.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.Addresses">
            <summary>
            IP addresses of the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.NextAddressIndex">
            <summary>
            The next IP address index in the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.NextAddress">
            <summary>
            The next IP address.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetDatagram">
            <summary>
            Represents an Ethernet datagram.
            
            <pre>
            +------+-----------------+------------+------------------+
            | Byte | 0-5             | 6-11       | 12-13            |
            +------+-----------------+------------+------------------+
            | 0    | MAC Destination | MAC Source | EtherType/Length |
            +------+-----------------+------------+------------------+
            | 14   | Data                                            |
            +------+-------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetDatagram.HeaderLengthValue">
            <summary>
            Ethernet header length in bytes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetDatagram.CalculateIsValid">
            <summary>
            An Ethernet datagram is valid iff its length is big enough for the header and its payload is valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.HeaderLength">
            <summary>
            Header length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.BroadcastAddress">
            <summary>
            The broadcast MAC address (FF:FF:FF:FF:FF:FF).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.PayloadLength">
            <summary>
            The Ethernet payload length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.Source">
            <summary>
            Ethernet source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.Destination">
            <summary>
            Ethernet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.EtherType">
            <summary>
            Ethernet type (next protocol).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataIsdn">
            <summary>
            RFC 1183.
            <pre>
            +---------------+
            | ISDN-address  |
            +---------------+
            | sa (optional) |
            +---------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIsdn.#ctor(PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an ISDN resource data without a subaddress from the ISDN address.
            </summary>
            <param name="isdnAddress">
            Identifies the ISDN number of the owner and DDI (Direct Dial In) if any, as defined by E.164 and E.163, 
            the ISDN and PSTN (Public Switched Telephone Network) numbering plan.
            E.163 defines the country codes, and E.164 the form of the addresses.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIsdn.#ctor(PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an ISDN resource data from the ISDN address and subaddress.
            </summary>
            <param name="isdnAddress">
            Identifies the ISDN number of the owner and DDI (Direct Dial In) if any, as defined by E.164 and E.163, 
            the ISDN and PSTN (Public Switched Telephone Network) numbering plan.
            E.163 defines the country codes, and E.164 the form of the addresses.
            </param>
            <param name="subaddress">Specifies the subaddress (SA).</param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIsdn.IsdnAddress">
            <summary>
            Identifies the ISDN number of the owner and DDI (Direct Dial In) if any, as defined by E.164 and E.163, 
            the ISDN and PSTN (Public Switched Telephone Network) numbering plan.
            E.163 defines the country codes, and E.164 the form of the addresses.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIsdn.Subaddress">
            <summary>
            Specifies the subaddress (SA).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey">
            <summary>
            RFC 4025.
            <pre>
            +-----+--------------+
            | bit | 0-7          |
            +-----+--------------+
            | 0   | precedence   |
            +-----+--------------+
            | 8   | gateway type |
            +-----+--------------+
            | 16  | algorithm    |
            +-----+--------------+
            | 24  | gateway      |
            | ... |              |
            +-----+--------------+
            |     | public key   |
            | ... |              |
            +-----+--------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.#ctor(System.Byte,PcapDotNet.Packets.Dns.DnsGateway,PcapDotNet.Packets.Dns.DnsPublicKeyAlgorithm,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the precedence, gateway, algorithm and public key fields.
            </summary>
            <param name="precedence">
            Precedence for this record.
            Gateways listed in IPSECKEY records with lower precedence are to be attempted first.
            Where there is a tie in precedence, the order should be non-deterministic.
            </param>
            <param name="gateway">
            Indicates a gateway to which an IPsec tunnel may be created in order to reach the entity named by this 
            resource record.
            </param>
            <param name="algorithm">Identifies the public key's cryptographic algorithm and determines the format of the public key field.</param>
            <param name="publicKey">Contains the algorithm-specific portion of the KEY RR RDATA.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.Equals(PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey)">
            <summary>
            Two DnsResourceDataIpSecKey are equal iff their precedence, gateway, algorithm and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.Equals(System.Object)">
            <summary>
            Two DnsResourceDataIpSecKey are equal iff their precedence, gateway, algorithm and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.GetHashCode">
            <summary>
            A hash code of the combination of the precedence, gateway, algorithm and public key fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.Precedence">
            <summary>
            Precedence for this record.
            Gateways listed in IPSECKEY records with lower precedence are to be attempted first.
            Where there is a tie in precedence, the order should be non-deterministic.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.GatewayType">
            <summary>
            Indicates the format of the information that is stored in the gateway field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.Gateway">
            <summary>
            Indicates a gateway to which an IPsec tunnel may be created in order to reach the entity named by this resource record.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.Algorithm">
            <summary>
            Identifies the public key's cryptographic algorithm and determines the format of the public key field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataIpSecKey.PublicKey">
            <summary>
            Contains the algorithm-specific portion of the KEY RR RDATA.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOpCode">
            <summary>
            RFCs 1035, 1996, 2136, 3425.
            Specifies kind of query in this message.  
            This value is set by the originator of a query and copied into the response.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOpCode.Query">
            <summary>
            RFC 1035.
            A standard query (QUERY).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOpCode.IQuery">
            <summary>
            RFC 3425.
            An inverse query (IQUERY).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOpCode.Status">
            <summary>
            RFC 1035.
            A server status request (STATUS).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOpCode.Notify">
            <summary>
            RFC 1996.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOpCode.Update">
            <summary>
            RFC 2136.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsClass">
            <summary>
            RFC 1035, 2136.
            Other sources: Dyer 1987, Moon 1981.
            CLASS fields appear in resource records.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsClass.None">
            <summary>
            Represents no class.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsClass.Internet">
            <summary>
            RFC 1035.
            IN - Internet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsClass.Chaos">
            <summary>
            Moon 1981 1035.
            The CHAOS class.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsClass.Hesiod">
            <summary>
            Dyer 87.
            HS - Hesiod.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsClass.NoneExistent">
            <summary>
            RFC 2136.
            None.
            Query class.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsClass.Any">
            <summary>
            RFC 1035.
            *.
            Any class.
            Query class.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.DataLinkKind">
            <summary>
            Represents the different data links kinds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.DataLinkKind.Ethernet">
            <summary>
            Ethernet data link kind.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.DataLinkKind.IpV4">
            <summary>
            IPv4 data link kind.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.DataLinkKind.Docsis">
            <summary>
            Data Over Cable Service Interface Specification.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpLayer">
            <summary>
            Represents an ARP protocol layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.Equals(PcapDotNet.Packets.Arp.ArpLayer)">
            <summary>
            True iff the two ARP layers have equal protocol type, operation and addresses.
            </summary>
            <param name="other">The ARP layer to compare the layer to.</param>
            <returns>True iff the two layers are equal.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two ARP layers have equal protocol type, operation and addresses.
            </summary>
            <param name="other">The ARP layer to compare the layer to.</param>
            <returns>True iff the two layers are equal.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of a combination of the protocol type and operation and the hash codes of the layer length and data link.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.ProtocolType">
            <summary>
            Each protocol is assigned a number used in this field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.Operation">
            <summary>
            Specifies the operation the sender is performing.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.SenderHardwareAddress">
            <summary>
            Hardware address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.SenderProtocolAddress">
            <summary>
            Protocol address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.TargetHardwareAddress">
            <summary>
            Hardware address of the intended receiver. 
            This field is ignored in requests.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.TargetProtocolAddress">
            <summary>
            Protocol address of the intended receiver.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.PreviousLayerEtherType">
            <summary>
            The Ethernet Type the Ethernet layer should write when this layer is the Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.PreviousLayerDefaultDestination">
            <summary>
            The default MAC Address value when this layer is the Ethernet payload.
            null means there is no default value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted">
            <summary>
            TCP POC-permitted Option (RFC 1693)
            <pre>
            +-----------+-------------+
            |  Kind=9   |  Length=2   |
            +-----------+-------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.#ctor">
            <summary>
            Creates a partial order connection permitted option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.Equals(PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted)">
            <summary>
            Two partial order connection permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two partial order connection permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpDatagram">
            <summary>
            RFC 793.
            TCP Header Format
            <pre>
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | Bit | 0-3         | 4-6      | 7  | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16-31            |
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | 0   | Source Port                                                                 | Destination Port |
            +-----+-----------------------------------------------------------------------------+------------------+
            | 32  | Sequence Number                                                                                |
            +-----+------------------------------------------------------------------------------------------------+
            | 64  | Acknowledgment Number                                                                          |
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | 96  | Data Offset | Reserved | NS | CWR | ECE | URG | ACK | PSH | RST | SYN | FIN | Window           |
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | 128 | Checksum                                                                    | Urgent Pointer   |
            +-----+-----------------------------------------------------------------------------+------------------+
            | 160 | Options + Padding                                                                              |
            +-----+------------------------------------------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpDatagram.HeaderMinimumLength">
            <summary>
            The minimum number of bytes the header takes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpDatagram.HeaderMaximumLength">
            <summary>
            The maximum number of bytes the header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpDatagram.CalculateIsValid">
            <summary>
            The datagram is valid if the length is correct according to the header and the options are valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.SequenceNumber">
            <summary>
            The sequence number of the first data octet in this segment (except when SYN is present). 
            If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.NextSequenceNumber">
            <summary>
            The sequence number of the data that will come after this data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.AcknowledgmentNumber">
            <summary>
            If the ACK control bit is set this field contains the value of the next sequence number 
            the sender of the segment is expecting to receive.  
            Once a connection is established this is always sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.HeaderLength">
            <summary>
            The number of bytes in the TCP Header.
            This indicates where the data begins.
            The TCP header (even one including options) is an integral number of 32 bits (4 bytes) long.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.RealHeaderLength">
            <summary>
            Returns the actual header length.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Reserved">
            <summary>
            Reserved for future use.
            Must be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.ControlBits">
            <summary>
            A collection of bits for the TCP control.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Window">
            <summary>
            The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Checksum">
            <summary>
            The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.  
            If a segment contains an odd number of header and text octets to be checksummed, 
            the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.  
            The pad is not transmitted as part of the segment.  
            While computing the checksum, the checksum field itself is replaced with zeros.
            
            The checksum also covers a 96 bit pseudo header conceptually prefixed to the TCP header.  
            This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.
            This gives the TCP protection against misrouted segments.  
            This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls 
            by the TCP on the IP.
            
            +--------+--------+--------+--------+
            |           Source Address          |
            +--------+--------+--------+--------+
            |         Destination Address       |
            +--------+--------+--------+--------+
            |  zero  |  PTCL  |    TCP Length   |
            +--------+--------+--------+--------+
            
            The TCP Length is the TCP header length plus the data length in octets (this is not an explicitly transmitted quantity, but is computed), 
            and it does not count the 12 octets of the pseudo header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsChecksumOptional">
            <summary>
            True iff the checksum for the transport type is optional.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.UrgentPointer">
            <summary>
            This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
            The urgent pointer points to the sequence number of the octet following the urgent data.  
            This field is only be interpreted in segments with the URG control bit set.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Options">
            <summary>
            Returns the TCP options contained in this TCP Datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.PayloadLength">
            <summary>
            The length of the TCP payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsCongestionWindowReduced">
            <summary>
            True iff the CongestionWindowReduced control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsExplicitCongestionNotificationEcho">
            <summary>
            True iff the ExplicitCongestionNotificationEcho control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsUrgent">
            <summary>
            True iff the Urgent control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsAcknowledgment">
            <summary>
            True iff the Acknowledgment control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsPush">
            <summary>
            True iff the Push control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsReset">
            <summary>
            True iff the Reset control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsSynchronize">
            <summary>
            True iff the Synchronize control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsFin">
            <summary>
            True iff the Fin control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Http">
            <summary>
            The first HTTP message in this TCP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.HttpCollection">
            <summary>
            All of the available HTTP messages in this TCP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Payload">
            <summary>
            The payload of the TCP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMood">
            <summary>
            TCP Mood Option:
            <pre>
            +---------+--------+------------+
            | Kind=25 | Length | ASCII Mood |
            +---------+--------+------------+
            </pre>
            
            <para>
             It is proposed that option 25 (released 2000-12-18) be used to define packet mood.
            This option would have a length value of 4 or 5 bytes.
            All the simple emotions described as expressible via this mechanism can be displayed with two or three 7-bit, ASCII-encoded characters.
            Multiple mood options may appear in a TCP header, so as to express more complex moods than those defined here (for instance if a packet were happy and surprised).
            </para>
            
            <para>
            It is proposed that common emoticons be used to denote packet mood.
            Packets do not "feel" per se.  The emotions they could be tagged with are a reflection of the user mood expressed through packets.
            So the humanity expressed in a packet would be entirely sourced from humans.
             To this end, it is proposed that simple emotions be used convey mood as follows.
            
            <pre>
            ASCII                Mood
            =====                ====
            :)                   Happy
            :(                   Sad
            :D                   Amused
            %(                   Confused
            :o                   Bored
            :O                   Surprised
            :P                   Silly
            :@                   Frustrated
            >:@                  Angry
            :|                   Apathetic
            ;)                   Sneaky
            >:)                  Evil
            </pre>
            
            Proposed ASCII character encoding
            <pre>
            Binary          Dec  Hex     Character
            ========        ===  ===     =========
            010 0101        37   25      %
            010 1000        40   28      (
            010 1001        41   29      )
            011 1010        58   3A      :
            011 1011        59   3B      ;
            011 1110        62   3E      >
            100 0000        64   40      @
            100 0100        68   44      D
            100 1111        79   4F      O
            101 0000        80   50      P
            110 1111        111  6F      o
            111 1100        124  7C      |
            </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionMaximumLength">
            <summary>
            The maximum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option value take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionValueMaximumLength">
            <summary>
            The maximum number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.#ctor(PcapDotNet.Packets.Transport.TcpOptionMoodEmotion)">
            <summary>
            Creates the option using the given emotion.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.#ctor">
            <summary>
            The default emotion is confused.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.Equals(PcapDotNet.Packets.Transport.TcpOptionMood)">
            <summary>
            Two mood options are equal if they have the same emotion.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two mood options are equal if they have the same emotion.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.GetHashCode">
            <summary>
            The hash code of the echo option is the hash code of the option type xored with the hash code info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.Emotion">
            <summary>
            The emotion of the option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.EmotionString">
            <summary>
            The ASCII string of the emotion.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.PayloadLayer">
            <summary>
            Represents a layer that adds a simple payload.
            Actually can be any buffer of bytes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.#ctor">
            <summary>
            Creates an empty payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.Equals(PcapDotNet.Packets.PayloadLayer)">
            <summary>
            Two payload layers are equal if they have same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two payload layers are equal if they have same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="P:PcapDotNet.Packets.PayloadLayer.Data">
            <summary>
            The Payload data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.PayloadLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute">
            <summary>
            The presence of this option in an ICMP Echo (or any other) packet, hereinafter referred to as the Outbound Packet, 
            will cause a router to send the newly defined ICMP Traceroute message to the originator of the Outbound Packet.  
            In this way, the path of the Outbound Packet will be logged by the originator with only n+1 (instead of 2n) packets.  
            This algorithm does not suffer from a changing path and allows the response to the Outbound Packet, 
            hereinafter refered to as the Return Packet, to be traced 
            (provided the Outbound Packet's destination preserves the IP Traceroute option in the Return Packet).
            
            <para>
            IP Traceroute option format
            <pre>
             0               8              16              24
            +-+---+---------+---------------+-------------------------------+
            |F| C |  Number |    Length     |          ID Number            |
            +-+---+-------------------------+-------------------------------+
            |      Outbound Hop Count       |       Return Hop Count        |
            +-------------------------------+-------------------------------+
            |                     Originator IP Address                     |
            +---------------------------------------------------------------+
            </pre>
            </para>
            
            <para>
            F (copy to fragments): 0 (do not copy to fragments)
            C (class): 2 (Debugging and Measurement)
            Number: 18 (F+C+Number = 82)
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OptionValueLength">
            <summary>
            The number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.#ctor(System.UInt16,System.UInt16,System.UInt16,PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Create the trace route option from the trace route option values.
            </summary>
            <param name="identification">
            An arbitrary number used by the originator of the Outbound Packet to identify the ICMP Traceroute messages.  
            It is NOT related to the ID number in the IP header.
            </param>
            <param name="outboundHopCount">
            Outbound Hop Count (OHC)
            The number of routers through which the Outbound Packet has passed.  
            This field is not incremented by the Outbound Packet's destination.
            </param>
            <param name="returnHopCount"></param>
            Return Hop Count (RHC)
            The number of routers through which the Return Packet has passed.
            This field is not incremented by the Return Packet's destination.       
            <param name="originatorIpAddress">
            The IP address of the originator of the Outbound Packet.  
            This isneeded so the routers know where to send the ICMP Traceroute message for Return Packets.  
            It is also needed for Outbound Packets which have a Source Route option.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.#ctor">
            <summary>
            Creates empty trace route option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Equals(PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute)">
            <summary>
            Two trace route options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two trace route options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code with the following values hash code:
            The identification, the combination of the outbound and return hop count, the originator address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Identification">
            <summary>
            An arbitrary number used by the originator of the Outbound Packet to identify the ICMP Traceroute messages.  
            It is NOT related to the ID number in the IP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OriginatorIpAddress">
            <summary>
            The IP address of the originator of the Outbound Packet.  
            This isneeded so the routers know where to send the ICMP Traceroute message for Return Packets.  
            It is also needed for Outbound Packets which have a Source Route option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OutboundHopCount">
            <summary>
            Outbound Hop Count (OHC)
            The number of routers through which the Outbound Packet has passed.  
            This field is not incremented by the Outbound Packet's destination.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.ReturnHopCount">
            <summary>
            Return Hop Count (RHC)
            The number of routers through which the Return Packet has passed.
            This field is not incremented by the Return Packet's destination.       
            /// </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier">
            <summary>
            Stream Identifier option.
            <pre>
            +--------+--------+--------+--------+
            |10001000|00000010|    Stream ID    |
            +--------+--------+--------+--------+
             Type=136 Length=4
            </pre>
            
            This option provides a way for the 16-bit SATNET stream identifier to be carried through networks that do not support the stream concept.
            
            Must be copied on fragmentation.  
            Appears at most once in a datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.#ctor(System.UInt16)">
            <summary>
            Create the option according to the given identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.#ctor">
            <summary>
            Creates a 0 stream identifier
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Equals(PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.GetHashCode">
            <summary>
            The hash code value is the xor of the base class hash code and the identifier hash code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Identifier">
            <summary>
            The identifier of the stream.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction">
            <summary>
            Defines the possible quick start functions.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction.RateRequest">
            <summary>
            Request for a specific rate.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction.RateReport">
            <summary>
            Reports on a specific rate that was agreed (or disagreed).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeRedirect">
            <summary>
            The different ICMP code values for Redirect ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheTypeOfServiceAndNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheTypeOfServiceAndHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition">
            <summary>
            RFC 1712.
            <pre>
            +-----------+
            | LONGITUDE |
            +-----------+
            | LATITUDE  |
            +-----------+
            | ALTITUDE  |
            +-----------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs an instnace from the longitude, latitude and altitude fields.
            </summary>
            <param name="longitude">
            The real number describing the longitude encoded as a printable string.
            The precision is limited by 256 charcters within the range -90..90 degrees.
            Positive numbers indicate locations north of the equator.
            </param>
            <param name="latitude">
            The real number describing the latitude encoded as a printable string.
            The precision is limited by 256 charcters within the range -180..180 degrees.
            Positive numbers indicate locations east of the prime meridian.
            </param>
            <param name="altitude">
            The real number describing the altitude (in meters) from mean sea-level encoded as a printable string.
            The precision is limited by 256 charcters.
            Positive numbers indicate locations above mean sea-level.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition.Equals(PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition)">
            <summary>
            Two DnsResourceDataGeographicalPosition are equal if their longitude, latitude and altitude fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition.Equals(System.Object)">
            <summary>
            Two DnsResourceDataGeographicalPosition are equal if their longitude, latitude and altitude fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition.GetHashCode">
            <summary>
            A hash code of the combined longitude, latitude and altitude fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition.Longitude">
            <summary>
            The real number describing the longitude encoded as a printable string.
            The precision is limited by 256 charcters within the range -90..90 degrees.
            Positive numbers indicate locations north of the equator.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition.Latitude">
            <summary>
            The real number describing the latitude encoded as a printable string.
            The precision is limited by 256 charcters within the range -180..180 degrees.
            Positive numbers indicate locations east of the prime meridian.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataGeographicalPosition.Altitude">
            <summary>
            The real number describing the altitude (in meters) from mean sea-level encoded as a printable string.
            The precision is limited by 256 charcters.
            Positive numbers indicate locations above mean sea-level.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataAnything">
            <summary>
            A resource data that can hold any data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAnything.#ctor">
            <summary>
            An empty resource data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAnything.#ctor(PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs the resource data from the given data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAnything.Equals(PcapDotNet.Packets.Dns.DnsResourceDataAnything)">
            <summary>
            Two resource datas are equal if their data is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAnything.Equals(System.Object)">
            <summary>
            Two resource datas are equal if their data is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAnything.GetHashCode">
            <summary>
            The hash code of the data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataAnything.Data">
            <summary>
            The data of the resource data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList">
            <summary>
            RFC 3123.
            <pre>
            0 Or more of:
            +-----+--------+---+-----------+
            | bit | 0-7    | 8 | 9-15      |
            +-----+--------+---+-----------+
            | 0   | ADDRESSFAMILY          |
            +-----+--------+---+-----------+
            | 16  | PREFIX | N | AFDLENGTH |
            +-----+--------+---+-----------+
            | 32  | AFDPART                |
            | ... |                        |
            +-----+------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.Dns.DnsAddressPrefix})">
            <summary>
            Constructs an instance from a sequence of DnsAddressPrefix.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList.#ctor(PcapDotNet.Packets.Dns.DnsAddressPrefix[])">
            <summary>
            Constructs an instance from a sequence of DnsAddressPrefix.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList.Equals(PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList)">
            <summary>
            Two DnsResourceDataAddressPrefixList are equal iff their items are equal and in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList.Equals(System.Object)">
            <summary>
            Two DnsResourceDataAddressPrefixList are equal iff their items are equal and in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList.GetHashCode">
            <summary>
            A hash code based on the items.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList.Items">
            <summary>
            The DnsAddressPrefix items in the list.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataAddressPrefixList.Length">
            <summary>
            The number of bytes the resource data takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionWindowScale">
            <summary>
            Window Scale Option (RFC 1323)
            The three-byte Window Scale option may be sent in a SYN segment by a TCP.  
            It has two purposes: (1) indicate that the TCP is prepared to do both send and receive window scaling, 
            and (2) communicate a scale factor to be applied to its receive window.  
            Thus, a TCP that is prepared to scale windows should send the option, even if its own scale factor is 1.  
            The scale factor is limited to a power of two and encoded logarithmically, so it may be implemented by binary shift operations.
            
            <pre>
            +---------+---------+---------+
            | Kind=3  |Length=3 |shift.cnt|
            +---------+---------+---------+
            </pre>
            
            <para>
            This option is an offer, not a promise; both sides must send Window Scale options in their SYN segments to enable window scaling in either direction.
            If window scaling is enabled, then the TCP that sent this option will right-shift its true receive-window values by 'shift.cnt' bits 
            for transmission in SEG.WND.  
            The value 'shift.cnt' may be zero (offering to scale, while applying a scale factor of 1 to the receive window).
            </para>
            
            <para>
            This option may be sent in an initial SYN segment (i.e., a segment with the SYN bit on and the ACK bit off).  
            It may also be sent in a SYN,ACK segment, but only if a Window Scale option was received in the initial SYN segment.  
            A Window Scale option in a segment without a SYN bit should be ignored.
            </para>
            
            <para>
            The Window field in a SYN (i.e., a SYN or SYN,ACK) segment itself is never scaled.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionWindowScale.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionWindowScale.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.#ctor(System.Byte)">
            <summary>
            Create a scale factor option using the given scale factor log.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.#ctor">
            <summary>
            The default scale factor log is 0 (scale factor is 1).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.Equals(PcapDotNet.Packets.Transport.TcpOptionWindowScale)">
            <summary>
            Two window scale options are equal if they have the same scale factor.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two window scale options are equal if they have the same scale factor.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.GetHashCode">
            <summary>
            The hash code of the window scale option is the hash code of the option type xored with the hash code of the scale factor log.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionWindowScale.ScaleFactorLog">
            <summary>
            The log of the window scale factor.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionWindowScale.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionWindowScale.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest">
            <summary>
            TCP Alternate Checksum Request Option (RFC 1146).
            <pre>
            +----------+----------+----------+
            |  Kind=14 | Length=3 |  chksum  |
            +----------+----------+----------+
            </pre>
            
            <para>
            Here chksum is a number identifying the type of checksum to be used.
            </para>
            
            <para>
            The currently defined values of chksum are:
            <list>
              <item>0  - TCP checksum.</item>
              <item>1  - 8-bit  Fletcher's algorithm.</item>
              <item>2  - 16-bit Fletcher's algorithm.</item>
            </list>
            </para>
            
            <para>
            Note that the 8-bit Fletcher algorithm gives a 16-bit checksum and the 16-bit algorithm gives a 32-bit checksum.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.#ctor(PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType)">
            <summary>
            Creates the option using the given checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.#ctor">
            <summary>
            The default checksum type is the TCP checksum.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.Equals(PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest)">
            <summary>
            Two alternate checksum request options are equal if they have the same checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two alternate checksum request options are equal if they have the same checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.GetHashCode">
            <summary>
            The hash code of this option is the hash code of the option type xored with hash code of the checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.ChecksumType">
            <summary>
            The type of the checksum.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Protocol">
            <summary>
            Indicates the next level IPv4 protocol used in the pyaload of the IPv4 datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6HopByHopOption">
            <summary>
            IPv6 Hop-by-Hop Option RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetControlMessageProtocol">
            <summary>
            Internet Control Message Protocol RFC 792   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetGroupManagementProtocol">
            <summary>
            Internet Group Management Protocol RFC 1112   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.GatewayToGateway">
            <summary>
            Gateway-to-Gateway Protocol RFC 823   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Ip">
            <summary>
            IP in IP (encapsulation) RFC 2003   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Stream">
            <summary>
            Internet Stream Protocol RFC 1190, RFC 1819   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Tcp">
            <summary>
            Transmission Control Protocol RFC 793   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Cbt">
            <summary>
            CBT   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ExteriorGatewayProtocol">
            <summary>
            Exterior Gateway Protocol RFC 888   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InteriorGatewayProtocol">
            <summary>
            Interior Gateway Protocol (any private interior gateway (used by Cisco for their IGRP))   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.BbnRccMonitoring">
            <summary>
            BBN RCC Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NetworkVoice">
            <summary>
            Network Voice Protocol RFC 741   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Pup">
            <summary>
            Xerox PUP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Argus">
            <summary>
            ARGUS   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Emcon">
            <summary>
            EMCON   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CrossNetDebugger">
            <summary>
            Cross Net Debugger IEN 158   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Chaos">
            <summary>
            Chaos   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Udp">
            <summary>
            User Datagram Protocol RFC 768   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Multiplexing">
            <summary>
            Multiplexing IEN 90   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DcnMeasurement">
            <summary>
            DCN Measurement Subsystems   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.HostMonitoringProtocol">
            <summary>
            Host Monitoring Protocol RFC 869   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PacketRadioMeasurement">
            <summary>
            Packet Radio Measurement   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.XeroxNsInternetDatagramProtocol">
            <summary>
            XEROX NS IDP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Trunk1">
            <summary>
            Trunk-1   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Trunk2">
            <summary>
            Trunk-2   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Leaf1">
            <summary>
            Leaf-1   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Leaf2">
            <summary>
            Leaf-2   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ReliableDatagramProtocol">
            <summary>
            Reliable Datagram Protocol RFC 908   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetReliableTransactionProtocol">
            <summary>
            Internet Reliable Transaction Protocol RFC 938   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IsoTransportProtocolClass4">
            <summary>
            ISO Transport Protocol Class 4 RFC 905   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.BulkDataTransferProtocol">
            <summary>
            Bulk Data Transfer Protocol RFC 998   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MagneticFusionEnergyNetworkServicesProtocol">
            <summary>
            MFE Network Services Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MeritInternodalProtocol">
            <summary>
            MERIT Internodal Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DatagramCongestionControlProtocol">
            <summary>
            Datagram Congestion Control Protocol RFC 4340   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ThirdPartyConnect">
            <summary>
            Third Party Connect Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InterDomainPolicyRoutingProtocol">
            <summary>
            Inter-Domain Policy Routing Protocol RFC 1479   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.XpressTransportProtocol">
            <summary>
            Xpress Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DatagramDeliveryProtocol">
            <summary>
            Datagram Delivery Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InterDomainPolicyRoutingProtocolControlMessageTransportProtocol">
            <summary>
            IDPR Control Message Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.TransportProtocolPlusPlus">
            <summary>
            TP++ Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Il">
            <summary>
            IL Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6">
            <summary>
            IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SourceDemandRoutingProtocol">
            <summary>
            Source Demand Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6Route">
            <summary>
            Routing Header for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.FragmentHeaderForIpV6">
            <summary>
            Fragment Header for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InterDomainRoutingProtocol">
            <summary>
            Inter-Domain Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Rsvp">
            <summary>
            Resource Reservation Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Gre">
            <summary>
            Generic Routing Encapsulation   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobileHostRoutingProtocol">
            <summary>
            Mobile Host Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Bna">
            <summary>
            BNA   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Esp">
            <summary>
            Encapsulating Security Payload RFC 2406   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AuthenticationHeader">
            <summary>
            Authentication Header RFC 2402   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IntegratedNetLayerSecurityProtocol">
            <summary>
            Integrated Net Layer Security Protocol TUBA   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Swipe">
            <summary>
            IP with Encryption   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NArp">
            <summary>
            NBMA Address Resolution Protocol RFC 1735   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Mobile">
            <summary>
            IP Mobility (Min Encap) RFC 2004   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.TransportLayerSecurityProtocol">
            <summary>
            Transport Layer Security Protocol (using Kryptonet key management)   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Skip">
            <summary>
            Simple Key-Management for Internet Protocol RFC 2356   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetControlMessageProtocolForIpV6">
            <summary>
            ICMP for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NoNextHeaderForIpV6">
            <summary>
            No Next Header for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6Opts">
            <summary>
            Destination Options for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyHostInternal">
            <summary>
            Any host internal protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Cftp">
            <summary>
            CFTP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyLocalNetwork">
            <summary>
            Any local network   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SatnetAndBackroomExpak">
            <summary>
            SATNET and Backroom EXPAK   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Kryptolan">
            <summary>
            Kryptolan   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.RemoteVirtualDiskProtocol">
            <summary>
            MIT Remote Virtual Disk Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetPluribusPacketCore">
            <summary>
            Internet Pluribus Packet Core   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyDistributedFileSystem">
            <summary>
            Any distributed file system   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SatMon">
            <summary>
            SATNET Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Visa">
            <summary>
            VISA Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetPacketCoreUtility">
            <summary>
            Internet Packet Core Utility   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ComputerProtocolNetworkExecutive">
            <summary>
            Computer Protocol Network Executive   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ComputerProtocolHeartbeat">
            <summary>
            Computer Protocol Heart Beat   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.WangSpanNetwork">
            <summary>
            Wang Span Network   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PacketVideoProtocol">
            <summary>
            Packet Video Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.BackroomSatMon">
            <summary>
            Backroom SATNET Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SunNd">
            <summary>
            SUN ND PROTOCOL-Temporary   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.WidebandMonitoring">
            <summary>
            WIDEBAND Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.WidebandExpak">
            <summary>
            WIDEBAND EXPAK   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IsoIp">
            <summary>
            International Organization for Standardization Internet Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.VersatileMessageTransactionProtocol">
            <summary>
            Versatile Message Transaction Protocol RFC 1045   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SecureVersatileMessageTransactionProtocol">
            <summary>
            Secure Versatile Message Transaction Protocol RFC 1045   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Vines">
            <summary>
            VINES   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Ttp">
            <summary>
            TTP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NationalScienceFoundationNetworkInteriorGatewayProtocol">
            <summary>
            NSFNET-IGP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DissimilarGatewayProtocol">
            <summary>
            Dissimilar Gateway Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Tcf">
            <summary>
            TCF   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.EnhancedInteriorGatewayRoutingProtocol">
            <summary>
            Enhanced Interior Gateway Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.OpenShortestPathFirst">
            <summary>
            Open Shortest Path First RFC 1583   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SpriteRpc">
            <summary>
            Sprite RPC Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.LArp">
            <summary>
            Locus Address Resolution Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MulticastTransportProtocol">
            <summary>
            Multicast Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Ax25">
            <summary>
            AX.25   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpIp">
            <summary>
            IP-within-IP Encapsulation Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobileInternetworkingControlProtocol">
            <summary>
            Mobile Internetworking Control Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SemaphoreCommunicationsSecondProtocol">
            <summary>
            Semaphore Communications Sec. Pro   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.EtherIp">
            <summary>
            Ethernet-within-IP Encapsulation RFC 3378   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.EncapsulationHeader">
            <summary>
            Encapsulation Header RFC 1241   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyPrivateEncryptionScheme">
            <summary>
            Any private encryption scheme   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Gmtp">
            <summary>
            GMTP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpsilonFlowManagementProtocol">
            <summary>
            Ipsilon Flow Management Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PrivateNetworkToNetworkInterface">
            <summary>
            PNNI over IP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Pin">
            <summary>
            Protocol Independent Multicast   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Aris">
            <summary>
            ARIS   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SpaceCommunicationsProtocolStandards">
            <summary>
            SCPS (Space Communications Protocol Standards)   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Qnx">
            <summary>
            QNX   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ActiveNetworks">
            <summary>
            Active Networks   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpComp">
            <summary>
            IP Payload Compression Protocol RFC 3173   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SitaraNetworksProtocol">
            <summary>
            Sitara Networks Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CompaqPeer">
            <summary>
            Compaq Peer Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetworkPacketExchangeInIp">
            <summary>
            IPX in IP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.VirtualRouterRedundancyProtocol">
            <summary>
            Virtual Router Redundancy Protocol, Common Address Redundancy Protocol (not IANA assigned) VRRP:RFC 3768   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PragmaticGeneralMulticastTransportProtocol">
            <summary>
            PGM Reliable Transport Protocol RFC 3208   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Any0HopProtocol">
            <summary>
            Any 0-hop protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.LayerTwoTunnelingProtocol">
            <summary>
            Layer Two Tunneling Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DiiDataExchange">
            <summary>
            D-II Data Exchange (DDX)   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InteractiveAgentTransferProtocol">
            <summary>
            Interactive Agent Transfer Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ScheduleTransferProtocol">
            <summary>
            Schedule Transfer Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SpectraLinkRadioProtocol">
            <summary>
            SpectraLink Radio Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Uti">
            <summary>
            UTI   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SimpleMessageProtocol">
            <summary>
            Simple Message Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Sm">
            <summary>
            SM   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PerformanceTransparencyProtocol">
            <summary>
            Performance Transparency Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IsIsOverIpV4">
            <summary>
            IS-IS over IPv4   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Fire">
            <summary>
              
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CombatRadioTransportProtocol">
            <summary>
            Combat Radio Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CombatRadioUserDatagram">
            <summary>
            Combat Radio User Datagram   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ServiceSpecificConnectionOrientedProtocolInAMultilinkAndConnectionlessEnvironment">
            <summary>
              
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Iplt">
            <summary>
              
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SecurePacketShield">
            <summary>
            Secure Packet Shield   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Pipe">
            <summary>
            Private IP Encapsulation within IP Expired I-D draft-petri-mobileip-pipe-00.txt   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.StreamControlTransmissionProtocol">
            <summary>
            Stream Control Transmission Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.FibreChannel">
            <summary>
            Fibre Channel   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.RsvpE2EIgnore">
            <summary>
            RSVP-E2E-IGNORE RFC 3175   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobilityHeader">
            <summary>
            Mobility Header RFC 3775   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.UdpLite">
            <summary>
            UDP Lite RFC 3828   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MultiprotocolLabelSwitchingInIp">
            <summary>
            MPLS-in-IP RFC 4023   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobileAdHocNetwork">
            <summary>
            MANET Protocols I-D draft-ietf-manet-iana-07.txt   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Hip">
            <summary>
            Host Identity Protocol RFC 5201   
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Datagram">
            <summary>
            Represents an IPv4 datagram.
            
            <pre>
            +-----+---------+-----+-----------------+-------+-----------------+
            | Bit | 0-3     | 4-7 | 8-15            | 16-18 | 19-31           |
            +-----+---------+-----+-----------------+-------+-----------------+
            | 0   | Version | IHL | Type of Service | Total Length            |
            +-----+---------+-----+-----------------+-------+-----------------+
            | 32  | Identification                  | Flags | Fragment Offset |
            +-----+---------------+-----------------+-------+-----------------+
            | 64  | Time to Live  | Protocol        | Header Checksum         |
            +-----+---------------+-----------------+-------------------------+
            | 96  | Source Address                                            |
            +-----+-----------------------------------------------------------+
            | 128 | Destination Address                                       |
            +-----+-----------------------------------------------------------+
            | 160 | Options with padding                                      |
            +-----+-----------------------------------------------------------+
            | 160 | Data                                                      |
            | to  |                                                           |
            | 360 |                                                           |
            +-----+-----------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderMinimumLength">
            <summary>
            The minimum length of the header in bytes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderMaximumLength">
            <summary>
            The maximum length of the header in bytes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Datagram.DefaultVersion">
            <summary>
            The version (4).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Datagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Datagram.CalculateIsValid">
            <summary>
            An IPv4 datagram is valid if its length is big enough for the header, the header checksum is correct and the payload is valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Version">
            <summary>
            The header length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderLength">
            <summary>
            The header length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.RealHeaderLength">
            <summary>
            The real number of bytes in the header (different than HeaderLength when the datagram is too small).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.TypeOfService">
            <summary>
            Type of Service field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.TotalLength">
            <summary>
            The length of the entire datagram as stated in the total length field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Identification">
            <summary>
            The value of the IPv4 ID field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Fragmentation">
            <summary>
            The fragmentation information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Ttl">
            <summary>
            The TTL field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Protocol">
            <summary>
            The IPv4 (next) protocol field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderChecksum">
            <summary>
            The header checksum value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.IsHeaderChecksumCorrect">
            <summary>
            True iff the header checksum value is correct according to the header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Source">
            <summary>
            The source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.CurrentDestination">
            <summary>
            The current destination address.
            This might not be the final destination when source routing options exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Destination">
            <summary>
            The final destination address.
            Takes into account the current destination and source routing options if they exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Options">
            <summary>
            The options field with all the parsed options if any exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.IsTransportChecksumCorrect">
            <summary>
            Returns whether the TCP or UDP checksum is correct.
            The protocol must be TCP or UDP.
            For UDP, the checksum is optional, so 0 checksum is still correct.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Payload">
            <summary>
            The payload of the datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.IpV4">
            <summary>
            The payload of the datagram as an IPv4 datagram (IP over IP).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Icmp">
            <summary>
            The payload of the datagram as an ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Igmp">
            <summary>
            The payload of the datagram as an IGMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Tcp">
            <summary>
            The payload of the datagram as a TCP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Gre">
            <summary>
            The payload of the datagram as a GRE datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Udp">
            <summary>
            The payload of the datagram as a UDP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Transport">
            <summary>
            Returns the Tranposrt Datagram.
            This is either a TCP Datagram or a UDP Datagram (according to the protocol).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV6.IpV6Address">
            <summary>
            Represents an IPv6 address.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV6.IpV6Address.SizeOf">
            <summary>
            The number of bytes the address take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.#ctor(PcapDotNet.Base.UInt128)">
            <summary>
            Create an address from a 128 bit integer.
            0 -> ::
            1 -> ::1
            256 -> ::100
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.#ctor(System.String)">
            <summary>
            Creates an address from an address string ("2001:0db8:0::22:1.2.3.4").
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.ToValue">
            <summary>
            Gets the address value as a 128 bit integer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.Equals(PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.Equals(System.Object)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.op_Equality(PcapDotNet.Packets.IpV6.IpV6Address,PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.op_Inequality(PcapDotNet.Packets.IpV6.IpV6Address,PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Two addresses are different if the have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.GetHashCode">
            <summary>
            The hash code of an address is the hash code of its 128 bit integer value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.ToString">
            <summary>
            Translates the address to a string (0ABC:1234:5678:0443:0ABC:1234:5678:0443).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV6.IpV6Address.Zero">
            <summary>
            The zero address (::).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV6.IpV6Address.MaxValue">
            <summary>
            The maximum address value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpLeaveGroupVersion2Layer">
            <summary>
            RFC 2236.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLeaveGroupVersion2Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSourceQuenchDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | Internet Header         |
            |     | + 64 bits of            |
            |     | Original Data Datagram  |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpSourceQuenchDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationDatagram">
            <summary>
            RFC 1256.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | reserved                |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry">
            <summary>
            RFC 1256.
            Represents an entry in Router Advertisement ICMP message.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.#ctor(PcapDotNet.Packets.IpV4.IpV4Address,System.Int32)">
            <summary>
            Creates an instance using the given router address and preference.
            </summary>
            <param name="routerAddress">The sending router's IP address(es) on the interface from which this message is sent.</param>
            <param name="routerAddressPreference">The preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet. A signed, twos-complement value; higher values mean more preferable.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.Equals(PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry)">
            <summary>
            Two entries are equal if they have the same router address and preference.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.Equals(System.Object)">
            <summary>
            Two entries are equal if they have the same router address and preference.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.GetHashCode">
            <summary>
            A xor of the hash codes of the router address and preference.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.RouterAddress">
            <summary>
            The sending router's IP address(es) on the interface from which this message is sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.RouterAddressPreference">
            <summary>
            The preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet. A signed, twos-complement value; higher values mean more preferable.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationReplyDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpInformationReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpResponseDatagram">
            <summary>
            RFC 2616.
            Represents an HTTP response.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpResponseDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseDatagram.IsRequest">
            <summary>
            False since this is message is a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseDatagram.StatusCode">
            <summary>
            The status code of the response.
            null if no status code exists.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseDatagram.ReasonPhrase">
            <summary>
            The data of the reason phrase.
            Example: OK
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpHeader">
            <summary>
            Represents HTTP header.
            The header is a container for HTTP fields.
            Insensitive to the case of HTTP field names.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.#ctor(System.Collections.Generic.IEnumerable{PcapDotNet.Packets.Http.HttpField})">
            <summary>
            Creates a header from an enumerable of fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.#ctor(PcapDotNet.Packets.Http.HttpField[])">
            <summary>
            Creates a header from an array of fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Equals(PcapDotNet.Packets.Http.HttpHeader)">
            <summary>
            Two HTTP headers are equal if they have the same fields with the same values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Equals(System.Object)">
            <summary>
            Two HTTP headers are equal if they have the same fields with the same values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.GetHashCode">
            <summary>
            Xor of the hash codes of the fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.ToString">
            <summary>
            Returns a string of all the fields with endline separators.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.GetEnumerator">
            <summary>
            Enumerates over the HTTP fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the HTTP header to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the header to.</param>
            <param name="offset">The offset in the given buffer to start writing the header.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Write(System.Byte[],System.Int32@)">
            <summary>
            Writes the HTTP header to the given buffer in the given offset.
            Increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the header to.</param>
            <param name="offset">The offset in the given buffer to start writing the header. Incremented by the number of bytes written.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.Empty">
            <summary>
            An empty HTTP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.BytesLength">
            <summary>
            The number of bytes the header takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.Item(System.String)">
            <summary>
            Returns the field with the given field name or null if it doesn't exist.
            Case insensitive.
            </summary>
            <param name="fieldName">The case insensitive name of the field.</param>
            <returns>The field with the matching case insensitive name or null if it doesn't exist.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.TransferEncoding">
            <summary>
            The HTTP Transfer Encoding field if it exists (null otherwise).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.ContentLength">
            <summary>
            The HTTP Content Length field if it exists (null otherwise).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.ContentType">
            <summary>
            The HTTP Content Type field if it exists (null otherwise).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.Trailer">
            <summary>
            The HTTP Trailer field if it exists (null otherwise).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataText">
            <summary>
            A resource data that contains 0 or more DNS strings.
            Each DNS string is a segment of up to 255 bytes.
            The format of each DNS string is one byte for the length of the string and then the specified number of bytes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataText.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{PcapDotNet.Packets.DataSegment})">
            <summary>
            Constructs the resource data from the given list of strings, each up to 255 bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataText.Text">
            <summary>
            The list of strings, each up to 255 bytes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNInfo">
            <summary>
            Reid.
            <pre>
            +---------------------+
            | One ore more strings|
            +---------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNInfo.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{PcapDotNet.Packets.DataSegment})">
            <summary>
            Constructs the resource data from strings.
            </summary>
            <param name="strings">A descriptive text in one or more strings.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNInfo.#ctor(PcapDotNet.Packets.DataSegment[])">
            <summary>
            Constructs the resource data from strings.
            </summary>
            <param name="strings">A descriptive text in one or more strings.</param>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataMailExchange">
            <summary>
            RFC 1035.
            <pre>
            +-----+------------+
            | bit | 0-15       |
            +-----+------------+
            | 0   | PREFERENCE |
            +-----+------------+
            | 16  | EXCHANGE   |
            | ... |            |
            +-----+------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataMailExchange.#ctor(System.UInt16,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs mail exchange resource data from preference and host.
            </summary>
            <param name="preference">
            Specifies the preference given to this RR among others at the same owner.
            Lower values are preferred.
            </param>
            <param name="mailExchangeHost">
            Specifies a host willing to act as a mail exchange for the owner name.
            </param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataMailExchange.Preference">
            <summary>
            Specifies the preference given to this RR among others at the same owner.
            Lower values are preferred.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataMailExchange.MailExchangeHost">
            <summary>
            Specifies a host willing to act as a mail exchange for the owner name.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner">
            <summary>
            RFC 3658.
            <pre>
            0 Or more of:
            +-----+---------+-----------+-------------+
            | bit | 0-15    | 16-23     | 24-31       |
            +-----+---------+-----------+-------------+
            | 0   | key tag | algorithm | Digest type |
            +-----+---------+-----------+-------------+
            | 32  | digest                            |
            | ... |                                   |
            +-----+-----------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.#ctor(System.UInt16,PcapDotNet.Packets.Dns.DnsAlgorithm,PcapDotNet.Packets.Dns.DnsDigestType,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the key tag, algorithm, digest type and digest fields.
            </summary>
            <param name="keyTag">
            Lists the key tag of the DNSKEY RR referred to by the DS record.
            The Key Tag used by the DS RR is identical to the Key Tag used by RRSIG RRs.
            Calculated as specified in RFC 2535.
            </param>
            <param name="algorithm">Algorithm must be allowed to sign DNS data.</param>
            <param name="digestType">An identifier for the digest algorithm used.</param>
            <param name="digest">
            Calculated over the canonical name of the delegated domain name followed by the whole RDATA of the KEY record (all four fields).
            digest = hash(canonical FQDN on KEY RR | KEY_RR_rdata)
            KEY_RR_rdata = Flags | Protocol | Algorithm | Public Key
            The size of the digest may vary depending on the digest type.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.Equals(PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner)">
            <summary>
            Two DnsResourceDataDelegationSigner are equal iff their key tag, algorithm, digest type and digest fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.Equals(System.Object)">
            <summary>
            Two DnsResourceDataDelegationSigner are equal iff their key tag, algorithm, digest type and digest fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.GetHashCode">
            <summary>
            A hash code of the combination of the key tag, algorithm, digest type and digest fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.KeyTag">
            <summary>
            Lists the key tag of the DNSKEY RR referred to by the DS record.
            The Key Tag used by the DS RR is identical to the Key Tag used by RRSIG RRs.
            Calculated as specified in RFC 2535.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.Algorithm">
            <summary>
            Algorithm must be allowed to sign DNS data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.DigestType">
            <summary>
            An identifier for the digest algorithm used.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.Digest">
            <summary>
            Calculated over the canonical name of the delegated domain name followed by the whole RDATA of the KEY record (all four fields).
            digest = hash(canonical FQDN on KEY RR | KEY_RR_rdata)
            KEY_RR_rdata = Flags | Protocol | Algorithm | Public Key
            The size of the digest may vary depending on the digest type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataDelegationSigner.ExtraDigest">
            <summary>
            The extra digest bytes after number of bytes according to the digest type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData">
            <summary>
            TCP Alternate Checksum Data Option (RFC 1146).
            
            <para>
            The format of the TCP Alternate Checksum Data Option is:
            <pre>
            +---------+---------+---------+     +---------+
            | Kind=15 |Length=N |  data   | ... |  data   |
            +---------+---------+---------+     +---------+
            </pre>
            </para>
            
            <para>
            This field is used only when the alternate checksum that is negotiated is longer than 16 bits. 
            These checksums will not fit in the checksum field of the TCP header and thus at least part of them must be put in an option.  
            Whether the checksum is split between the checksum field in the TCP header and the option or the entire checksum is placed in the option 
            is determined on a checksum by checksum basis.
            </para>
            
            <para>
            The length of this option will depend on the choice of alternate checksum algorithm for this connection.
            </para>
            
            <para>
            While computing the alternate checksum, the TCP checksum field and the data portion TCP Alternate Checksum Data Option are replaced with zeros.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.#ctor(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates the option using the given data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.#ctor">
            <summary>
            the default option data is no data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Equals(PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData)">
            <summary>
            Two alternate checksum data options are equal if they have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two alternate checksum data options are equal if they have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.GetHashCode">
            <summary>
            The hash code of this option is the hash code of the option type xored with the hash code of the data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Data">
            <summary>
            The alternate checksum data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionSimple">
            <summary>
            A simple IPv4 option - holds only the type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSimple.OptionLength">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionSimple.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionSimple.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReportVersion2Layer">
            <summary>
            RFC 2236.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion2Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer">
            <summary>
            RFC 2521.
            Represents an ICMP Security Failures layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.Pointer">
            <summary>
            An offset into the Original Internet Headers that locates the most significant octet of the offending SPI.  
            Will be zero when no SPI is present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeTraceRoute">
            <summary>
            The ICMP code values for Traceroute ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTraceRoute.OutboundPacketSuccessfullyForwarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTraceRoute.NoRouteForOutboundPacketDiscarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpContentTypeField">
            <summary>
            RFC 2616.
            The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method,
            the media type that would have been sent had the request been a GET.
            
            <pre>
            Content-Type   = "Content-Type" ":" media-type
            </pre>
            
            An example of the field is
            <pre>
            Content-Type: text/html; charset=ISO-8859-4
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentTypeField.FieldName">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentTypeField.FieldNameUpper">
            <summary>
            The field name in uppercase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentTypeField.#ctor(System.String,System.String,PcapDotNet.Packets.Http.HttpFieldParameters)">
            <summary>
            Creates a Content Type Field according to the given media type, media subtype and parameters.
            </summary>
            <param name="mediaType">The main type of the content of this HTTP message.</param>
            <param name="mediaSubtype">The subtype of the content of this HTTP message.</param>
            <param name="parameters">Parameters on the specific type.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentTypeField.Equals(PcapDotNet.Packets.Http.HttpContentTypeField)">
            <summary>
            True iff the two fields are equal.
            Two content type fields are equal if they have the same media type and subtype and same parameters.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentTypeField.Equals(PcapDotNet.Packets.Http.HttpField)">
            <summary>
            True iff the two fields are equal.
            Two content type fields are equal if they have the same media type and subtype and same parameters.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentTypeField.MediaType">
            <summary>
            The main type of the content of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentTypeField.MediaSubtype">
            <summary>
            The subtype of the content of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentTypeField.Parameters">
            <summary>
            Parameters on the specific type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsSecNSec3Flags">
            <summary>
            RFC 5155.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSecNSec3Flags.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsSecNSec3Flags.OptOut">
            <summary>
            RFC 5155.
            Indicates whether this NSEC3 RR may cover unsigned delegations.
            If set, the NSEC3 record covers zero or more unsigned delegations.
            If clear, the NSEC3 record covers zero unsigned delegations.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink">
            <summary>
            Wijngaards.
            <pre>
            +----------------------+
            | Previous Domain Name |
            +----------------------+
            | Next Domain Name     |
            +----------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs the resource data from the previous and next fields.
            </summary>
            <param name="previous">The start, or previous name.</param>
            <param name="next">End or next name in the list.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink.Equals(PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink)">
            <summary>
            Two trust anchor link resource datas are equal iff their previous and next fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink.Equals(System.Object)">
            <summary>
            Two trust anchor link resource datas are equal iff their previous and next fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink.GetHashCode">
            <summary>
            The combined hash code of the previous and next fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink.Previous">
            <summary>
            The start, or previous name.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataTrustAnchorLink.Next">
            <summary>
            End or next name in the list.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataString">
            <summary>
            A DNS string.
            Any segment of bytes up to 255 characters is valid.
            The format is one byte for the length of the string and then the specified number of bytes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataString.#ctor(PcapDotNet.Packets.DataSegment)">
            <summary>
            Creates the resource data from the given string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataString.Equals(PcapDotNet.Packets.Dns.DnsResourceDataString)">
            <summary>
            Two string resource datas are equals if they have the same string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataString.Equals(System.Object)">
            <summary>
            Two string resource datas are equals if they have the same string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataString.GetHashCode">
            <summary>
            The hash code of the string.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataString.String">
            <summary>
            The value of the data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer">
            <summary>
            RFCs 2915, 3403.
            <pre>
            +-----+-------+------------+
            | bit | 0-15  | 16-31      |
            +-----+-------+------------+
            | 0   | Order | Preference |
            +-----+-------+------------+
            | 32  | FLAGS              |
            | ... |                    |
            +-----+--------------------+
            |     | SERVICES           |
            | ... |                    |
            +-----+--------------------+
            |     | REGEXP             |
            | ... |                    |
            +-----+--------------------+
            |     | REPLACEMENT        |
            | ... |                    |
            +-----+--------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.#ctor(System.UInt16,System.UInt16,PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs an instance out of the order, preference, flags, services, regular expression and replacement fields.
            </summary>
            <param name="order">
            A 16-bit unsigned integer specifying the order in which the NAPTR records MUST be processed 
            in order to accurately represent the ordered list of Rules.
            The ordering is from lowest to highest.
            If two records have the same order value then they are considered to be the same rule and should be selected 
            based on the combination of the Preference values and Services offered.
            </param>
            <param name="preference">
            Although it is called "preference" in deference to DNS terminology, this field is equivalent to the Priority value in the DDDS Algorithm.
            It specifies the order in which NAPTR records with equal Order values should be processed, low numbers being processed before high numbers.
            This is similar to the preference field in an MX record, 
            and is used so domain administrators can direct clients towards more capable hosts or lighter weight protocols.
            A client may look at records with higher preference values if it has a good reason to do so such 
            as not supporting some protocol or service very well.
            The important difference between Order and Preference is that once a match is found the client must not consider records 
            with a different Order but they may process records with the same Order but different Preferences.
            The only exception to this is noted in the second important Note in the DDDS algorithm specification 
            concerning allowing clients to use more complex Service determination between steps 3 and 4 in the algorithm.
            Preference is used to give communicate a higher quality of service to rules that are considered the same from an authority standpoint 
            but not from a simple load balancing standpoint.
            
            It is important to note that DNS contains several load balancing mechanisms and if load balancing among otherwise equal services 
            should be needed then methods such as SRV records or multiple A records should be utilized to accomplish load balancing.
            </param>
            <param name="flags">
            Flags to control aspects of the rewriting and interpretation of the fields in the record.
            Flags are single characters from the set A-Z and 0-9.
            The case of the alphabetic characters is not significant.
            The field can be empty.
            
            It is up to the Application specifying how it is using this Database to define the Flags in this field.
            It must define which ones are terminal and which ones are not.
            </param>
            <param name="services">
            Specifies the Service Parameters applicable to this this delegation path.
            It is up to the Application Specification to specify the values found in this field.
            </param>
            <param name="regularExpression">
            A substitution expression that is applied to the original string held by the client in order to construct the next domain name to lookup.
            See the DDDS Algorithm specification for the syntax of this field.
            
            As stated in the DDDS algorithm, The regular expressions must not be used in a cumulative fashion, 
            that is, they should only be applied to the original string held by the client, never to the domain name produced by a previous NAPTR rewrite.
            The latter is tempting in some applications but experience has shown such use to be extremely fault sensitive, very error prone, 
            and extremely difficult to debug.
            </param>
            <param name="replacement">
            The next domain-name to query for depending on the potential values found in the flags field.
            This field is used when the regular expression is a simple replacement operation.
            Any value in this field must be a fully qualified domain-name.
            Name compression is not to be used for this field.
            
            This field and the Regexp field together make up the Substitution Expression in the DDDS Algorithm.
            It is simply a historical optimization specifically for DNS compression that this field exists.
            The fields are also mutually exclusive.  
            If a record is returned that has values for both fields then it is considered to be in error and SHOULD be either ignored or an error returned.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.Equals(PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer)">
            <summary>
            Two DnsResourceDataNamingAuthorityPointer are equal iff their order, preference, flags, services, regular expression and replacement fields 
            are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.Equals(System.Object)">
            <summary>
            Two DnsResourceDataNamingAuthorityPointer are equal iff their order, preference, flags, services, regular expression and replacement fields 
            are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.GetHashCode">
            <summary>
            A hash code of the combination of the order, preference, flags, services, regular expression and replacement fields. 
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.Order">
            <summary>
            A 16-bit unsigned integer specifying the order in which the NAPTR records MUST be processed 
            in order to accurately represent the ordered list of Rules.
            The ordering is from lowest to highest.
            If two records have the same order value then they are considered to be the same rule and should be selected 
            based on the combination of the Preference values and Services offered.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.Preference">
            <summary>
            Although it is called "preference" in deference to DNS terminology, this field is equivalent to the Priority value in the DDDS Algorithm.
            It specifies the order in which NAPTR records with equal Order values should be processed, low numbers being processed before high numbers.
            This is similar to the preference field in an MX record, 
            and is used so domain administrators can direct clients towards more capable hosts or lighter weight protocols.
            A client may look at records with higher preference values if it has a good reason to do so such 
            as not supporting some protocol or service very well.
            The important difference between Order and Preference is that once a match is found the client must not consider records 
            with a different Order but they may process records with the same Order but different Preferences.
            The only exception to this is noted in the second important Note in the DDDS algorithm specification 
            concerning allowing clients to use more complex Service determination between steps 3 and 4 in the algorithm.
            Preference is used to give communicate a higher quality of service to rules that are considered the same from an authority standpoint 
            but not from a simple load balancing standpoint.
            
            It is important to note that DNS contains several load balancing mechanisms and if load balancing among otherwise equal services 
            should be needed then methods such as SRV records or multiple A records should be utilized to accomplish load balancing.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.Flags">
            <summary>
            Flags to control aspects of the rewriting and interpretation of the fields in the record.
            Flags are single characters from the set A-Z and 0-9.
            The case of the alphabetic characters is not significant.
            The field can be empty.
            
            It is up to the Application specifying how it is using this Database to define the Flags in this field.
            It must define which ones are terminal and which ones are not.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.Services">
            <summary>
            Specifies the Service Parameters applicable to this this delegation path.
            It is up to the Application Specification to specify the values found in this field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.RegularExpression">
            <summary>
            A substitution expression that is applied to the original string held by the client in order to construct the next domain name to lookup.
            See the DDDS Algorithm specification for the syntax of this field.
            
            As stated in the DDDS algorithm, The regular expressions must not be used in a cumulative fashion, 
            that is, they should only be applied to the original string held by the client, never to the domain name produced by a previous NAPTR rewrite.
            The latter is tempting in some applications but experience has shown such use to be extremely fault sensitive, very error prone, 
            and extremely difficult to debug.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNamingAuthorityPointer.Replacement">
            <summary>
            The next domain-name to query for depending on the potential values found in the flags field.
            This field is used when the regular expression is a simple replacement operation.
            Any value in this field must be a fully qualified domain-name.
            Name compression is not to be used for this field.
            
            This field and the Regexp field together make up the Substitution Expression in the DDDS Algorithm.
            It is simply a historical optimization specifically for DNS compression that this field exists.
            The fields are also mutually exclusive.  
            If a record is returned that has values for both fields then it is considered to be in error and SHOULD be either ignored or an error returned.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataHostInformation">
            <summary>
            RFC 1035.
            <pre>
            +-----+
            | CPU |
            +-----+ 
            | OS  |
            +-----+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataHostInformation.#ctor(PcapDotNet.Packets.DataSegment,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs the resource data from the CPU and OS parameters.
            </summary>
            <param name="cpu">A string which specifies the CPU type.</param>
            <param name="os">A string which specifies the operating system type.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataHostInformation.Cpu">
            <summary>
            A string which specifies the CPU type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataHostInformation.Os">
            <summary>
            A string which specifies the operating system type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsAlgorithm">
            <summary>
            RFCs 2535, 2536, 2537, 2539, 3110, 3755, 4034, 5155, 5702, 5933.
            The key algorithm.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.None">
            <summary>
            RFC 4034.
            Field is not used or indicates that the algorithm is unknown to a secure DNS, 
            which may simply be the result of the algorithm not having been standardized for DNSSEC.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.RsaMd5">
            <summary>
            RFCs 2537, 4034.
            RSA/MD5.
            Deprecated.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.DiffieHellman">
            <summary>
            RFC 2539.
            Diffie-Hellman.
            Implementation is optional, key only.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.Dsa">
            <summary>
            RFCs 2536, 3755.
            DSA - Digital Signature Algorithm.
            Implementation is mandatory.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.EllipticCurveCrypto">
            <summary>
            Reserved for elliptic curve crypto.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.RsaSha1">
            <summary>
            RFCs 3110, 3755.
            RSA/SHA-1.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.DsaNextSecure3Sha1">
            <summary>
            RFC 5155.
            DSA-NSEC3-SHA1.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.RsaSha1NextSecure3Sha1">
            <summary>
            RFC 5155.
            RSASHA1-NSEC3-SHA1.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.RsaSha256">
            <summary>
            RFC 5702.
            RSA/SHA-256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.RsaSha512">
            <summary>
            RFC 5702.
            RSA/SHA-512.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.EllipticCurveCryptoGost">
            <summary>
            RFC 5933.
            GOST R 34.10-2001.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.Indirect">
            <summary>
            RFC 4034.
            Reserved for Indirect Keys.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.PrivateDns">
            <summary>
            RFCs 2535, 3755.
            Private algorithms - domain name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsAlgorithm.PrivateObjectIdentifier">
            <summary>
            RFCs 2535, 3755.
            Private algorithms - OID.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsAddressPrefix">
            <summary>
            RFC 3123.
            <pre>
            +-----+--------+---+-----------+
            | bit | 0-7    | 8 | 9-15      |
            +-----+--------+---+-----------+
            | 0   | ADDRESSFAMILY          |
            +-----+--------+---+-----------+
            | 16  | PREFIX | N | AFDLENGTH |
            +-----+--------+---+-----------+
            | 32  | AFDPART                |
            | ... |                        |
            +-----+------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsAddressPrefix.#ctor(PcapDotNet.Packets.AddressFamily,System.Byte,System.Boolean,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the address family, prefix length, negation and address family dependent part fields.
            </summary>
            <param name="addressFamily">The address family value.</param>
            <param name="prefixLength">
            Prefix length.
            Upper and lower bounds and interpretation of this value are address family specific.
            
            For IPv4, specifies the number of bits of the IPv4 address starting at the most significant bit.
            Legal values range from 0 to 32.
            
            For IPv6, specifies the number of bits of the IPv6 address starting at the most significant bit.
            Legal values range from 0 to 128.
            </param>
            <param name="negation">Negation flag, indicates the presence of the "!" character in the textual format.</param>
            <param name="addressFamilyDependentPart">
            For IPv4, the encoding follows the encoding specified for the A RR by RFC 1035.
            Trailing zero octets do not bear any information (e.g., there is no semantic difference between 10.0.0.0/16 and 10/16) in an address prefix,
            so the shortest possible AddressFamilyDependentPart can be used to encode it.
            However, for DNSSEC (RFC 2535) a single wire encoding must be used by all.
            Therefore the sender must not include trailing zero octets in the AddressFamilyDependentPart regardless of the value of PrefixLength.
            This includes cases in which AddressFamilyDependentPart length times 8 results in a value less than PrefixLength.
            The AddressFamilyDependentPart is padded with zero bits to match a full octet boundary.
            An IPv4 AddressFamilyDependentPart has a variable length of 0 to 4 octets.
            
            For IPv6, the 128 bit IPv6 address is encoded in network byte order (high-order byte first).
            The sender must not include trailing zero octets in the AddressFamilyDependentPart regardless of the value of PrefixLength.
            This includes cases in which AddressFamilyDependentPart length times 8 results in a value less than PrefixLength.
            The AddressFamilyDependentPart is padded with zero bits to match a full octet boundary.
            An IPv6 AddressFamilyDependentPart has a variable length of 0 to 16 octets.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsAddressPrefix.Equals(PcapDotNet.Packets.Dns.DnsAddressPrefix)">
            <summary>
            Two DnsAddressPrefix are equal iff their address family, prefix length, negation and address family dependent part are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsAddressPrefix.Equals(System.Object)">
            <summary>
            Two DnsAddressPrefix are equal iff their address family, prefix length, negation and address family dependent part fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsAddressPrefix.GetHashCode">
            <summary>
            A hash code based on the address family, prefix length, negation and address family dependent part fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsAddressPrefix.AddressFamily">
            <summary>
            The address family value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsAddressPrefix.PrefixLength">
            <summary>
            Prefix length.
            Upper and lower bounds and interpretation of this value are address family specific.
            
            For IPv4, specifies the number of bits of the IPv4 address starting at the most significant bit.
            Legal values range from 0 to 32.
            
            For IPv6, specifies the number of bits of the IPv6 address starting at the most significant bit.
            Legal values range from 0 to 128.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsAddressPrefix.Negation">
            <summary>
            Negation flag, indicates the presence of the "!" character in the textual format.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsAddressPrefix.AddressFamilyDependentPart">
            <summary>
            For IPv4, the encoding follows the encoding specified for the A RR by RFC 1035.
            Trailing zero octets do not bear any information (e.g., there is no semantic difference between 10.0.0.0/16 and 10/16) in an address prefix,
            so the shortest possible AddressFamilyDependentPart can be used to encode it.
            However, for DNSSEC (RFC 2535) a single wire encoding must be used by all.
            Therefore the sender must not include trailing zero octets in the AddressFamilyDependentPart regardless of the value of PrefixLength.
            This includes cases in which AddressFamilyDependentPart length times 8 results in a value less than PrefixLength.
            The AddressFamilyDependentPart is padded with zero bits to match a full octet boundary.
            An IPv4 AddressFamilyDependentPart has a variable length of 0 to 4 octets.
            
            For IPv6, the 128 bit IPv6 address is encoded in network byte order (high-order byte first).
            The sender must not include trailing zero octets in the AddressFamilyDependentPart regardless of the value of PrefixLength.
            This includes cases in which AddressFamilyDependentPart length times 8 results in a value less than PrefixLength.
            The AddressFamilyDependentPart is padded with zero bits to match a full octet boundary.
            An IPv6 AddressFamilyDependentPart has a variable length of 0 to 16 octets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsAddressPrefix.Length">
            <summary>
            The number of bytes this resource data takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsOptVersion">
            <summary>
            RFC 2671.
            The implementation level of whoever sets it for the OPT resource record.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsOptVersion.Version0">
            <summary>
            Full conformance with the specification.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Fragmentation">
            <summary>
            Represents IPv4 Fragmentation information.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.#ctor(PcapDotNet.Packets.IpV4.IpV4FragmentationOptions,System.UInt16)">
            <summary>
            Creates fragmentation field value according to the given information.
            </summary>
            <param name="options">Options for fragmentation (must be one of the values of the enum).</param>
            <param name="offset">This field indicates where in the complete datagram this fragment belongs. Measured in bytes but must divide by 8.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Equals(PcapDotNet.Packets.IpV4.IpV4Fragmentation)">
            <summary>
            Two framentations are equal if they are exactly the same fragmentation (options and offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Equals(System.Object)">
            <summary>
            Two framentations are equal if they are exactly the same fragmentation (options and offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.op_Equality(PcapDotNet.Packets.IpV4.IpV4Fragmentation,PcapDotNet.Packets.IpV4.IpV4Fragmentation)">
            <summary>
            Two framentations are equal if they are exactly the same fragmentation (options and offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.op_Inequality(PcapDotNet.Packets.IpV4.IpV4Fragmentation,PcapDotNet.Packets.IpV4.IpV4Fragmentation)">
            <summary>
            Two framentations are different if they are different fragmentation (options or offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.GetHashCode">
            <summary>
            The hash code of the fragmentation is the hash code of its combined flags and offset 16 bit field.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Fragmentation.None">
            <summary>
            No fragmentation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Options">
            <summary>
            Options for fragmentation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Offset">
            <summary>
            This field indicates where in the complete datagram this fragment belongs. Measured in bytes but must divide by 8.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionUnknown">
            <summary>
            An unknown IPv4 option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType,System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates an unknown IPv4 option by the given type and data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.#ctor">
            <summary>
            The default unknown option is with type 255 and no data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Equals(PcapDotNet.Packets.IpV4.IpV4OptionUnknown)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.GetHashCode">
            <summary>
            The hash code for an unknown option is the hash code for the option type xored with the hash code of the data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.CreateInstance(PcapDotNet.Packets.IpV4.IpV4OptionType,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Creates an unknown option from its type and by reading a buffer for its value.
            </summary>
            <param name="optionType">The type of the unknown option.</param>
            <param name="buffer">The buffer of bytes to read the value of the unknown option.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="valueLength">The number of bytes to read from the buffer.</param>
            <returns>An option created from the given type and buffer.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Data">
            <summary>
            Returns the Data of the option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpGroupRecord">
            <summary>
            Represents an IGMP group record with all the relevant fields.
            Used to build an IGMP report of version 3.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.#ctor(PcapDotNet.Packets.Igmp.IgmpRecordType,PcapDotNet.Packets.IpV4.IpV4Address,System.Collections.ObjectModel.ReadOnlyCollection{PcapDotNet.Packets.IpV4.IpV4Address},PcapDotNet.Packets.Datagram)">
            <summary>
            Create the record according to all the fields.
            </summary>
            <param name="recordType">The type of group record included in the report message.</param>
            <param name="multicastAddress">The Multicast Address field contains the IP multicast address to which this Group Record pertains.</param>
            <param name="sourceAddresses">
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </param>
            <param name="auxiliaryData">
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.#ctor(PcapDotNet.Packets.Igmp.IgmpRecordType,PcapDotNet.Packets.IpV4.IpV4Address,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},PcapDotNet.Packets.Datagram)">
            <summary>
            Create the record according to all the fields.
            </summary>
            <param name="recordType">The type of group record included in the report message.</param>
            <param name="multicastAddress">The Multicast Address field contains the IP multicast address to which this Group Record pertains.</param>
            <param name="sourceAddresses">
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </param>
            <param name="auxiliaryData">
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.ToString">
            <summary>
            A string containing the record type, multicast address, source addresses and the number of bytes in teh auxiliary data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.Equals(PcapDotNet.Packets.Igmp.IgmpGroupRecord)">
            <summary>
            Two records are equal if the record type, multicast address, source addresses and auxiliary data are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.Equals(System.Object)">
            <summary>
            Two records are equal if the record type, multicast address, source addresses and auxiliary data are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.GetHashCode">
            <summary>
            The hash code of a record is the xor of the hash code of the record type, multicast address, source addresses and auxiliary data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.RecordType">
            <summary>
            The type of group record included in the report message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.MulticastAddress">
            <summary>
            The Multicast Address field contains the IP multicast address to which this Group Record pertains.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.AuxiliaryData">
            <summary>
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code">
            <summary>
            The code of the IGMP message for Create Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestGranted">
            <summary>
            Request Granted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedNoResources">
            <summary>
            Request Denied - No Resources.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedInvalidCode">
            <summary>
            Request Denied - Invalid Code.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedInvalidGroupAddress">
            <summary>
            Request Denied - Invalid Group Address.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedInvalidAccessKey">
            <summary>
            Request Denied - Invalid Access Key.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn5Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn6Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn7Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn8Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn9Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn10Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn11Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn12Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn13Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn14Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn15Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn16Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn17Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn18Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn19Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn20Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn21Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn22Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn23Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn24Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn25Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn26Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn27Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn28Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn29Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn30Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn31Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn32Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn33Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn34Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn35Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn36Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn37Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn38Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn39Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn40Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn41Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn42Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn43Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn44Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn45Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn46Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn47Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn48Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn49Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn50Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn51Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn52Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn53Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn54Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn55Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn56Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn57Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn58Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn59Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn60Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn61Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn62Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn63Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn64Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn65Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn66Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn67Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn68Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn69Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn70Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn71Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn72Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn73Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn74Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn75Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn76Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn77Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn78Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn79Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn80Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn81Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn82Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn83Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn84Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn85Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn86Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn87Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn88Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn89Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn90Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn91Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn92Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn93Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn94Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn95Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn96Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn97Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn98Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn99Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn100Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn101Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn102Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn103Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn104Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn105Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn106Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn107Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn108Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn109Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn110Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn111Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn112Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn113Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn114Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn115Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn116Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn117Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn118Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn119Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn120Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn121Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn122Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn123Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn124Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn125Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn126Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn127Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn128Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn129Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn130Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn131Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn132Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn133Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn134Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn135Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn136Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn137Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn138Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn139Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn140Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn141Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn142Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn143Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn144Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn145Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn146Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn147Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn148Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn149Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn150Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn151Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn152Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn153Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn154Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn155Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn156Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn157Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn158Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn159Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn160Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn161Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn162Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn163Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn164Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn165Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn166Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn167Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn168Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn169Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn170Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn171Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn172Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn173Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn174Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn175Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn176Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn177Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn178Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn179Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn180Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn181Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn182Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn183Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn184Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn185Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn186Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn187Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn188Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn189Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn190Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn191Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn192Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn193Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn194Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn195Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn196Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn197Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn198Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn199Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn200Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn201Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn202Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn203Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn204Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn205Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn206Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn207Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn208Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn209Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn210Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn211Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn212Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn213Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn214Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn215Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn216Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn217Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn218Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn219Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn220Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn221Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn222Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn223Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn224Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn225Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn226Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn227Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn228Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn229Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn230Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn231Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn232Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn233Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn234Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn235Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn236Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn237Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn238Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn239Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn240Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn241Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn242Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn243Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn244Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn245Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn246Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn247Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn248Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn249Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn250Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn251Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn252Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn253Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn254Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn255Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion1Layer">
            <summary>
            RFC 1112.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion1Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion1Layer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+---------+------+-----------+
            | Bit | 0-7     | 8-15 | 16-31     |
            +-----+---------+------+-----------+
            | 0   | Type    | Code | Checksum  |
            +-----+---------+------+-----------+
            | 32  | Pointer | unused           |
            +-----+---------+------------------+
            | 64  | Internet Header            |
            |     | + 64 bits of               |
            |     | Original Data Datagram     |
            +-----+----------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header, the IPv4's payload is in the expected size
            and the pointer points to a byte within the IPv4 header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram.Pointer">
            <summary>
            The pointer identifies the octet of the original datagram's header where the error was detected (it may be in the middle of an option).  
            For example, 1 indicates something is wrong with the Type of Service, and (if there are options present) 20 indicates something is wrong with the type code of the first option.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationReplyLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpInformationReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure">
            <summary>
            The different ICMP code values for Security Failures ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.BadSecurityParametersIndex">
            <summary>
            RFC 2521.
            Indicates that a received datagram includes a Security Parameters Index (SPI) that is invalid or has expired.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.AuthenticationFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed the authenticity or integrity check for a given SPI.
            
            <para>
            Note that the SPI may indicate an outer Encapsulating Security Protocol when a separate Authentication Header SPI is hidden inside.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.DecompressionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decompression check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.DecryptionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decryption check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.NeedAuthentication">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted without additional authentication.
            
            <para>
            In this case, either no SPI is present, or an unsuitable SPI is present.  
            For example, an encryption SPI without integrity arrives from a secure operating system with mutually suspicious users.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.NeedAuthorization">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted because it has insufficient authorization.
            
            <para>
            In this case, an authentication SPI is present that is inappropriate for the target transport or application.  
            The principle party denoted by the SPI does not have proper authorization for the facilities used by the datagram.  
            For example, the party is authorized for Telnet access, but not for FTP access.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed">
            <summary>
            The ICMP code values for Code Conversion Failed ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnknownOrUnspecifiedError">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.DoNotConvertOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnknownMandatoryOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.KnownUnsupportedOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnsupportedTransportProtocol">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.OverallLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.IpHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.TransportProtocolIsBiggerThan255">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.PortConversionOutOfRange">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.TransportHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.Code32BitRolloverMissingAndAckSet">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnknownMandatoryTransportOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpTrailerField">
            <summary>
            RFC 2616.
            The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded 
            with chunked transfer-coding.
            <pre>
            Trailer  = "Trailer" ":" 1#field-name
            </pre>
            An HTTP/1.1 message should include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer.
            Doing so allows the recipient to know which header fields to expect in the trailer.
            
            If no Trailer header field is present, the trailer should not include any header fields.
            
            Message header fields listed in the Trailer header field must not include the following header fields:
            * Transfer-Encoding.
            * Content-Length.
            * Trailer.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpTrailerField.FieldName">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpTrailerField.FieldNameUpper">
            <summary>
            The field name in uppercase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTrailerField.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a Trailer Field according to the given field names.
            </summary>
            <param name="fieldsNames">The names of the fields that should be encoded in the chunked body trailer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTrailerField.Equals(PcapDotNet.Packets.Http.HttpTrailerField)">
            <summary>
            True iff the two fields are equal.
            Two trailer fields are equal iff they have the fields names in the same order.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTrailerField.Equals(PcapDotNet.Packets.Http.HttpField)">
            <summary>
            True iff the two fields are equal.
            Two trailer fields are equal iff they have the fields names in the same order.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpTrailerField.FieldsNames">
            <summary>
            The names of the fields that should be encoded in the chunked body trailer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily">
            <summary>
            A value representing the syntax and semantics of the Routing Information field.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily.None">
            <summary>
            No address family
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily.IpSourceRoute">
            <summary>
            The Routing Information field will consist of a list of IP addresses and indicates an IP source route.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily.AsSourceRoute">
            <summary>
            the Routing Information field will consist of a list of Autonomous System numbers and indicates an AS source route.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Endianity">
            <summary>
            The two possible endianities.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Endianity.Small">
            <summary>
            Small endianity - bytes are read from the high offset to the low offset.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Endianity.Big">
            <summary>
            Big endianity - bytes are read from the low offset to the high offset.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService">
            <summary>
            RFC 1035.
            <pre>
            +-----+----------+---------+
            | bit | 0-7      | 8-31    |
            +-----+----------+---------+
            | 0   | Address            |
            +-----+----------+---------+
            | 32  | Protocol | Bit Map | (Bit Map is variable multiple of 8 bits length)
            +-----+----------+---------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService.#ctor(PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.IpV4.IpV4Protocol,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance from the address, protocol and bitmap fields.
            </summary>
            <param name="address">The service address.</param>
            <param name="protocol">Specifies an IP protocol number.</param>
            <param name="bitmap">Has one bit per port of the specified protocol.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService.Equals(PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService)">
            <summary>
            Two DnsResourceDataWellKnownService are equal iff their address, protocol and bitmap fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService.Equals(System.Object)">
            <summary>
            Two DnsResourceDataWellKnownService are equal iff their address, protocol and bitmap fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService.GetHashCode">
            <summary>
            A hash code based on the address, protocol and bitmap fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService.Address">
            <summary>
            The service address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService.Protocol">
            <summary>
            Specifies an IP protocol number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataWellKnownService.Bitmap">
            <summary>
            Has one bit per port of the specified protocol.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataRKey">
            <summary>
            Reid.
            <pre>
            +-----+-------+----------+-----------+
            | bit | 0-15  | 16-23    | 24-31     |
            +-----+-------+----------+-----------+
            | 0   | flags | protocol | algorithm |
            +-----+-------+----------+-----------+
            | 32  | public key                   |
            | ... |                              |
            +-----+------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataRKey.#ctor(System.UInt16,System.Byte,PcapDotNet.Packets.Dns.DnsAlgorithm,PcapDotNet.Packets.DataSegment)">
            <summary>
            Constructs an instance out of the flags, protocol, algorithm and public key fields.
            </summary>
            <param name="flags">Reserved and must be zero.</param>
            <param name="protocol">Must be set to 1.</param>
            <param name="algorithm">The key algorithm parallel to the same field for the SIG resource.</param>
            <param name="publicKey">The public key value.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataRKey.Equals(PcapDotNet.Packets.Dns.DnsResourceDataRKey)">
            <summary>
            Two DnsResourceDataRKey are equal iff their flags, protocol, algorithm and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataRKey.Equals(System.Object)">
            <summary>
            Two DnsResourceDataRKey are equal iff their flags, protocol, algorithm and public key fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataRKey.GetHashCode">
            <summary>
            A hash code based on the flags, protocol, algorithm and public key fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataRKey.Flags">
            <summary>
            Reserved and must be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataRKey.Protocol">
            <summary>
            Must be set to 1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataRKey.Algorithm">
            <summary>
            The key algorithm parallel to the same field for the SIG resource.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataRKey.PublicKey">
            <summary>
            The public key value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsGatewayDomainName">
            <summary>
            A gateway that is represented using a domain name.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayDomainName.#ctor(PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Creates the gateway using the given domain name.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayDomainName.Equals(PcapDotNet.Packets.Dns.DnsGatewayDomainName)">
            <summary>
            Two DnsGatewayDomainName are equal if their domain name values are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsGatewayDomainName.Equals(PcapDotNet.Packets.Dns.DnsGateway)">
            <summary>
            Two gateway representations are equal if they are of the same type and the value is the same.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayDomainName.Value">
            <summary>
            Returns the domain name value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayDomainName.GatewayType">
            <summary>
            The gateway represnetation type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsGatewayDomainName.Length">
            <summary>
            The number of bytes the gateway represnetation takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.AddressFamily">
            <summary>
             RFCs 2453, 2858, 4761, 6074.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.None">
            <summary>
            No address family defined.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.IpV4">
            <summary>
            IP (IP version 4).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.IpV6">
            <summary>
            IP6 (IP version 6).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.NetworkServiceAccessPoint">
            <summary>
            NSAP - Network Service Access Point.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.HighLevelDataLink">
            <summary>
            High-Level Data Link (8-bit multidrop).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.Bbn1822">
            <summary>
            BBN Report 1822.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.Media802">
            <summary>
            802 (includes all 802 media plus Ethernet "canonical format").
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.E163">
            <summary>
            E.163.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.E164">
            <summary>
            E.164 (SMDS, Frame Relay, ATM).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.F69">
            <summary>
            F.69 (Telex).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.X121">
            <summary>
            X.121 (X.25, Frame Relay).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.Ipx">
            <summary>
            IPX.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.AppleTalk">
            <summary>
            Appletalk.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.DecNetIv">
            <summary>
            Decnet IV.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.BanyanVines">
            <summary>
            Banyan Vines.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.E164WithNetworkServiceAccessPointFormatSubaddresses">
            <summary>
            E.164 with NSAP format subaddress.
            ATM Forum UNI 3.1. October 1995.
            Andy Malis.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.Dns">
            <summary>
            DNS (Domain Name System).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.DistinguishedName">
            <summary>
            Distinguished Name.
            Charles Lynn.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.AsNumber">
            <summary>
            AS Number.
            Charles Lynn.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.XtpOverIpV4">
            <summary>
            XTP over IP version 4.
            Mike Saul.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.XtpOverIpV6">
            <summary>
            XTP over IP version 6.
            Mike Saul.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.XtpNativeModeXtp">
            <summary>
            XTP native mode XTP.
            Mike Saul.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.FibreChannelWorldwidePortName">
            <summary>
            Fibre Channel World-Wide Port Name.
            Mark Bakke.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.FibreChannelWorldwideNodeName">
            <summary>
            Fibre Channel World-Wide Node Name.
            Mark Bakke.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.Gwid">
            <summary>
            GWID.
            Subra Hegde.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.AfiForL2VpnInformation">
            <summary>
            RFCs 4761, 6074.
            AFI for L2VPN information.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.EnhancedInteriorGatewayRoutingProtocolCommonServiceFamily">
            <summary>
            EIGRP Common Service Family.
            Donnie Savage.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.EnhancedInteriorGatewayRoutingProtocolIpV4ServiceFamily">
            <summary>
            EIGRP IPv4 Service Family.
            Donnie Savage.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.EnhancedInteriorGatewayRoutingProtocolIpV6ServiceFamily">
            <summary>
            EIGRP IPv6 Service Family.
            Donnie Savage.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.AddressFamily.LispCanonicalAddressFormat">
            <summary>
            LISP Canonical Address Format (LCAF).
            David Meyer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Address">
            <summary>
            Represents an IPv4 address.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Address.SizeOf">
            <summary>
            The number of bytes the address take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.#ctor(System.UInt32)">
            <summary>
            Create an address from a 32 bit integer.
            0 -> 0.0.0.0
            1 -> 0.0.0.1
            256 -> 0.0.1.0
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.#ctor(System.String)">
            <summary>
            Creates an address from an address string (1.2.3.4).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.ToValue">
            <summary>
            Gets the address value as a 32 bit integer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.Equals(PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.Equals(System.Object)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.op_Equality(PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.op_Inequality(PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Two addresses are different if the have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.GetHashCode">
            <summary>
            The hash code of an address is the hash code of its 32 bit integer value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.ToString">
            <summary>
            Translates the address to a string (1.2.3.4).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Address.Zero">
            <summary>
            The zero address (0.0.0.0).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Address.AllHostsGroupAddress">
            <summary>
            The all-hosts group. 
            If you ping that group, all multicast capable hosts on the network should answer, 
            as every multicast capable host must join that group at start-up on all it's multicast capable interfaces. 
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpCreateGroupRequestVersion0Code">
            <summary>
            The code of the IGMP message for Create Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpCreateGroupRequestVersion0Code.Public">
            <summary>
            Public.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpCreateGroupRequestVersion0Code.Private">
            <summary>
            Private.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram">
            <summary>
            Used to represent an ICMP datagram with an unknown message type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram.CalculateIsValid">
            <summary>
            Unknown ICMP datagrams are always invalid.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Take only part of the bytes as a datagarm.
            </summary>
            <param name="buffer">The bytes to take the datagram from.</param>
            <param name="offset">The offset in the buffer to start taking the bytes from.</param>
            <param name="length">The number of bytes to take.</param>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampReplyLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestMethod">
            <summary>
            HTTP request method.
            Example: GET
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.#ctor(System.String)">
            <summary>
            Creates a method from a method string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.#ctor(PcapDotNet.Packets.Http.HttpRequestKnownMethod)">
            <summary>
            Creates a method from a known method.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.Equals(PcapDotNet.Packets.Http.HttpRequestMethod)">
            <summary>
            Two methods are equal iff they have the same method string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.Equals(System.Object)">
            <summary>
            Two methods are equal iff they have the same method string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.GetHashCode">
            <summary>
            The hash code of the method string.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestMethod.Method">
            <summary>
            The method string.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestMethod.KnownMethod">
            <summary>
            Returns the known method that matches the method string.
            Returns HttpRequestKnownMethod.Unknown if no matching known method could be found.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestMethod.Length">
            <summary>
            The number of bytes this method takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown">
            <summary>
            Represents a source route entry consisting of an unknown data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.#ctor(PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily,PcapDotNet.Packets.Datagram,System.Int32)">
            <summary>
            Initializes using an address family, data, and offset to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
            <param name="addressFamily">The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.</param>
            <param name="data">The data of the entry source route.</param>
            <param name="offset">The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the payloads a are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.Data">
            <summary>
            The data of the entry source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.PayloadHashCode">
            <summary>
            The hash code of the payload.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreDatagram">
            <summary>
            RFC 1701, RFC 1702, RFC 2637, RFC 2784.
            <pre>
            +-----+---+---+---+---+---+-------+---+-------+---------+-------------------+
            | Bit | 0 | 1 | 2 | 3 | 4 | 5-7   | 8 | 9-12  | 13-15   | 16-31             |
            +-----+---+-----------+---+-------+---+-------+---------+-------------------+
            | 0   | C | R | K | S | s | Recur | A | Flags | Version | Protocol Type     |
            +-----+---+-----------+---+-------+---+-------+---------+-------------------+
            | 32  | Checksum (optional)                             | Offset (optional) |
            +-----+-------------------------------------------------+-------------------+
            | 32  | Key (optional)                                                      |
            +-----+---------------------------------------------------------------------+
            | 32  | Sequence Number (optional)                                          |
            +-----+---------------------------------------------------------------------+
            | 32  | Acknowledgment Number (optional)                                    |
            +-----+---------------------------------------------------------------------+
            | 32  | Routing (optional)                                                  |
            +-----+---------------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreDatagram.HeaderMinimumLength">
            <summary>
            The minimum number of bytes the GRE header can contain.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreDatagram.CalculateIsValid">
            <summary>
            A GRE Datagram is valid if its length is enough for the GRE header, its routing information is valid,
            the bits for future use are set to 0, it has acknowledgment sequence number only if it's Enhanced GRE,
            if it has checksum the checksum is correct and its payload is correct.
            </summary>
            <returns>true iff the datagram is valid.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.HeaderLength">
            <summary>
            The length of the full GRE header on bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.EtherType">
            <summary>
            Ethernet type (next protocol).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ChecksumPresent">
            <summary>
            If the Checksum Present bit is set to 1, then the Checksum field is present and contains valid information.
            If either the Checksum Present bit or the Routing Present bit are set, BOTH the Checksum and Offset fields are present in the GRE packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.RoutingPresent">
            <summary>
            If the Routing Present bit is set to 1, then it indicates that the Offset and Routing fields are present and contain valid information.
            If either the Checksum Present bit or the Routing Present bit are set, BOTH the Checksum and Offset fields are present in the GRE packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.KeyPresent">
            <summary>
            If the Key Present bit is set to 1, then it indicates that the Key field is present in the GRE header.  
            Otherwise, the Key field is not present in the GRE header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.SequenceNumberPresent">
            <summary>
            If the Sequence Number Present bit is set to 1, then it indicates that the Sequence Number field is present.  
            Otherwise, the Sequence Number field is not present in the GRE header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.StrictSourceRoute">
            <summary>
            If the source route is incomplete, then the Strict Source Route bit is checked.  
            If the source route is a strict source route and the next IP destination or autonomous system is NOT an adjacent system, the packet MUST be dropped.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.RecursionControl">
            <summary>
            Recursion control contains a three bit unsigned integer which contains the number of additional encapsulations which are permissible.  
            This SHOULD default to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.AcknowledgmentSequenceNumberPresent">
            <summary>
            Set to one (1) if packet contains Acknowledgment Number to be used for acknowledging previously transmitted data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.FutureUseBits">
            <summary>
            Must be set to zero (0).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Version">
            <summary>
            The GRE Version Number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ProtocolType">
            <summary>
            The Protocol Type field contains the protocol type of the payload packet. 
            These Protocol Types are defined in [RFC1700] as "ETHER TYPES" and in [ETYPES]. 
            An implementation receiving a packet containing a Protocol Type which is not listed in [RFC1700] or [ETYPES] SHOULD discard the packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Checksum">
            <summary>
            The Checksum field contains the IP (one's complement) checksum sum of the all the 16 bit words in the GRE header and the payload packet.
            For purposes of computing the checksum, the value of the checksum field is zero. 
            This field is present only if the Checksum Present bit is set to one.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.IsChecksumCorrect">
            <summary>
            True iff the checksum value is correct according to the datagram data.
            Valid only if the Checksum Present bit is set to one.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.RoutingOffset">
            <summary>
            The offset field indicates the octet offset from the start of the Routing field to the first octet of the active Source Route Entry to be examined.  
            This field is present if the Routing Present or the Checksum Present bit is set to 1, and contains valid information only if the Routing Present bit is set to 1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ActiveSourceRouteEntryIndex">
            <summary>
            The index in the Routing collection of the active source route entry.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ActiveSourceRouteEntry">
            <summary>
            The active Source Route Entry to be examined.
            Contains valid information only if the Routing Present bit is set to 1.
            if the offset points to the end of the routing information, returns null.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Key">
            <summary>
            The Key field contains a four octet number which was inserted by the encapsulator.  
            It may be used by the receiver to authenticate the source of the packet.  
            The Key field is only present if the Key Present field is set to 1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.KeyPayloadLength">
            <summary>
            (High 2 octets of Key) Size of the payload, not including the GRE header
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.KeyCallId">
            <summary>
            (Low 2 octets of Key) Contains the Peer's Call ID for the session to which this packet belongs.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.SequenceNumber">
            <summary>
            The Sequence Number field contains an unsigned 32 bit integer which is inserted by the encapsulator.  
            It may be used by the receiver to establish the order in which packets have been transmitted from the encapsulator to the receiver.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.AcknowledgmentSequenceNumber">
            <summary>
            Contains the sequence number of the highest numbered GRE packet received by the sending peer for this user session.
            Present if A bit (Bit 8) is one (1).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Routing">
            <summary>
            The Routing field is optional and is present only if the Routing Present bit is set to 1.
            The Routing field is a list of Source Route Entries (SREs). 
            Each SRE has the form:
            <pre>
            +-----+----------------+------------+------------+
            | Bit | 0-15           | 16-23      | 24-31      |
            +-----+----------------+------------+------------+
            | 0   | Address Family | SRE Offset | SRE Length |
            +-----+----------------+------------+------------+
            | 32  | Routing Information ...                  |
            +-----+------------------------------------------+
            </pre>
            The routing field is terminated with a "NULL" SRE containing an address family of type 0x0000 and a length of 0.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetLayer">
            <summary>
            Represents an Ethernet layer.
            <seealso cref="T:PcapDotNet.Packets.Ethernet.EthernetDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.#ctor">
            <summary>
            Creates an instance with zero values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.Equals(PcapDotNet.Packets.Ethernet.EthernetLayer)">
            <summary>
            Two Ethernet layers are equal if they have the same source, destination and ethernet type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two Ethernet layers are equal if they have the same source, destination and ethernet type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the hash codes of the layer length, data link, source and destination addresses and the ethernet type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.ToString">
            <summary>
            Contains the source, destination and ether type.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.Source">
            <summary>
            Ethernet source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.Destination">
            <summary>
            Ethernet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.DataLink">
            <summary>
            The kind of the data link of the layer.
            Can be null if this is not the first layer in the packet.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsTransactionKeyMode">
            <summary>
            RFC 2930.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsTransactionKeyMode.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsTransactionKeyMode.ServerAssignment">
            <summary>
            RFC 2930.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsTransactionKeyMode.DiffieHellmanExchange">
            <summary>
            RFC 2930.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsTransactionKeyMode.GssApiNegotiation">
            <summary>
            RFC 2930.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsTransactionKeyMode.ResolverAssignment">
            <summary>
            RFC 2930.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsTransactionKeyMode.KeyDeletion">
            <summary>
            RFC 2930.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure">
            <summary>
            RFC 4034.
            <pre>
            +------------------+
            | next domain name |
            |                  |
            +------------------+
            | type bit map     |
            |                  |
            +------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,System.Collections.Generic.IEnumerable{PcapDotNet.Packets.Dns.DnsType})">
             <summary>
             Constructs an instance from the next domain name and types exist fields.
             </summary>
             <param name="nextDomainName">
             Contains the next owner name (in the canonical ordering of the zone) that has authoritative data or contains a delegation point NS RRset;
             The value of the Next Domain Name field in the last NSEC record in the zone is the name of the zone apex (the owner name of the zone's SOA RR).
             This indicates that the owner name of the NSEC RR is the last name in the canonical ordering of the zone.
            
             Owner names of RRsets for which the given zone is not authoritative (such as glue records) must not be listed in the Next Domain Name
             unless at least one authoritative RRset exists at the same owner name.
             </param>
             <param name="typesExist">Identifies the RRset types that exist at the NSEC RR's owner name.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure.IsTypePresentForOwner(PcapDotNet.Packets.Dns.DnsType)">
            <summary>
            True iff the given dns type exists.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure.Equals(PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure)">
            <summary>
            Two DnsResourceDataNextDomainSecure are equal iff their next domain name and types exist fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure.Equals(System.Object)">
            <summary>
            Two DnsResourceDataNextDomainSecure are equal iff their next domain name and types exist fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure.GetHashCode">
            <summary>
            A hash code of the combined next domain name and types exist fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure.NextDomainName">
             <summary>
             Contains the next owner name (in the canonical ordering of the zone) that has authoritative data or contains a delegation point NS RRset;
             The value of the Next Domain Name field in the last NSEC record in the zone is the name of the zone apex (the owner name of the zone's SOA RR).
             This indicates that the owner name of the NSEC RR is the last name in the canonical ordering of the zone.
            
             Owner names of RRsets for which the given zone is not authoritative (such as glue records) must not be listed in the Next Domain Name
             unless at least one authoritative RRset exists at the same owner name.
             </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataNextDomainSecure.TypesExist">
            <summary>
            Identifies the RRset types that exist at the NSEC RR's owner name.
            Ordered by the DnsType value.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsResourceDataMailingListInfo">
            <summary>
            RFC 1035.
            <pre>
            +---------+
            | RMAILBX |
            +---------+
            | EMAILBX |
            +---------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Dns.DnsResourceDataMailingListInfo.#ctor(PcapDotNet.Packets.Dns.DnsDomainName,PcapDotNet.Packets.Dns.DnsDomainName)">
            <summary>
            Constructs a mailing list info resource data from mailing list and error mailbox.
            </summary>
            <param name="mailingList">
            Specifies a mailbox which is responsible for the mailing list or mailbox.
            If this domain name names the root, the owner of the MINFO RR is responsible for itself.
            Note that many existing mailing lists use a mailbox X-request for the RMAILBX field of mailing list X, e.g., Msgroup-request for Msgroup.
            This field provides a more general mechanism.
            </param>
            <param name="errorMailbox">
            Specifies a mailbox which is to receive error messages related to the mailing list or mailbox specified by the owner of the MINFO RR
            (similar to the ERRORS-TO: field which has been proposed).
            If this domain name names the root, errors should be returned to the sender of the message.
            </param>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataMailingListInfo.MailingList">
            <summary>
            Specifies a mailbox which is responsible for the mailing list or mailbox.
            If this domain name names the root, the owner of the MINFO RR is responsible for itself.
            Note that many existing mailing lists use a mailbox X-request for the RMAILBX field of mailing list X, e.g., Msgroup-request for Msgroup.
            This field provides a more general mechanism.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Dns.DnsResourceDataMailingListInfo.ErrorMailbox">
            <summary>
            Specifies a mailbox which is to receive error messages related to the mailing list or mailbox specified by the owner of the MINFO RR
            (similar to the ERRORS-TO: field which has been proposed).
            If this domain name names the root, errors should be returned to the sender of the message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsLongLivedQueryOpCode">
            <summary>
            http://files.dns-sd.org/draft-sekar-dns-llq.txt.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryOpCode.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryOpCode.Setup">
            <summary>
            An LLQ is initiated by a client, and is completed via a four-way handshake. 
            This handshake provides resilience to packet loss, demonstrates client reachability, and reduces denial of service attack opportunities.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryOpCode.Refresh">
            <summary>
            If the client desires to maintain the LLQ beyond the duration specified in the LEASE-LIFE field of the Request Acknowledgment,
            the client must send a Refresh Request.
            A Refresh Request is identical to an LLQ Challenge Response, but with the LLQ-OPCODE set to LLQ-REFRESH.
            Unlike a Challenge Response, a Refresh Request returns no answers.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsLongLivedQueryOpCode.Event">
            <summary>
            When a change ("event") occurs to a name server's zone, the server must check if the new or deleted resource records answer any LLQs.
            If so, the resource records must be sent to the LLQ requesters in the form of a gratuitous DNS response sent to the client,
            with the question(s) being answered in the Question section, and answers to these questions in the Answer section.
            The response also includes an OPT RR as the last record in the Additional section.
            This OPT RR contains, in its RDATA, an entry for each LLQ being answered in the message.
            Entries must include the LLQ-ID. This reduces the potential for spoof events being sent to a client.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Dns.DnsFingerprintType">
            <summary>
            RFC 4255.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsFingerprintType.None">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Dns.DnsFingerprintType.Sha1">
            <summary>
            RFC 4255.
            </summary>
        </member>
    </members>
</doc>
